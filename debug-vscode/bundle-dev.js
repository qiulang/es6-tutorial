/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/ui/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||\n  // is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||\n  // is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||\n  // double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit');\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch (e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch (e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/debug.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0,\n      i;\n\n  for (i in namespace) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n//# sourceURL=webpack:///./node_modules/debug/src/debug.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function (n) {\n  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function (type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events) this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler)) return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++) listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function (type, listener) {\n  var m;\n\n  if (!isFunction(listener)) throw TypeError('listener must be a function');\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function (type, listener) {\n  if (!isFunction(listener)) throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function (type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener)) throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type]) return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener || isFunction(list.listener) && list.listener === listener) {\n    delete this._events[type];\n    if (this._events.removeListener) this.emit('removeListener', type, listener);\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener) this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function (type) {\n  var key, listeners;\n\n  if (!this._events) return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function (type) {\n  var ret;\n  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function (type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Config.js":
/*!**********************************************!*\
  !*** ./node_modules/jssip/lib-es5/Config.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib-es5/Grammar.js\");\nvar URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib-es5/URI.js\");\nvar Socket = __webpack_require__(/*! ./Socket */ \"./node_modules/jssip/lib-es5/Socket.js\");\nvar Exceptions = __webpack_require__(/*! ./Exceptions */ \"./node_modules/jssip/lib-es5/Exceptions.js\");\n\n// Default settings.\nexports.settings = {\n  // SIP authentication.\n  authorization_user: null,\n  password: null,\n  realm: null,\n  ha1: null,\n\n  // SIP account.\n  display_name: null,\n  uri: null,\n  contact_uri: null,\n\n  // SIP instance id (GRUU).\n  instance_id: null,\n\n  // Preloaded SIP Route header field.\n  use_preloaded_route: false,\n\n  // Session parameters.\n  session_timers: true,\n  session_timers_refresh_method: JsSIP_C.UPDATE,\n  no_answer_timeout: 60,\n\n  // Registration parameters.\n  register: true,\n  register_expires: 600,\n  registrar_server: null,\n\n  // Connection options.\n  sockets: null,\n  connection_recovery_max_interval: null,\n  connection_recovery_min_interval: null,\n\n  /*\n   * Host address.\n   * Value to be set in Via sent_by and host part of Contact FQDN.\n  */\n  via_host: Utils.createRandomToken(12) + '.invalid'\n};\n\n// Configuration checks.\nvar checks = {\n  mandatory: {\n    sockets: function sockets(_sockets2) {\n      /* Allow defining sockets parameter as:\n       *  Socket: socket\n       *  Array of Socket: [socket1, socket2]\n       *  Array of Objects: [{socket: socket1, weight:1}, {socket: Socket2, weight:0}]\n       *  Array of Objects and Socket: [{socket: socket1}, socket2]\n       */\n      var _sockets = [];\n\n      if (Socket.isSocket(_sockets2)) {\n        _sockets.push({ socket: _sockets2 });\n      } else if (Array.isArray(_sockets2) && _sockets2.length) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = _sockets2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var socket = _step.value;\n\n            if (Object.prototype.hasOwnProperty.call(socket, 'socket') && Socket.isSocket(socket.socket)) {\n              _sockets.push(socket);\n            } else if (Socket.isSocket(socket)) {\n              _sockets.push({ socket: socket });\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        return;\n      }\n\n      return _sockets;\n    },\n    uri: function uri(_uri) {\n      if (!/^sip:/i.test(_uri)) {\n        _uri = JsSIP_C.SIP + ':' + _uri;\n      }\n      var parsed = URI.parse(_uri);\n\n      if (!parsed) {\n        return;\n      } else if (!parsed.user) {\n        return;\n      } else {\n        return parsed;\n      }\n    }\n  },\n\n  optional: {\n    authorization_user: function authorization_user(_authorization_user) {\n      if (Grammar.parse('\"' + _authorization_user + '\"', 'quoted_string') === -1) {\n        return;\n      } else {\n        return _authorization_user;\n      }\n    },\n    user_agent: function user_agent(_user_agent) {\n      if (typeof _user_agent === 'string') {\n        return _user_agent;\n      }\n    },\n    connection_recovery_max_interval: function connection_recovery_max_interval(_connection_recovery_max_interval) {\n      if (Utils.isDecimal(_connection_recovery_max_interval)) {\n        var value = Number(_connection_recovery_max_interval);\n\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n    connection_recovery_min_interval: function connection_recovery_min_interval(_connection_recovery_min_interval) {\n      if (Utils.isDecimal(_connection_recovery_min_interval)) {\n        var value = Number(_connection_recovery_min_interval);\n\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n    contact_uri: function contact_uri(_contact_uri) {\n      if (typeof _contact_uri === 'string') {\n        var uri = Grammar.parse(_contact_uri, 'SIP_URI');\n\n        if (uri !== -1) {\n          return uri;\n        }\n      }\n    },\n    display_name: function display_name(_display_name) {\n      if (Grammar.parse('\"' + _display_name + '\"', 'display_name') === -1) {\n        return;\n      } else {\n        return _display_name;\n      }\n    },\n    instance_id: function instance_id(_instance_id) {\n      if (/^uuid:/i.test(_instance_id)) {\n        _instance_id = _instance_id.substr(5);\n      }\n\n      if (Grammar.parse(_instance_id, 'uuid') === -1) {\n        return;\n      } else {\n        return _instance_id;\n      }\n    },\n    no_answer_timeout: function no_answer_timeout(_no_answer_timeout) {\n      if (Utils.isDecimal(_no_answer_timeout)) {\n        var value = Number(_no_answer_timeout);\n\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n    session_timers: function session_timers(_session_timers) {\n      if (typeof _session_timers === 'boolean') {\n        return _session_timers;\n      }\n    },\n    session_timers_refresh_method: function session_timers_refresh_method(method) {\n      if (typeof method === 'string') {\n        method = method.toUpperCase();\n\n        if (method === JsSIP_C.INVITE || method === JsSIP_C.UPDATE) {\n          return method;\n        }\n      }\n    },\n    password: function password(_password) {\n      return String(_password);\n    },\n    realm: function realm(_realm) {\n      return String(_realm);\n    },\n    ha1: function ha1(_ha) {\n      return String(_ha);\n    },\n    register: function register(_register) {\n      if (typeof _register === 'boolean') {\n        return _register;\n      }\n    },\n    register_expires: function register_expires(_register_expires) {\n      if (Utils.isDecimal(_register_expires)) {\n        var value = Number(_register_expires);\n\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n    registrar_server: function registrar_server(_registrar_server) {\n      if (!/^sip:/i.test(_registrar_server)) {\n        _registrar_server = JsSIP_C.SIP + ':' + _registrar_server;\n      }\n\n      var parsed = URI.parse(_registrar_server);\n\n      if (!parsed) {\n        return;\n      } else if (parsed.user) {\n        return;\n      } else {\n        return parsed;\n      }\n    },\n    use_preloaded_route: function use_preloaded_route(_use_preloaded_route) {\n      if (typeof _use_preloaded_route === 'boolean') {\n        return _use_preloaded_route;\n      }\n    }\n  }\n};\n\nexports.load = function (dst, src) {\n  // Check Mandatory parameters.\n  for (var parameter in checks.mandatory) {\n    if (!src.hasOwnProperty(parameter)) {\n      throw new Exceptions.ConfigurationError(parameter);\n    } else {\n      var value = src[parameter];\n      var checked_value = checks.mandatory[parameter](value);\n\n      if (checked_value !== undefined) {\n        dst[parameter] = checked_value;\n      } else {\n        throw new Exceptions.ConfigurationError(parameter, value);\n      }\n    }\n  }\n\n  // Check Optional parameters.\n  for (var _parameter in checks.optional) {\n    if (src.hasOwnProperty(_parameter)) {\n      var _value = src[_parameter];\n\n      /* If the parameter value is null, empty string, undefined, empty array\n       * or it's a number with NaN value, then apply its default value.\n       */\n      if (Utils.isEmpty(_value)) {\n        continue;\n      }\n\n      var _checked_value = checks.optional[_parameter](_value);\n\n      if (_checked_value !== undefined) {\n        dst[_parameter] = _checked_value;\n      } else {\n        throw new Exceptions.ConfigurationError(_parameter, _value);\n      }\n    }\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Config.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Constants.js":
/*!*************************************************!*\
  !*** ./node_modules/jssip/lib-es5/Constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar pkg = __webpack_require__(/*! ../package.json */ \"./node_modules/jssip/package.json\");\n\nmodule.exports = {\n  USER_AGENT: pkg.title + ' ' + pkg.version,\n\n  // SIP scheme.\n  SIP: 'sip',\n  SIPS: 'sips',\n\n  // End and Failure causes.\n  causes: {\n    // Generic error causes.\n    CONNECTION_ERROR: 'Connection Error',\n    REQUEST_TIMEOUT: 'Request Timeout',\n    SIP_FAILURE_CODE: 'SIP Failure Code',\n    INTERNAL_ERROR: 'Internal Error',\n\n    // SIP error causes.\n    BUSY: 'Busy',\n    REJECTED: 'Rejected',\n    REDIRECTED: 'Redirected',\n    UNAVAILABLE: 'Unavailable',\n    NOT_FOUND: 'Not Found',\n    ADDRESS_INCOMPLETE: 'Address Incomplete',\n    INCOMPATIBLE_SDP: 'Incompatible SDP',\n    MISSING_SDP: 'Missing SDP',\n    AUTHENTICATION_ERROR: 'Authentication Error',\n\n    // Session error causes.\n    BYE: 'Terminated',\n    WEBRTC_ERROR: 'WebRTC Error',\n    CANCELED: 'Canceled',\n    NO_ANSWER: 'No Answer',\n    EXPIRES: 'Expires',\n    NO_ACK: 'No ACK',\n    DIALOG_ERROR: 'Dialog Error',\n    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',\n    BAD_MEDIA_DESCRIPTION: 'Bad Media Description',\n    RTP_TIMEOUT: 'RTP Timeout'\n  },\n\n  SIP_ERROR_CAUSES: {\n    REDIRECTED: [300, 301, 302, 305, 380],\n    BUSY: [486, 600],\n    REJECTED: [403, 603],\n    NOT_FOUND: [404, 604],\n    UNAVAILABLE: [480, 410, 408, 430],\n    ADDRESS_INCOMPLETE: [484, 424],\n    INCOMPATIBLE_SDP: [488, 606],\n    AUTHENTICATION_ERROR: [401, 407]\n  },\n\n  // SIP Methods.\n  ACK: 'ACK',\n  BYE: 'BYE',\n  CANCEL: 'CANCEL',\n  INFO: 'INFO',\n  INVITE: 'INVITE',\n  MESSAGE: 'MESSAGE',\n  NOTIFY: 'NOTIFY',\n  OPTIONS: 'OPTIONS',\n  REGISTER: 'REGISTER',\n  REFER: 'REFER',\n  UPDATE: 'UPDATE',\n  SUBSCRIBE: 'SUBSCRIBE',\n\n  /* SIP Response Reasons\n   * DOC: http://www.iana.org/assignments/sip-parameters\n   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7\n   */\n  REASON_PHRASE: {\n    100: 'Trying',\n    180: 'Ringing',\n    181: 'Call Is Being Forwarded',\n    182: 'Queued',\n    183: 'Session Progress',\n    199: 'Early Dialog Terminated', // draft-ietf-sipcore-199\n    200: 'OK',\n    202: 'Accepted', // RFC 3265\n    204: 'No Notification', // RFC 5839\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Moved Temporarily',\n    305: 'Use Proxy',\n    380: 'Alternative Service',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    410: 'Gone',\n    412: 'Conditional Request Failed', // RFC 3903\n    413: 'Request Entity Too Large',\n    414: 'Request-URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Unsupported URI Scheme',\n    417: 'Unknown Resource-Priority', // RFC 4412\n    420: 'Bad Extension',\n    421: 'Extension Required',\n    422: 'Session Interval Too Small', // RFC 4028\n    423: 'Interval Too Brief',\n    424: 'Bad Location Information', // RFC 6442\n    428: 'Use Identity Header', // RFC 4474\n    429: 'Provide Referrer Identity', // RFC 3892\n    430: 'Flow Failed', // RFC 5626\n    433: 'Anonymity Disallowed', // RFC 5079\n    436: 'Bad Identity-Info', // RFC 4474\n    437: 'Unsupported Certificate', // RFC 4744\n    438: 'Invalid Identity Header', // RFC 4744\n    439: 'First Hop Lacks Outbound Support', // RFC 5626\n    440: 'Max-Breadth Exceeded', // RFC 5393\n    469: 'Bad Info Package', // draft-ietf-sipcore-info-events\n    470: 'Consent Needed', // RFC 5360\n    478: 'Unresolvable Destination', // Custom code copied from Kamailio.\n    480: 'Temporarily Unavailable',\n    481: 'Call/Transaction Does Not Exist',\n    482: 'Loop Detected',\n    483: 'Too Many Hops',\n    484: 'Address Incomplete',\n    485: 'Ambiguous',\n    486: 'Busy Here',\n    487: 'Request Terminated',\n    488: 'Not Acceptable Here',\n    489: 'Bad Event', // RFC 3265\n    491: 'Request Pending',\n    493: 'Undecipherable',\n    494: 'Security Agreement Required', // RFC 3329\n    500: 'JsSIP Internal Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Server Time-out',\n    505: 'Version Not Supported',\n    513: 'Message Too Large',\n    580: 'Precondition Failure', // RFC 3312\n    600: 'Busy Everywhere',\n    603: 'Decline',\n    604: 'Does Not Exist Anywhere',\n    606: 'Not Acceptable'\n  },\n\n  ALLOWED_METHODS: 'INVITE,ACK,CANCEL,BYE,UPDATE,MESSAGE,OPTIONS,REFER,INFO',\n  ACCEPTED_BODY_TYPES: 'application/sdp, application/dtmf-relay',\n  MAX_FORWARDS: 69,\n  SESSION_EXPIRES: 90,\n  MIN_SESSION_EXPIRES: 60\n};\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Constants.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Dialog.js":
/*!**********************************************!*\
  !*** ./node_modules/jssip/lib-es5/Dialog.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib-es5/SIPMessage.js\");\nvar JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar Transactions = __webpack_require__(/*! ./Transactions */ \"./node_modules/jssip/lib-es5/Transactions.js\");\nvar Dialog_RequestSender = __webpack_require__(/*! ./Dialog/RequestSender */ \"./node_modules/jssip/lib-es5/Dialog/RequestSender.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:Dialog');\n\nvar C = {\n  // Dialog states.\n  STATUS_EARLY: 1,\n  STATUS_CONFIRMED: 2\n};\n\n// RFC 3261 12.1.\nmodule.exports = function () {\n  _createClass(Dialog, null, [{\n    key: 'C',\n\n    // Expose C object.\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  function Dialog(owner, message, type) {\n    var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : C.STATUS_CONFIRMED;\n\n    _classCallCheck(this, Dialog);\n\n    this._owner = owner;\n    this._ua = owner._ua;\n\n    this._uac_pending_reply = false;\n    this._uas_pending_reply = false;\n\n    if (!message.hasHeader('contact')) {\n      return {\n        error: 'unable to create a Dialog without Contact header field'\n      };\n    }\n\n    if (message instanceof SIPMessage.IncomingResponse) {\n      state = message.status_code < 200 ? C.STATUS_EARLY : C.STATUS_CONFIRMED;\n    }\n\n    var contact = message.parseHeader('contact');\n\n    // RFC 3261 12.1.1.\n    if (type === 'UAS') {\n      this._id = {\n        call_id: message.call_id,\n        local_tag: message.to_tag,\n        remote_tag: message.from_tag,\n        toString: function toString() {\n          return this.call_id + this.local_tag + this.remote_tag;\n        }\n      };\n      this._state = state;\n      this._remote_seqnum = message.cseq;\n      this._local_uri = message.parseHeader('to').uri;\n      this._remote_uri = message.parseHeader('from').uri;\n      this._remote_target = contact.uri;\n      this._route_set = message.getHeaders('record-route');\n      this._ack_seqnum = this._remote_seqnum;\n    }\n    // RFC 3261 12.1.2.\n    else if (type === 'UAC') {\n        this._id = {\n          call_id: message.call_id,\n          local_tag: message.from_tag,\n          remote_tag: message.to_tag,\n          toString: function toString() {\n            return this.call_id + this.local_tag + this.remote_tag;\n          }\n        };\n        this._state = state;\n        this._local_seqnum = message.cseq;\n        this._local_uri = message.parseHeader('from').uri;\n        this._remote_uri = message.parseHeader('to').uri;\n        this._remote_target = contact.uri;\n        this._route_set = message.getHeaders('record-route').reverse();\n        this._ack_seqnum = null;\n      }\n\n    this._ua.newDialog(this);\n    debug('new ' + type + ' dialog created with status ' + (this._state === C.STATUS_EARLY ? 'EARLY' : 'CONFIRMED'));\n  }\n\n  _createClass(Dialog, [{\n    key: 'update',\n    value: function update(message, type) {\n      this._state = C.STATUS_CONFIRMED;\n\n      debug('dialog ' + this._id.toString() + '  changed to CONFIRMED state');\n\n      if (type === 'UAC') {\n        // RFC 3261 13.2.2.4.\n        this._route_set = message.getHeaders('record-route').reverse();\n      }\n    }\n  }, {\n    key: 'terminate',\n    value: function terminate() {\n      debug('dialog ' + this._id.toString() + ' deleted');\n      this._ua.destroyDialog(this);\n    }\n  }, {\n    key: 'sendRequest',\n    value: function sendRequest(method) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n      var body = options.body || null;\n      var request = this._createRequest(method, extraHeaders, body);\n\n      // Increase the local CSeq on authentication.\n      eventHandlers.onAuthenticated = function () {\n        _this._local_seqnum += 1;\n      };\n\n      var request_sender = new Dialog_RequestSender(this, request, eventHandlers);\n\n      request_sender.send();\n\n      // Return the instance of OutgoingRequest.\n      return request;\n    }\n  }, {\n    key: 'receiveRequest',\n    value: function receiveRequest(request) {\n      // Check in-dialog request.\n      if (!this._checkInDialogRequest(request)) {\n        return;\n      }\n\n      // ACK received. Cleanup this._ack_seqnum.\n      if (request.method === JsSIP_C.ACK && this._ack_seqnum !== null) {\n        this._ack_seqnum = null;\n      }\n      // INVITE received. Set this._ack_seqnum.\n      else if (request.method === JsSIP_C.INVITE) {\n          this._ack_seqnum = request.cseq;\n        }\n\n      this._owner.receiveRequest(request);\n    }\n\n    // RFC 3261 12.2.1.1.\n\n  }, {\n    key: '_createRequest',\n    value: function _createRequest(method, extraHeaders, body) {\n      extraHeaders = Utils.cloneArray(extraHeaders);\n\n      if (!this._local_seqnum) {\n        this._local_seqnum = Math.floor(Math.random() * 10000);\n      }\n\n      var cseq = method === JsSIP_C.CANCEL || method === JsSIP_C.ACK ? this._local_seqnum : this._local_seqnum += 1;\n\n      var request = new SIPMessage.OutgoingRequest(method, this._remote_target, this._ua, {\n        'cseq': cseq,\n        'call_id': this._id.call_id,\n        'from_uri': this._local_uri,\n        'from_tag': this._id.local_tag,\n        'to_uri': this._remote_uri,\n        'to_tag': this._id.remote_tag,\n        'route_set': this._route_set\n      }, extraHeaders, body);\n\n      return request;\n    }\n\n    // RFC 3261 12.2.2.\n\n  }, {\n    key: '_checkInDialogRequest',\n    value: function _checkInDialogRequest(request) {\n      var _this2 = this;\n\n      if (!this._remote_seqnum) {\n        this._remote_seqnum = request.cseq;\n      } else if (request.cseq < this._remote_seqnum) {\n        if (request.method === JsSIP_C.ACK) {\n          // We are not expecting any ACK with lower seqnum than the current one.\n          // Or this is not the ACK we are waiting for.\n          if (this._ack_seqnum === null || request.cseq !== this._ack_seqnum) {\n            return false;\n          }\n        } else {\n          request.reply(500);\n\n          return false;\n        }\n      } else if (request.cseq > this._remote_seqnum) {\n        this._remote_seqnum = request.cseq;\n      }\n\n      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-.\n      if (request.method === JsSIP_C.INVITE || request.method === JsSIP_C.UPDATE && request.body) {\n        if (this._uac_pending_reply === true) {\n          request.reply(491);\n        } else if (this._uas_pending_reply === true) {\n          var retryAfter = (Math.random() * 10 | 0) + 1;\n\n          request.reply(500, null, ['Retry-After:' + retryAfter]);\n\n          return false;\n        } else {\n          this._uas_pending_reply = true;\n\n          var stateChanged = function stateChanged() {\n            if (request.server_transaction.state === Transactions.C.STATUS_ACCEPTED || request.server_transaction.state === Transactions.C.STATUS_COMPLETED || request.server_transaction.state === Transactions.C.STATUS_TERMINATED) {\n\n              request.server_transaction.removeListener('stateChanged', stateChanged);\n              _this2._uas_pending_reply = false;\n            }\n          };\n\n          request.server_transaction.on('stateChanged', stateChanged);\n        }\n\n        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted.\n        if (request.hasHeader('contact')) {\n          request.server_transaction.on('stateChanged', function () {\n            if (request.server_transaction.state === Transactions.C.STATUS_ACCEPTED) {\n              _this2._remote_target = request.parseHeader('contact').uri;\n            }\n          });\n        }\n      } else if (request.method === JsSIP_C.NOTIFY) {\n        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted.\n        if (request.hasHeader('contact')) {\n          request.server_transaction.on('stateChanged', function () {\n            if (request.server_transaction.state === Transactions.C.STATUS_COMPLETED) {\n              _this2._remote_target = request.parseHeader('contact').uri;\n            }\n          });\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'id',\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: 'local_seqnum',\n    get: function get() {\n      return this._local_seqnum;\n    },\n    set: function set(num) {\n      this._local_seqnum = num;\n    }\n  }, {\n    key: 'owner',\n    get: function get() {\n      return this._owner;\n    }\n  }, {\n    key: 'uac_pending_reply',\n    get: function get() {\n      return this._uac_pending_reply;\n    },\n    set: function set(pending) {\n      this._uac_pending_reply = pending;\n    }\n  }, {\n    key: 'uas_pending_reply',\n    get: function get() {\n      return this._uas_pending_reply;\n    }\n  }]);\n\n  return Dialog;\n}();\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Dialog.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Dialog/RequestSender.js":
/*!************************************************************!*\
  !*** ./node_modules/jssip/lib-es5/Dialog/RequestSender.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar JsSIP_C = __webpack_require__(/*! ../Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar Transactions = __webpack_require__(/*! ../Transactions */ \"./node_modules/jssip/lib-es5/Transactions.js\");\nvar RTCSession = __webpack_require__(/*! ../RTCSession */ \"./node_modules/jssip/lib-es5/RTCSession.js\");\nvar RequestSender = __webpack_require__(/*! ../RequestSender */ \"./node_modules/jssip/lib-es5/RequestSender.js\");\n\n// Default event handlers.\nvar EventHandlers = {\n  onRequestTimeout: function onRequestTimeout() {},\n  onTransportError: function onTransportError() {},\n  onSuccessResponse: function onSuccessResponse() {},\n  onErrorResponse: function onErrorResponse() {},\n  onAuthenticated: function onAuthenticated() {},\n  onDialogError: function onDialogError() {}\n};\n\nmodule.exports = function () {\n  function DialogRequestSender(dialog, request, eventHandlers) {\n    _classCallCheck(this, DialogRequestSender);\n\n    this._dialog = dialog;\n    this._ua = dialog._ua;\n    this._request = request;\n    this._eventHandlers = eventHandlers;\n\n    // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.\n    this._reattempt = false;\n    this._reattemptTimer = null;\n\n    // Define the undefined handlers.\n    for (var handler in EventHandlers) {\n      if (Object.prototype.hasOwnProperty.call(EventHandlers, handler)) {\n        if (!this._eventHandlers[handler]) {\n          this._eventHandlers[handler] = EventHandlers[handler];\n        }\n      }\n    }\n  }\n\n  _createClass(DialogRequestSender, [{\n    key: 'send',\n    value: function send() {\n      var _this = this;\n\n      var request_sender = new RequestSender(this._ua, this._request, {\n        onRequestTimeout: function onRequestTimeout() {\n          _this._eventHandlers.onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          _this._eventHandlers.onTransportError();\n        },\n        onAuthenticated: function onAuthenticated(request) {\n          _this._eventHandlers.onAuthenticated(request);\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          _this._receiveResponse(response);\n        }\n      });\n\n      request_sender.send();\n\n      // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-.\n      if ((this._request.method === JsSIP_C.INVITE || this._request.method === JsSIP_C.UPDATE && this._request.body) && request_sender.clientTransaction.state !== Transactions.C.STATUS_TERMINATED) {\n        this._dialog.uac_pending_reply = true;\n\n        var stateChanged = function stateChanged() {\n          if (request_sender.clientTransaction.state === Transactions.C.STATUS_ACCEPTED || request_sender.clientTransaction.state === Transactions.C.STATUS_COMPLETED || request_sender.clientTransaction.state === Transactions.C.STATUS_TERMINATED) {\n            request_sender.clientTransaction.removeListener('stateChanged', stateChanged);\n            _this._dialog.uac_pending_reply = false;\n          }\n        };\n\n        request_sender.clientTransaction.on('stateChanged', stateChanged);\n      }\n    }\n  }, {\n    key: '_receiveResponse',\n    value: function _receiveResponse(response) {\n      var _this2 = this;\n\n      // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.\n      if (response.status_code === 408 || response.status_code === 481) {\n        this._eventHandlers.onDialogError(response);\n      } else if (response.method === JsSIP_C.INVITE && response.status_code === 491) {\n        if (this._reattempt) {\n          if (response.status_code >= 200 && response.status_code < 300) {\n            this._eventHandlers.onSuccessResponse(response);\n          } else if (response.status_code >= 300) {\n            this._eventHandlers.onErrorResponse(response);\n          }\n        } else {\n          this._request.cseq.value = this._dialog.local_seqnum += 1;\n          this._reattemptTimer = setTimeout(function () {\n            // TODO: look at dialog state instead.\n            if (_this2._dialog.owner.status !== RTCSession.C.STATUS_TERMINATED) {\n              _this2._reattempt = true;\n              _this2._request_sender.send();\n            }\n          }, 1000);\n        }\n      } else if (response.status_code >= 200 && response.status_code < 300) {\n        this._eventHandlers.onSuccessResponse(response);\n      } else if (response.status_code >= 300) {\n        this._eventHandlers.onErrorResponse(response);\n      }\n    }\n  }, {\n    key: 'request',\n    get: function get() {\n      return this._request;\n    }\n  }]);\n\n  return DialogRequestSender;\n}();\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Dialog/RequestSender.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/DigestAuthentication.js":
/*!************************************************************!*\
  !*** ./node_modules/jssip/lib-es5/DigestAuthentication.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:DigestAuthentication');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:ERROR:DigestAuthentication');\n\ndebugerror.log = console.warn.bind(console);\n\nmodule.exports = function () {\n  function DigestAuthentication(credentials) {\n    _classCallCheck(this, DigestAuthentication);\n\n    this._credentials = credentials;\n    this._cnonce = null;\n    this._nc = 0;\n    this._ncHex = '00000000';\n    this._algorithm = null;\n    this._realm = null;\n    this._nonce = null;\n    this._opaque = null;\n    this._stale = null;\n    this._qop = null;\n    this._method = null;\n    this._uri = null;\n    this._ha1 = null;\n    this._response = null;\n  }\n\n  _createClass(DigestAuthentication, [{\n    key: 'get',\n    value: function get(parameter) {\n      switch (parameter) {\n        case 'realm':\n          return this._realm;\n\n        case 'ha1':\n          return this._ha1;\n\n        default:\n          debugerror('get() | cannot get \"%s\" parameter', parameter);\n\n          return undefined;\n      }\n    }\n\n    /**\n    * Performs Digest authentication given a SIP request and the challenge\n    * received in a response to that request.\n    * Returns true if auth was successfully generated, false otherwise.\n    */\n\n  }, {\n    key: 'authenticate',\n    value: function authenticate(_ref, challenge) /* test interface */{\n      var method = _ref.method,\n          ruri = _ref.ruri,\n          body = _ref.body;\n      var cnonce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      this._algorithm = challenge.algorithm;\n      this._realm = challenge.realm;\n      this._nonce = challenge.nonce;\n      this._opaque = challenge.opaque;\n      this._stale = challenge.stale;\n\n      if (this._algorithm) {\n        if (this._algorithm !== 'MD5') {\n          debugerror('authenticate() | challenge with Digest algorithm different than \"MD5\", authentication aborted');\n\n          return false;\n        }\n      } else {\n        this._algorithm = 'MD5';\n      }\n\n      if (!this._nonce) {\n        debugerror('authenticate() | challenge without Digest nonce, authentication aborted');\n\n        return false;\n      }\n\n      if (!this._realm) {\n        debugerror('authenticate() | challenge without Digest realm, authentication aborted');\n\n        return false;\n      }\n\n      // If no plain SIP password is provided.\n      if (!this._credentials.password) {\n        // If ha1 is not provided we cannot authenticate.\n        if (!this._credentials.ha1) {\n          debugerror('authenticate() | no plain SIP password nor ha1 provided, authentication aborted');\n\n          return false;\n        }\n\n        // If the realm does not match the stored realm we cannot authenticate.\n        if (this._credentials.realm !== this._realm) {\n          debugerror('authenticate() | no plain SIP password, and stored `realm` does not match the given `realm`, cannot authenticate [stored:\"%s\", given:\"%s\"]', this._credentials.realm, this._realm);\n\n          return false;\n        }\n      }\n\n      // 'qop' can contain a list of values (Array). Let's choose just one.\n      if (challenge.qop) {\n        if (challenge.qop.indexOf('auth-int') > -1) {\n          this._qop = 'auth-int';\n        } else if (challenge.qop.indexOf('auth') > -1) {\n          this._qop = 'auth';\n        } else {\n          // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n          debugerror('authenticate() | challenge without Digest qop different than \"auth\" or \"auth-int\", authentication aborted');\n\n          return false;\n        }\n      } else {\n        this._qop = null;\n      }\n\n      // Fill other attributes.\n\n      this._method = method;\n      this._uri = ruri;\n      this._cnonce = cnonce || Utils.createRandomToken(12);\n      this._nc += 1;\n      var hex = Number(this._nc).toString(16);\n\n      this._ncHex = '00000000'.substr(0, 8 - hex.length) + hex;\n\n      // Nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n      if (this._nc === 4294967296) {\n        this._nc = 1;\n        this._ncHex = '00000001';\n      }\n\n      // Calculate the Digest \"response\" value.\n\n      // If we have plain SIP password then regenerate ha1.\n      if (this._credentials.password) {\n        // HA1 = MD5(A1) = MD5(username:realm:password).\n        this._ha1 = Utils.calculateMD5(this._credentials.username + ':' + this._realm + ':' + this._credentials.password);\n      }\n      // Otherwise reuse the stored ha1.\n      else {\n          this._ha1 = this._credentials.ha1;\n        }\n\n      var ha2 = void 0;\n\n      if (this._qop === 'auth') {\n        // HA2 = MD5(A2) = MD5(method:digestURI).\n        ha2 = Utils.calculateMD5(this._method + ':' + this._uri);\n        // Response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2).\n        this._response = Utils.calculateMD5(this._ha1 + ':' + this._nonce + ':' + this._ncHex + ':' + this._cnonce + ':auth:' + ha2);\n      } else if (this._qop === 'auth-int') {\n        // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody)).\n        ha2 = Utils.calculateMD5(this._method + ':' + this._uri + ':' + Utils.calculateMD5(body ? body : ''));\n        // Response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2).\n        this._response = Utils.calculateMD5(this._ha1 + ':' + this._nonce + ':' + this._ncHex + ':' + this._cnonce + ':auth-int:' + ha2);\n      } else if (this._qop === null) {\n        // HA2 = MD5(A2) = MD5(method:digestURI).\n        ha2 = Utils.calculateMD5(this._method + ':' + this._uri);\n        // Response = MD5(HA1:nonce:HA2).\n        this._response = Utils.calculateMD5(this._ha1 + ':' + this._nonce + ':' + ha2);\n      }\n\n      debug('authenticate() | response generated');\n\n      return true;\n    }\n\n    /**\n    * Return the Proxy-Authorization or WWW-Authorization header value.\n    */\n\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var auth_params = [];\n\n      if (!this._response) {\n        throw new Error('response field does not exist, cannot generate Authorization header');\n      }\n\n      auth_params.push('algorithm=' + this._algorithm);\n      auth_params.push('username=\"' + this._credentials.username + '\"');\n      auth_params.push('realm=\"' + this._realm + '\"');\n      auth_params.push('nonce=\"' + this._nonce + '\"');\n      auth_params.push('uri=\"' + this._uri + '\"');\n      auth_params.push('response=\"' + this._response + '\"');\n      if (this._opaque) {\n        auth_params.push('opaque=\"' + this._opaque + '\"');\n      }\n      if (this._qop) {\n        auth_params.push('qop=' + this._qop);\n        auth_params.push('cnonce=\"' + this._cnonce + '\"');\n        auth_params.push('nc=' + this._ncHex);\n      }\n\n      return 'Digest ' + auth_params.join(', ');\n    }\n  }]);\n\n  return DigestAuthentication;\n}();\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/DigestAuthentication.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Exceptions.js":
/*!**************************************************!*\
  !*** ./node_modules/jssip/lib-es5/Exceptions.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar ConfigurationError = function (_Error) {\n  _inherits(ConfigurationError, _Error);\n\n  function ConfigurationError(parameter, value) {\n    _classCallCheck(this, ConfigurationError);\n\n    var _this = _possibleConstructorReturn(this, (ConfigurationError.__proto__ || Object.getPrototypeOf(ConfigurationError)).call(this));\n\n    _this.code = 1;\n    _this.name = 'CONFIGURATION_ERROR';\n    _this.parameter = parameter;\n    _this.value = value;\n    _this.message = !_this.value ? 'Missing parameter: ' + _this.parameter : 'Invalid value ' + JSON.stringify(_this.value) + ' for parameter \"' + _this.parameter + '\"';\n    return _this;\n  }\n\n  return ConfigurationError;\n}(Error);\n\nvar InvalidStateError = function (_Error2) {\n  _inherits(InvalidStateError, _Error2);\n\n  function InvalidStateError(status) {\n    _classCallCheck(this, InvalidStateError);\n\n    var _this2 = _possibleConstructorReturn(this, (InvalidStateError.__proto__ || Object.getPrototypeOf(InvalidStateError)).call(this));\n\n    _this2.code = 2;\n    _this2.name = 'INVALID_STATE_ERROR';\n    _this2.status = status;\n    _this2.message = 'Invalid status: ' + status;\n    return _this2;\n  }\n\n  return InvalidStateError;\n}(Error);\n\nvar NotSupportedError = function (_Error3) {\n  _inherits(NotSupportedError, _Error3);\n\n  function NotSupportedError(message) {\n    _classCallCheck(this, NotSupportedError);\n\n    var _this3 = _possibleConstructorReturn(this, (NotSupportedError.__proto__ || Object.getPrototypeOf(NotSupportedError)).call(this));\n\n    _this3.code = 3;\n    _this3.name = 'NOT_SUPPORTED_ERROR';\n    _this3.message = message;\n    return _this3;\n  }\n\n  return NotSupportedError;\n}(Error);\n\nvar NotReadyError = function (_Error4) {\n  _inherits(NotReadyError, _Error4);\n\n  function NotReadyError(message) {\n    _classCallCheck(this, NotReadyError);\n\n    var _this4 = _possibleConstructorReturn(this, (NotReadyError.__proto__ || Object.getPrototypeOf(NotReadyError)).call(this));\n\n    _this4.code = 4;\n    _this4.name = 'NOT_READY_ERROR';\n    _this4.message = message;\n    return _this4;\n  }\n\n  return NotReadyError;\n}(Error);\n\nmodule.exports = {\n  ConfigurationError: ConfigurationError,\n  InvalidStateError: InvalidStateError,\n  NotSupportedError: NotSupportedError,\n  NotReadyError: NotReadyError\n};\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Exceptions.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Grammar.js":
/*!***********************************************!*\
  !*** ./node_modules/jssip/lib-es5/Grammar.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function () {\n  /*\n   * Generated by PEG.js 0.7.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n  function quote(s) {\n    /*\n     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a\n     * string literal except for the closing quote character, backslash,\n     * carriage return, line separator, paragraph separator, and line feed.\n     * Any character may appear in the form of an escape sequence.\n     *\n     * For portability, we also escape escape all control and non-ASCII\n     * characters. Note that \"\\0\" and \"\\v\" escape sequences are not used\n     * because JSHint does not like the first and IE the second.\n     */\n    return '\"' + s.replace(/\\\\/g, '\\\\\\\\') // backslash\n    .replace(/\"/g, '\\\\\"') // closing quote character\n    .replace(/\\x08/g, '\\\\b') // backspace\n    .replace(/\\t/g, '\\\\t') // horizontal tab\n    .replace(/\\n/g, '\\\\n') // line feed\n    .replace(/\\f/g, '\\\\f') // form feed\n    .replace(/\\r/g, '\\\\r') // carriage return\n    .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape) + '\"';\n  }\n  var result = {\n    /*\n     * Parses the input with a generated parser. If the parsing is successfull,\n     * returns a value explicitly or implicitly specified by the grammar from\n     * which the parser was generated (see |PEG.buildParser|). If the parsing is\n     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.\n     */\n    parse: function parse(input, startRule) {\n      var parseFunctions = {\n        \"CRLF\": parse_CRLF,\n        \"DIGIT\": parse_DIGIT,\n        \"ALPHA\": parse_ALPHA,\n        \"HEXDIG\": parse_HEXDIG,\n        \"WSP\": parse_WSP,\n        \"OCTET\": parse_OCTET,\n        \"DQUOTE\": parse_DQUOTE,\n        \"SP\": parse_SP,\n        \"HTAB\": parse_HTAB,\n        \"alphanum\": parse_alphanum,\n        \"reserved\": parse_reserved,\n        \"unreserved\": parse_unreserved,\n        \"mark\": parse_mark,\n        \"escaped\": parse_escaped,\n        \"LWS\": parse_LWS,\n        \"SWS\": parse_SWS,\n        \"HCOLON\": parse_HCOLON,\n        \"TEXT_UTF8_TRIM\": parse_TEXT_UTF8_TRIM,\n        \"TEXT_UTF8char\": parse_TEXT_UTF8char,\n        \"UTF8_NONASCII\": parse_UTF8_NONASCII,\n        \"UTF8_CONT\": parse_UTF8_CONT,\n        \"LHEX\": parse_LHEX,\n        \"token\": parse_token,\n        \"token_nodot\": parse_token_nodot,\n        \"separators\": parse_separators,\n        \"word\": parse_word,\n        \"STAR\": parse_STAR,\n        \"SLASH\": parse_SLASH,\n        \"EQUAL\": parse_EQUAL,\n        \"LPAREN\": parse_LPAREN,\n        \"RPAREN\": parse_RPAREN,\n        \"RAQUOT\": parse_RAQUOT,\n        \"LAQUOT\": parse_LAQUOT,\n        \"COMMA\": parse_COMMA,\n        \"SEMI\": parse_SEMI,\n        \"COLON\": parse_COLON,\n        \"LDQUOT\": parse_LDQUOT,\n        \"RDQUOT\": parse_RDQUOT,\n        \"comment\": parse_comment,\n        \"ctext\": parse_ctext,\n        \"quoted_string\": parse_quoted_string,\n        \"quoted_string_clean\": parse_quoted_string_clean,\n        \"qdtext\": parse_qdtext,\n        \"quoted_pair\": parse_quoted_pair,\n        \"SIP_URI_noparams\": parse_SIP_URI_noparams,\n        \"SIP_URI\": parse_SIP_URI,\n        \"uri_scheme\": parse_uri_scheme,\n        \"uri_scheme_sips\": parse_uri_scheme_sips,\n        \"uri_scheme_sip\": parse_uri_scheme_sip,\n        \"userinfo\": parse_userinfo,\n        \"user\": parse_user,\n        \"user_unreserved\": parse_user_unreserved,\n        \"password\": parse_password,\n        \"hostport\": parse_hostport,\n        \"host\": parse_host,\n        \"hostname\": parse_hostname,\n        \"domainlabel\": parse_domainlabel,\n        \"toplabel\": parse_toplabel,\n        \"IPv6reference\": parse_IPv6reference,\n        \"IPv6address\": parse_IPv6address,\n        \"h16\": parse_h16,\n        \"ls32\": parse_ls32,\n        \"IPv4address\": parse_IPv4address,\n        \"dec_octet\": parse_dec_octet,\n        \"port\": parse_port,\n        \"uri_parameters\": parse_uri_parameters,\n        \"uri_parameter\": parse_uri_parameter,\n        \"transport_param\": parse_transport_param,\n        \"user_param\": parse_user_param,\n        \"method_param\": parse_method_param,\n        \"ttl_param\": parse_ttl_param,\n        \"maddr_param\": parse_maddr_param,\n        \"lr_param\": parse_lr_param,\n        \"other_param\": parse_other_param,\n        \"pname\": parse_pname,\n        \"pvalue\": parse_pvalue,\n        \"paramchar\": parse_paramchar,\n        \"param_unreserved\": parse_param_unreserved,\n        \"headers\": parse_headers,\n        \"header\": parse_header,\n        \"hname\": parse_hname,\n        \"hvalue\": parse_hvalue,\n        \"hnv_unreserved\": parse_hnv_unreserved,\n        \"Request_Response\": parse_Request_Response,\n        \"Request_Line\": parse_Request_Line,\n        \"Request_URI\": parse_Request_URI,\n        \"absoluteURI\": parse_absoluteURI,\n        \"hier_part\": parse_hier_part,\n        \"net_path\": parse_net_path,\n        \"abs_path\": parse_abs_path,\n        \"opaque_part\": parse_opaque_part,\n        \"uric\": parse_uric,\n        \"uric_no_slash\": parse_uric_no_slash,\n        \"path_segments\": parse_path_segments,\n        \"segment\": parse_segment,\n        \"param\": parse_param,\n        \"pchar\": parse_pchar,\n        \"scheme\": parse_scheme,\n        \"authority\": parse_authority,\n        \"srvr\": parse_srvr,\n        \"reg_name\": parse_reg_name,\n        \"query\": parse_query,\n        \"SIP_Version\": parse_SIP_Version,\n        \"INVITEm\": parse_INVITEm,\n        \"ACKm\": parse_ACKm,\n        \"OPTIONSm\": parse_OPTIONSm,\n        \"BYEm\": parse_BYEm,\n        \"CANCELm\": parse_CANCELm,\n        \"REGISTERm\": parse_REGISTERm,\n        \"SUBSCRIBEm\": parse_SUBSCRIBEm,\n        \"NOTIFYm\": parse_NOTIFYm,\n        \"REFERm\": parse_REFERm,\n        \"Method\": parse_Method,\n        \"Status_Line\": parse_Status_Line,\n        \"Status_Code\": parse_Status_Code,\n        \"extension_code\": parse_extension_code,\n        \"Reason_Phrase\": parse_Reason_Phrase,\n        \"Allow_Events\": parse_Allow_Events,\n        \"Call_ID\": parse_Call_ID,\n        \"Contact\": parse_Contact,\n        \"contact_param\": parse_contact_param,\n        \"name_addr\": parse_name_addr,\n        \"display_name\": parse_display_name,\n        \"contact_params\": parse_contact_params,\n        \"c_p_q\": parse_c_p_q,\n        \"c_p_expires\": parse_c_p_expires,\n        \"delta_seconds\": parse_delta_seconds,\n        \"qvalue\": parse_qvalue,\n        \"generic_param\": parse_generic_param,\n        \"gen_value\": parse_gen_value,\n        \"Content_Disposition\": parse_Content_Disposition,\n        \"disp_type\": parse_disp_type,\n        \"disp_param\": parse_disp_param,\n        \"handling_param\": parse_handling_param,\n        \"Content_Encoding\": parse_Content_Encoding,\n        \"Content_Length\": parse_Content_Length,\n        \"Content_Type\": parse_Content_Type,\n        \"media_type\": parse_media_type,\n        \"m_type\": parse_m_type,\n        \"discrete_type\": parse_discrete_type,\n        \"composite_type\": parse_composite_type,\n        \"extension_token\": parse_extension_token,\n        \"x_token\": parse_x_token,\n        \"m_subtype\": parse_m_subtype,\n        \"m_parameter\": parse_m_parameter,\n        \"m_value\": parse_m_value,\n        \"CSeq\": parse_CSeq,\n        \"CSeq_value\": parse_CSeq_value,\n        \"Expires\": parse_Expires,\n        \"Event\": parse_Event,\n        \"event_type\": parse_event_type,\n        \"From\": parse_From,\n        \"from_param\": parse_from_param,\n        \"tag_param\": parse_tag_param,\n        \"Max_Forwards\": parse_Max_Forwards,\n        \"Min_Expires\": parse_Min_Expires,\n        \"Name_Addr_Header\": parse_Name_Addr_Header,\n        \"Proxy_Authenticate\": parse_Proxy_Authenticate,\n        \"challenge\": parse_challenge,\n        \"other_challenge\": parse_other_challenge,\n        \"auth_param\": parse_auth_param,\n        \"digest_cln\": parse_digest_cln,\n        \"realm\": parse_realm,\n        \"realm_value\": parse_realm_value,\n        \"domain\": parse_domain,\n        \"URI\": parse_URI,\n        \"nonce\": parse_nonce,\n        \"nonce_value\": parse_nonce_value,\n        \"opaque\": parse_opaque,\n        \"stale\": parse_stale,\n        \"algorithm\": parse_algorithm,\n        \"qop_options\": parse_qop_options,\n        \"qop_value\": parse_qop_value,\n        \"Proxy_Require\": parse_Proxy_Require,\n        \"Record_Route\": parse_Record_Route,\n        \"rec_route\": parse_rec_route,\n        \"Reason\": parse_Reason,\n        \"reason_param\": parse_reason_param,\n        \"reason_cause\": parse_reason_cause,\n        \"Require\": parse_Require,\n        \"Route\": parse_Route,\n        \"route_param\": parse_route_param,\n        \"Subscription_State\": parse_Subscription_State,\n        \"substate_value\": parse_substate_value,\n        \"subexp_params\": parse_subexp_params,\n        \"event_reason_value\": parse_event_reason_value,\n        \"Subject\": parse_Subject,\n        \"Supported\": parse_Supported,\n        \"To\": parse_To,\n        \"to_param\": parse_to_param,\n        \"Via\": parse_Via,\n        \"via_param\": parse_via_param,\n        \"via_params\": parse_via_params,\n        \"via_ttl\": parse_via_ttl,\n        \"via_maddr\": parse_via_maddr,\n        \"via_received\": parse_via_received,\n        \"via_branch\": parse_via_branch,\n        \"response_port\": parse_response_port,\n        \"sent_protocol\": parse_sent_protocol,\n        \"protocol_name\": parse_protocol_name,\n        \"transport\": parse_transport,\n        \"sent_by\": parse_sent_by,\n        \"via_host\": parse_via_host,\n        \"via_port\": parse_via_port,\n        \"ttl\": parse_ttl,\n        \"WWW_Authenticate\": parse_WWW_Authenticate,\n        \"Session_Expires\": parse_Session_Expires,\n        \"s_e_expires\": parse_s_e_expires,\n        \"s_e_params\": parse_s_e_params,\n        \"s_e_refresher\": parse_s_e_refresher,\n        \"extension_header\": parse_extension_header,\n        \"header_value\": parse_header_value,\n        \"message_body\": parse_message_body,\n        \"uuid_URI\": parse_uuid_URI,\n        \"uuid\": parse_uuid,\n        \"hex4\": parse_hex4,\n        \"hex8\": parse_hex8,\n        \"hex12\": parse_hex12,\n        \"Refer_To\": parse_Refer_To,\n        \"Replaces\": parse_Replaces,\n        \"call_id\": parse_call_id,\n        \"replaces_param\": parse_replaces_param,\n        \"to_tag\": parse_to_tag,\n        \"from_tag\": parse_from_tag,\n        \"early_flag\": parse_early_flag\n      };\n      if (startRule !== undefined) {\n        if (parseFunctions[startRule] === undefined) {\n          throw new Error(\"Invalid rule name: \" + quote(startRule) + \".\");\n        }\n      } else {\n        startRule = \"CRLF\";\n      }\n      var pos = 0;\n      var reportFailures = 0;\n      var rightmostFailuresPos = 0;\n      var rightmostFailuresExpected = [];\n      function padLeft(input, padding, length) {\n        var result = input;\n        var padLength = length - input.length;\n        for (var i = 0; i < padLength; i++) {\n          result = padding + result;\n        }\n        return result;\n      }\n      function escape(ch) {\n        var charCode = ch.charCodeAt(0);\n        var escapeChar;\n        var length;\n        if (charCode <= 0xFF) {\n          escapeChar = 'x';\n          length = 2;\n        } else {\n          escapeChar = 'u';\n          length = 4;\n        }\n        return '\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);\n      }\n      function matchFailed(failure) {\n        if (pos < rightmostFailuresPos) {\n          return;\n        }\n        if (pos > rightmostFailuresPos) {\n          rightmostFailuresPos = pos;\n          rightmostFailuresExpected = [];\n        }\n        rightmostFailuresExpected.push(failure);\n      }\n      function parse_CRLF() {\n        var result0;\n        if (input.substr(pos, 2) === \"\\r\\n\") {\n          result0 = \"\\r\\n\";\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"\\\\r\\\\n\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_DIGIT() {\n        var result0;\n        if (/^[0-9]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[0-9]\");\n          }\n        }\n        return result0;\n      }\n      function parse_ALPHA() {\n        var result0;\n        if (/^[a-zA-Z]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[a-zA-Z]\");\n          }\n        }\n        return result0;\n      }\n      function parse_HEXDIG() {\n        var result0;\n        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[0-9a-fA-F]\");\n          }\n        }\n        return result0;\n      }\n      function parse_WSP() {\n        var result0;\n        result0 = parse_SP();\n        if (result0 === null) {\n          result0 = parse_HTAB();\n        }\n        return result0;\n      }\n      function parse_OCTET() {\n        var result0;\n        if (/^[\\0-\\xFF]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[\\\\0-\\\\xFF]\");\n          }\n        }\n        return result0;\n      }\n      function parse_DQUOTE() {\n        var result0;\n        if (/^[\"]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[\\\"]\");\n          }\n        }\n        return result0;\n      }\n      function parse_SP() {\n        var result0;\n        if (input.charCodeAt(pos) === 32) {\n          result0 = \" \";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\" \\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_HTAB() {\n        var result0;\n        if (input.charCodeAt(pos) === 9) {\n          result0 = \"\\t\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"\\\\t\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_alphanum() {\n        var result0;\n        if (/^[a-zA-Z0-9]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[a-zA-Z0-9]\");\n          }\n        }\n        return result0;\n      }\n      function parse_reserved() {\n        var result0;\n        if (input.charCodeAt(pos) === 59) {\n          result0 = \";\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\";\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 47) {\n            result0 = \"/\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 63) {\n              result0 = \"?\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"?\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 58) {\n                result0 = \":\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\":\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 64) {\n                  result0 = \"@\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"@\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 38) {\n                    result0 = \"&\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"&\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 61) {\n                      result0 = \"=\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"=\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 43) {\n                        result0 = \"+\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"+\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 36) {\n                          result0 = \"$\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"$\\\"\");\n                          }\n                        }\n                        if (result0 === null) {\n                          if (input.charCodeAt(pos) === 44) {\n                            result0 = \",\";\n                            pos++;\n                          } else {\n                            result0 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\",\\\"\");\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_unreserved() {\n        var result0;\n        result0 = parse_alphanum();\n        if (result0 === null) {\n          result0 = parse_mark();\n        }\n        return result0;\n      }\n      function parse_mark() {\n        var result0;\n        if (input.charCodeAt(pos) === 45) {\n          result0 = \"-\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"-\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 95) {\n            result0 = \"_\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"_\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 46) {\n              result0 = \".\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 33) {\n                result0 = \"!\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"!\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 126) {\n                  result0 = \"~\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"~\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 42) {\n                    result0 = \"*\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"*\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 39) {\n                      result0 = \"'\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"'\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 40) {\n                        result0 = \"(\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"(\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 41) {\n                          result0 = \")\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\")\\\"\");\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_escaped() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 37) {\n          result0 = \"%\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"%\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_HEXDIG();\n          if (result1 !== null) {\n            result2 = parse_HEXDIG();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, escaped) {\n            return escaped.join('');\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_LWS() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        pos2 = pos;\n        result0 = [];\n        result1 = parse_WSP();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_WSP();\n        }\n        if (result0 !== null) {\n          result1 = parse_CRLF();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos2;\n          }\n        } else {\n          result0 = null;\n          pos = pos2;\n        }\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result2 = parse_WSP();\n          if (result2 !== null) {\n            result1 = [];\n            while (result2 !== null) {\n              result1.push(result2);\n              result2 = parse_WSP();\n            }\n          } else {\n            result1 = null;\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \" \";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SWS() {\n        var result0;\n        result0 = parse_LWS();\n        result0 = result0 !== null ? result0 : \"\";\n        return result0;\n      }\n      function parse_HCOLON() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = [];\n        result1 = parse_SP();\n        if (result1 === null) {\n          result1 = parse_HTAB();\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_SP();\n          if (result1 === null) {\n            result1 = parse_HTAB();\n          }\n        }\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return ':';\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_TEXT_UTF8_TRIM() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result1 = parse_TEXT_UTF8char();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_TEXT_UTF8char();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = [];\n          result3 = parse_LWS();\n          while (result3 !== null) {\n            result2.push(result3);\n            result3 = parse_LWS();\n          }\n          if (result2 !== null) {\n            result3 = parse_TEXT_UTF8char();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = [];\n            result3 = parse_LWS();\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_LWS();\n            }\n            if (result2 !== null) {\n              result3 = parse_TEXT_UTF8char();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_TEXT_UTF8char() {\n        var result0;\n        if (/^[!-~]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[!-~]\");\n          }\n        }\n        if (result0 === null) {\n          result0 = parse_UTF8_NONASCII();\n        }\n        return result0;\n      }\n      function parse_UTF8_NONASCII() {\n        var result0;\n        if (/^[\\x80-\\uFFFF]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed('[\\\\x80-\\\\uFFFF]');\n          }\n        }\n        return result0;\n      }\n      function parse_UTF8_CONT() {\n        var result0;\n        if (/^[\\x80-\\xBF]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[\\\\x80-\\\\xBF]\");\n          }\n        }\n        return result0;\n      }\n      function parse_LHEX() {\n        var result0;\n        result0 = parse_DIGIT();\n        if (result0 === null) {\n          if (/^[a-f]/.test(input.charAt(pos))) {\n            result0 = input.charAt(pos);\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[a-f]\");\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_token() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_alphanum();\n        if (result1 === null) {\n          if (input.charCodeAt(pos) === 45) {\n            result1 = \"-\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"-\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 46) {\n              result1 = \".\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 33) {\n                result1 = \"!\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"!\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 37) {\n                  result1 = \"%\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"%\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 42) {\n                    result1 = \"*\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"*\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 95) {\n                      result1 = \"_\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"_\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 43) {\n                        result1 = \"+\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"+\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 96) {\n                          result1 = \"`\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"`\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 39) {\n                            result1 = \"'\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"'\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 126) {\n                              result1 = \"~\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"~\\\"\");\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_alphanum();\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result1 = \"-\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 46) {\n                  result1 = \".\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\".\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 33) {\n                    result1 = \"!\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"!\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 37) {\n                      result1 = \"%\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"%\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 42) {\n                        result1 = \"*\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"*\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 95) {\n                          result1 = \"_\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"_\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 43) {\n                            result1 = \"+\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"+\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 96) {\n                              result1 = \"`\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"`\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 39) {\n                                result1 = \"'\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"'\\\"\");\n                                }\n                              }\n                              if (result1 === null) {\n                                if (input.charCodeAt(pos) === 126) {\n                                  result1 = \"~\";\n                                  pos++;\n                                } else {\n                                  result1 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\"~\\\"\");\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_token_nodot() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_alphanum();\n        if (result1 === null) {\n          if (input.charCodeAt(pos) === 45) {\n            result1 = \"-\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"-\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 33) {\n              result1 = \"!\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"!\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 37) {\n                result1 = \"%\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"%\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 42) {\n                  result1 = \"*\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"*\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 95) {\n                    result1 = \"_\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"_\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 43) {\n                      result1 = \"+\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"+\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 96) {\n                        result1 = \"`\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"`\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 39) {\n                          result1 = \"'\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"'\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 126) {\n                            result1 = \"~\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"~\\\"\");\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_alphanum();\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result1 = \"-\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 33) {\n                  result1 = \"!\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"!\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 37) {\n                    result1 = \"%\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"%\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 42) {\n                      result1 = \"*\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"*\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 95) {\n                        result1 = \"_\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"_\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 43) {\n                          result1 = \"+\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"+\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 96) {\n                            result1 = \"`\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"`\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 39) {\n                              result1 = \"'\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"'\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 126) {\n                                result1 = \"~\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"~\\\"\");\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_separators() {\n        var result0;\n        if (input.charCodeAt(pos) === 40) {\n          result0 = \"(\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"(\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 41) {\n            result0 = \")\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\")\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 60) {\n              result0 = \"<\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"<\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 62) {\n                result0 = \">\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\">\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 64) {\n                  result0 = \"@\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"@\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 44) {\n                    result0 = \",\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\",\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 59) {\n                      result0 = \";\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\";\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result0 = \":\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 92) {\n                          result0 = \"\\\\\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"\\\\\\\\\\\"\");\n                          }\n                        }\n                        if (result0 === null) {\n                          result0 = parse_DQUOTE();\n                          if (result0 === null) {\n                            if (input.charCodeAt(pos) === 47) {\n                              result0 = \"/\";\n                              pos++;\n                            } else {\n                              result0 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"/\\\"\");\n                              }\n                            }\n                            if (result0 === null) {\n                              if (input.charCodeAt(pos) === 91) {\n                                result0 = \"[\";\n                                pos++;\n                              } else {\n                                result0 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"[\\\"\");\n                                }\n                              }\n                              if (result0 === null) {\n                                if (input.charCodeAt(pos) === 93) {\n                                  result0 = \"]\";\n                                  pos++;\n                                } else {\n                                  result0 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\"]\\\"\");\n                                  }\n                                }\n                                if (result0 === null) {\n                                  if (input.charCodeAt(pos) === 63) {\n                                    result0 = \"?\";\n                                    pos++;\n                                  } else {\n                                    result0 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\"?\\\"\");\n                                    }\n                                  }\n                                  if (result0 === null) {\n                                    if (input.charCodeAt(pos) === 61) {\n                                      result0 = \"=\";\n                                      pos++;\n                                    } else {\n                                      result0 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\"=\\\"\");\n                                      }\n                                    }\n                                    if (result0 === null) {\n                                      if (input.charCodeAt(pos) === 123) {\n                                        result0 = \"{\";\n                                        pos++;\n                                      } else {\n                                        result0 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\"{\\\"\");\n                                        }\n                                      }\n                                      if (result0 === null) {\n                                        if (input.charCodeAt(pos) === 125) {\n                                          result0 = \"}\";\n                                          pos++;\n                                        } else {\n                                          result0 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\"}\\\"\");\n                                          }\n                                        }\n                                        if (result0 === null) {\n                                          result0 = parse_SP();\n                                          if (result0 === null) {\n                                            result0 = parse_HTAB();\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_word() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_alphanum();\n        if (result1 === null) {\n          if (input.charCodeAt(pos) === 45) {\n            result1 = \"-\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"-\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 46) {\n              result1 = \".\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 33) {\n                result1 = \"!\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"!\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 37) {\n                  result1 = \"%\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"%\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 42) {\n                    result1 = \"*\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"*\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 95) {\n                      result1 = \"_\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"_\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 43) {\n                        result1 = \"+\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"+\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 96) {\n                          result1 = \"`\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"`\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 39) {\n                            result1 = \"'\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"'\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 126) {\n                              result1 = \"~\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"~\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 40) {\n                                result1 = \"(\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"(\\\"\");\n                                }\n                              }\n                              if (result1 === null) {\n                                if (input.charCodeAt(pos) === 41) {\n                                  result1 = \")\";\n                                  pos++;\n                                } else {\n                                  result1 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\")\\\"\");\n                                  }\n                                }\n                                if (result1 === null) {\n                                  if (input.charCodeAt(pos) === 60) {\n                                    result1 = \"<\";\n                                    pos++;\n                                  } else {\n                                    result1 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\"<\\\"\");\n                                    }\n                                  }\n                                  if (result1 === null) {\n                                    if (input.charCodeAt(pos) === 62) {\n                                      result1 = \">\";\n                                      pos++;\n                                    } else {\n                                      result1 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\">\\\"\");\n                                      }\n                                    }\n                                    if (result1 === null) {\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result1 = \":\";\n                                        pos++;\n                                      } else {\n                                        result1 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result1 === null) {\n                                        if (input.charCodeAt(pos) === 92) {\n                                          result1 = \"\\\\\";\n                                          pos++;\n                                        } else {\n                                          result1 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\"\\\\\\\\\\\"\");\n                                          }\n                                        }\n                                        if (result1 === null) {\n                                          result1 = parse_DQUOTE();\n                                          if (result1 === null) {\n                                            if (input.charCodeAt(pos) === 47) {\n                                              result1 = \"/\";\n                                              pos++;\n                                            } else {\n                                              result1 = null;\n                                              if (reportFailures === 0) {\n                                                matchFailed(\"\\\"/\\\"\");\n                                              }\n                                            }\n                                            if (result1 === null) {\n                                              if (input.charCodeAt(pos) === 91) {\n                                                result1 = \"[\";\n                                                pos++;\n                                              } else {\n                                                result1 = null;\n                                                if (reportFailures === 0) {\n                                                  matchFailed(\"\\\"[\\\"\");\n                                                }\n                                              }\n                                              if (result1 === null) {\n                                                if (input.charCodeAt(pos) === 93) {\n                                                  result1 = \"]\";\n                                                  pos++;\n                                                } else {\n                                                  result1 = null;\n                                                  if (reportFailures === 0) {\n                                                    matchFailed(\"\\\"]\\\"\");\n                                                  }\n                                                }\n                                                if (result1 === null) {\n                                                  if (input.charCodeAt(pos) === 63) {\n                                                    result1 = \"?\";\n                                                    pos++;\n                                                  } else {\n                                                    result1 = null;\n                                                    if (reportFailures === 0) {\n                                                      matchFailed(\"\\\"?\\\"\");\n                                                    }\n                                                  }\n                                                  if (result1 === null) {\n                                                    if (input.charCodeAt(pos) === 123) {\n                                                      result1 = \"{\";\n                                                      pos++;\n                                                    } else {\n                                                      result1 = null;\n                                                      if (reportFailures === 0) {\n                                                        matchFailed(\"\\\"{\\\"\");\n                                                      }\n                                                    }\n                                                    if (result1 === null) {\n                                                      if (input.charCodeAt(pos) === 125) {\n                                                        result1 = \"}\";\n                                                        pos++;\n                                                      } else {\n                                                        result1 = null;\n                                                        if (reportFailures === 0) {\n                                                          matchFailed(\"\\\"}\\\"\");\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_alphanum();\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result1 = \"-\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 46) {\n                  result1 = \".\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\".\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 33) {\n                    result1 = \"!\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"!\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 37) {\n                      result1 = \"%\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"%\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 42) {\n                        result1 = \"*\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"*\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 95) {\n                          result1 = \"_\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"_\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 43) {\n                            result1 = \"+\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"+\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 96) {\n                              result1 = \"`\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"`\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 39) {\n                                result1 = \"'\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"'\\\"\");\n                                }\n                              }\n                              if (result1 === null) {\n                                if (input.charCodeAt(pos) === 126) {\n                                  result1 = \"~\";\n                                  pos++;\n                                } else {\n                                  result1 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\"~\\\"\");\n                                  }\n                                }\n                                if (result1 === null) {\n                                  if (input.charCodeAt(pos) === 40) {\n                                    result1 = \"(\";\n                                    pos++;\n                                  } else {\n                                    result1 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\"(\\\"\");\n                                    }\n                                  }\n                                  if (result1 === null) {\n                                    if (input.charCodeAt(pos) === 41) {\n                                      result1 = \")\";\n                                      pos++;\n                                    } else {\n                                      result1 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\")\\\"\");\n                                      }\n                                    }\n                                    if (result1 === null) {\n                                      if (input.charCodeAt(pos) === 60) {\n                                        result1 = \"<\";\n                                        pos++;\n                                      } else {\n                                        result1 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\"<\\\"\");\n                                        }\n                                      }\n                                      if (result1 === null) {\n                                        if (input.charCodeAt(pos) === 62) {\n                                          result1 = \">\";\n                                          pos++;\n                                        } else {\n                                          result1 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\">\\\"\");\n                                          }\n                                        }\n                                        if (result1 === null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result1 = \":\";\n                                            pos++;\n                                          } else {\n                                            result1 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result1 === null) {\n                                            if (input.charCodeAt(pos) === 92) {\n                                              result1 = \"\\\\\";\n                                              pos++;\n                                            } else {\n                                              result1 = null;\n                                              if (reportFailures === 0) {\n                                                matchFailed(\"\\\"\\\\\\\\\\\"\");\n                                              }\n                                            }\n                                            if (result1 === null) {\n                                              result1 = parse_DQUOTE();\n                                              if (result1 === null) {\n                                                if (input.charCodeAt(pos) === 47) {\n                                                  result1 = \"/\";\n                                                  pos++;\n                                                } else {\n                                                  result1 = null;\n                                                  if (reportFailures === 0) {\n                                                    matchFailed(\"\\\"/\\\"\");\n                                                  }\n                                                }\n                                                if (result1 === null) {\n                                                  if (input.charCodeAt(pos) === 91) {\n                                                    result1 = \"[\";\n                                                    pos++;\n                                                  } else {\n                                                    result1 = null;\n                                                    if (reportFailures === 0) {\n                                                      matchFailed(\"\\\"[\\\"\");\n                                                    }\n                                                  }\n                                                  if (result1 === null) {\n                                                    if (input.charCodeAt(pos) === 93) {\n                                                      result1 = \"]\";\n                                                      pos++;\n                                                    } else {\n                                                      result1 = null;\n                                                      if (reportFailures === 0) {\n                                                        matchFailed(\"\\\"]\\\"\");\n                                                      }\n                                                    }\n                                                    if (result1 === null) {\n                                                      if (input.charCodeAt(pos) === 63) {\n                                                        result1 = \"?\";\n                                                        pos++;\n                                                      } else {\n                                                        result1 = null;\n                                                        if (reportFailures === 0) {\n                                                          matchFailed(\"\\\"?\\\"\");\n                                                        }\n                                                      }\n                                                      if (result1 === null) {\n                                                        if (input.charCodeAt(pos) === 123) {\n                                                          result1 = \"{\";\n                                                          pos++;\n                                                        } else {\n                                                          result1 = null;\n                                                          if (reportFailures === 0) {\n                                                            matchFailed(\"\\\"{\\\"\");\n                                                          }\n                                                        }\n                                                        if (result1 === null) {\n                                                          if (input.charCodeAt(pos) === 125) {\n                                                            result1 = \"}\";\n                                                            pos++;\n                                                          } else {\n                                                            result1 = null;\n                                                            if (reportFailures === 0) {\n                                                              matchFailed(\"\\\"}\\\"\");\n                                                            }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_STAR() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 42) {\n            result1 = \"*\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"*\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"*\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SLASH() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 47) {\n            result1 = \"/\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"/\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_EQUAL() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 61) {\n            result1 = \"=\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"=\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_LPAREN() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 40) {\n            result1 = \"(\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"(\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"(\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_RPAREN() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 41) {\n            result1 = \")\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\")\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \")\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_RAQUOT() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 62) {\n          result0 = \">\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\">\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_SWS();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \">\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_LAQUOT() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 60) {\n            result1 = \"<\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"<\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"<\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_COMMA() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 44) {\n            result1 = \",\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\",\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \",\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SEMI() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 59) {\n            result1 = \";\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\";\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \";\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_COLON() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \":\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_LDQUOT() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          result1 = parse_DQUOTE();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"\\\"\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_RDQUOT() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_DQUOTE();\n        if (result0 !== null) {\n          result1 = parse_SWS();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"\\\"\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_comment() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_LPAREN();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_ctext();\n          if (result2 === null) {\n            result2 = parse_quoted_pair();\n            if (result2 === null) {\n              result2 = parse_comment();\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_ctext();\n            if (result2 === null) {\n              result2 = parse_quoted_pair();\n              if (result2 === null) {\n                result2 = parse_comment();\n              }\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_RPAREN();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_ctext() {\n        var result0;\n        if (/^[!-']/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[!-']\");\n          }\n        }\n        if (result0 === null) {\n          if (/^[*-[]/.test(input.charAt(pos))) {\n            result0 = input.charAt(pos);\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[*-[]\");\n            }\n          }\n          if (result0 === null) {\n            if (/^[\\]-~]/.test(input.charAt(pos))) {\n              result0 = input.charAt(pos);\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[\\\\]-~]\");\n              }\n            }\n            if (result0 === null) {\n              result0 = parse_UTF8_NONASCII();\n              if (result0 === null) {\n                result0 = parse_LWS();\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_quoted_string() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          result1 = parse_DQUOTE();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_qdtext();\n            if (result3 === null) {\n              result3 = parse_quoted_pair();\n            }\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_qdtext();\n              if (result3 === null) {\n                result3 = parse_quoted_pair();\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_DQUOTE();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_quoted_string_clean() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          result1 = parse_DQUOTE();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_qdtext();\n            if (result3 === null) {\n              result3 = parse_quoted_pair();\n            }\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_qdtext();\n              if (result3 === null) {\n                result3 = parse_quoted_pair();\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_DQUOTE();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return input.substring(pos - 1, offset + 1);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_qdtext() {\n        var result0;\n        result0 = parse_LWS();\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 33) {\n            result0 = \"!\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"!\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (/^[#-[]/.test(input.charAt(pos))) {\n              result0 = input.charAt(pos);\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[#-[]\");\n              }\n            }\n            if (result0 === null) {\n              if (/^[\\]-~]/.test(input.charAt(pos))) {\n                result0 = input.charAt(pos);\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[\\\\]-~]\");\n                }\n              }\n              if (result0 === null) {\n                result0 = parse_UTF8_NONASCII();\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_quoted_pair() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        if (input.charCodeAt(pos) === 92) {\n          result0 = \"\\\\\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"\\\\\\\\\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (/^[\\0-\\t]/.test(input.charAt(pos))) {\n            result1 = input.charAt(pos);\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[\\\\0-\\\\t]\");\n            }\n          }\n          if (result1 === null) {\n            if (/^[\\x0B-\\f]/.test(input.charAt(pos))) {\n              result1 = input.charAt(pos);\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[\\\\x0B-\\\\f]\");\n              }\n            }\n            if (result1 === null) {\n              if (/^[\\x0E-]/.test(input.charAt(pos))) {\n                result1 = input.charAt(pos);\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[\\\\x0E-]\");\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SIP_URI_noparams() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_uri_scheme();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_userinfo();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_hostport();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            try {\n              data.uri = new URI(data.scheme, data.user, data.host, data.port);\n              delete data.scheme;\n              delete data.user;\n              delete data.host;\n              delete data.host_type;\n              delete data.port;\n            } catch (e) {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SIP_URI() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_uri_scheme();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_userinfo();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_hostport();\n              if (result3 !== null) {\n                result4 = parse_uri_parameters();\n                if (result4 !== null) {\n                  result5 = parse_headers();\n                  result5 = result5 !== null ? result5 : \"\";\n                  if (result5 !== null) {\n                    result0 = [result0, result1, result2, result3, result4, result5];\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var header;\n            try {\n              data.uri = new URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);\n              delete data.scheme;\n              delete data.user;\n              delete data.host;\n              delete data.host_type;\n              delete data.port;\n              delete data.uri_params;\n              if (startRule === 'SIP_URI') {\n                data = data.uri;\n              }\n            } catch (e) {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uri_scheme() {\n        var result0;\n        result0 = parse_uri_scheme_sips();\n        if (result0 === null) {\n          result0 = parse_uri_scheme_sip();\n        }\n        return result0;\n      }\n      function parse_uri_scheme_sips() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 4).toLowerCase() === \"sips\") {\n          result0 = input.substr(pos, 4);\n          pos += 4;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"sips\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset, scheme) {\n            data.scheme = scheme.toLowerCase();\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uri_scheme_sip() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"sip\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"sip\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset, scheme) {\n            data.scheme = scheme.toLowerCase();\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_userinfo() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_user();\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_password();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            if (input.charCodeAt(pos) === 64) {\n              result2 = \"@\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"@\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.user = decodeURIComponent(input.substring(pos - 1, offset));\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_user() {\n        var result0, result1;\n        result1 = parse_unreserved();\n        if (result1 === null) {\n          result1 = parse_escaped();\n          if (result1 === null) {\n            result1 = parse_user_unreserved();\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_unreserved();\n            if (result1 === null) {\n              result1 = parse_escaped();\n              if (result1 === null) {\n                result1 = parse_user_unreserved();\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        return result0;\n      }\n      function parse_user_unreserved() {\n        var result0;\n        if (input.charCodeAt(pos) === 38) {\n          result0 = \"&\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"&\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 61) {\n            result0 = \"=\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 43) {\n              result0 = \"+\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"+\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 36) {\n                result0 = \"$\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"$\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 44) {\n                  result0 = \",\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\",\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 59) {\n                    result0 = \";\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\";\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 63) {\n                      result0 = \"?\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"?\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 47) {\n                        result0 = \"/\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"/\\\"\");\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_password() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result0 = [];\n        result1 = parse_unreserved();\n        if (result1 === null) {\n          result1 = parse_escaped();\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 38) {\n              result1 = \"&\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"&\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 61) {\n                result1 = \"=\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"=\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 43) {\n                  result1 = \"+\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"+\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 36) {\n                    result1 = \"$\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"$\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 44) {\n                      result1 = \",\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\",\\\"\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_unreserved();\n          if (result1 === null) {\n            result1 = parse_escaped();\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 38) {\n                result1 = \"&\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"&\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 61) {\n                  result1 = \"=\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"=\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 43) {\n                    result1 = \"+\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"+\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 36) {\n                      result1 = \"$\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"$\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 44) {\n                        result1 = \",\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\",\\\"\");\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.password = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hostport() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_host();\n        if (result0 !== null) {\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_port();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos1;\n            }\n          } else {\n            result1 = null;\n            pos = pos1;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_host() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_hostname();\n        if (result0 === null) {\n          result0 = parse_IPv4address();\n          if (result0 === null) {\n            result0 = parse_IPv6reference();\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.host = input.substring(pos, offset).toLowerCase();\n            return data.host;\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hostname() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = [];\n        pos2 = pos;\n        result1 = parse_domainlabel();\n        if (result1 !== null) {\n          if (input.charCodeAt(pos) === 46) {\n            result2 = \".\";\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result2 !== null) {\n            result1 = [result1, result2];\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n        } else {\n          result1 = null;\n          pos = pos2;\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          pos2 = pos;\n          result1 = parse_domainlabel();\n          if (result1 !== null) {\n            if (input.charCodeAt(pos) === 46) {\n              result2 = \".\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_toplabel();\n          if (result1 !== null) {\n            if (input.charCodeAt(pos) === 46) {\n              result2 = \".\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.host_type = 'domain';\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_domainlabel() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_alphanum();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_alphanum();\n          if (result2 === null) {\n            if (input.charCodeAt(pos) === 45) {\n              result2 = \"-\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"-\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 95) {\n                result2 = \"_\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"_\\\"\");\n                }\n              }\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_alphanum();\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result2 = \"-\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result2 === null) {\n                if (input.charCodeAt(pos) === 95) {\n                  result2 = \"_\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"_\\\"\");\n                  }\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_toplabel() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_ALPHA();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_alphanum();\n          if (result2 === null) {\n            if (input.charCodeAt(pos) === 45) {\n              result2 = \"-\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"-\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 95) {\n                result2 = \"_\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"_\\\"\");\n                }\n              }\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_alphanum();\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result2 = \"-\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result2 === null) {\n                if (input.charCodeAt(pos) === 95) {\n                  result2 = \"_\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"_\\\"\");\n                  }\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_IPv6reference() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 91) {\n          result0 = \"[\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"[\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_IPv6address();\n          if (result1 !== null) {\n            if (input.charCodeAt(pos) === 93) {\n              result2 = \"]\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"]\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.host_type = 'IPv6';\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_IPv6address() {\n        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_h16();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_h16();\n            if (result2 !== null) {\n              if (input.charCodeAt(pos) === 58) {\n                result3 = \":\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\":\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result4 = parse_h16();\n                if (result4 !== null) {\n                  if (input.charCodeAt(pos) === 58) {\n                    result5 = \":\";\n                    pos++;\n                  } else {\n                    result5 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\":\\\"\");\n                    }\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_h16();\n                    if (result6 !== null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result7 = \":\";\n                        pos++;\n                      } else {\n                        result7 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result7 !== null) {\n                        result8 = parse_h16();\n                        if (result8 !== null) {\n                          if (input.charCodeAt(pos) === 58) {\n                            result9 = \":\";\n                            pos++;\n                          } else {\n                            result9 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\":\\\"\");\n                            }\n                          }\n                          if (result9 !== null) {\n                            result10 = parse_h16();\n                            if (result10 !== null) {\n                              if (input.charCodeAt(pos) === 58) {\n                                result11 = \":\";\n                                pos++;\n                              } else {\n                                result11 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\":\\\"\");\n                                }\n                              }\n                              if (result11 !== null) {\n                                result12 = parse_ls32();\n                                if (result12 !== null) {\n                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12];\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 === null) {\n          pos1 = pos;\n          if (input.substr(pos, 2) === \"::\") {\n            result0 = \"::\";\n            pos += 2;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"::\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = parse_h16();\n            if (result1 !== null) {\n              if (input.charCodeAt(pos) === 58) {\n                result2 = \":\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\":\\\"\");\n                }\n              }\n              if (result2 !== null) {\n                result3 = parse_h16();\n                if (result3 !== null) {\n                  if (input.charCodeAt(pos) === 58) {\n                    result4 = \":\";\n                    pos++;\n                  } else {\n                    result4 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\":\\\"\");\n                    }\n                  }\n                  if (result4 !== null) {\n                    result5 = parse_h16();\n                    if (result5 !== null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result6 = \":\";\n                        pos++;\n                      } else {\n                        result6 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result6 !== null) {\n                        result7 = parse_h16();\n                        if (result7 !== null) {\n                          if (input.charCodeAt(pos) === 58) {\n                            result8 = \":\";\n                            pos++;\n                          } else {\n                            result8 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\":\\\"\");\n                            }\n                          }\n                          if (result8 !== null) {\n                            result9 = parse_h16();\n                            if (result9 !== null) {\n                              if (input.charCodeAt(pos) === 58) {\n                                result10 = \":\";\n                                pos++;\n                              } else {\n                                result10 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\":\\\"\");\n                                }\n                              }\n                              if (result10 !== null) {\n                                result11 = parse_ls32();\n                                if (result11 !== null) {\n                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11];\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 === null) {\n            pos1 = pos;\n            if (input.substr(pos, 2) === \"::\") {\n              result0 = \"::\";\n              pos += 2;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"::\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result1 = parse_h16();\n              if (result1 !== null) {\n                if (input.charCodeAt(pos) === 58) {\n                  result2 = \":\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\":\\\"\");\n                  }\n                }\n                if (result2 !== null) {\n                  result3 = parse_h16();\n                  if (result3 !== null) {\n                    if (input.charCodeAt(pos) === 58) {\n                      result4 = \":\";\n                      pos++;\n                    } else {\n                      result4 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\":\\\"\");\n                      }\n                    }\n                    if (result4 !== null) {\n                      result5 = parse_h16();\n                      if (result5 !== null) {\n                        if (input.charCodeAt(pos) === 58) {\n                          result6 = \":\";\n                          pos++;\n                        } else {\n                          result6 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\":\\\"\");\n                          }\n                        }\n                        if (result6 !== null) {\n                          result7 = parse_h16();\n                          if (result7 !== null) {\n                            if (input.charCodeAt(pos) === 58) {\n                              result8 = \":\";\n                              pos++;\n                            } else {\n                              result8 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\":\\\"\");\n                              }\n                            }\n                            if (result8 !== null) {\n                              result9 = parse_ls32();\n                              if (result9 !== null) {\n                                result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n            if (result0 === null) {\n              pos1 = pos;\n              if (input.substr(pos, 2) === \"::\") {\n                result0 = \"::\";\n                pos += 2;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"::\\\"\");\n                }\n              }\n              if (result0 !== null) {\n                result1 = parse_h16();\n                if (result1 !== null) {\n                  if (input.charCodeAt(pos) === 58) {\n                    result2 = \":\";\n                    pos++;\n                  } else {\n                    result2 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\":\\\"\");\n                    }\n                  }\n                  if (result2 !== null) {\n                    result3 = parse_h16();\n                    if (result3 !== null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result4 = \":\";\n                        pos++;\n                      } else {\n                        result4 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result4 !== null) {\n                        result5 = parse_h16();\n                        if (result5 !== null) {\n                          if (input.charCodeAt(pos) === 58) {\n                            result6 = \":\";\n                            pos++;\n                          } else {\n                            result6 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\":\\\"\");\n                            }\n                          }\n                          if (result6 !== null) {\n                            result7 = parse_ls32();\n                            if (result7 !== null) {\n                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n              if (result0 === null) {\n                pos1 = pos;\n                if (input.substr(pos, 2) === \"::\") {\n                  result0 = \"::\";\n                  pos += 2;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"::\\\"\");\n                  }\n                }\n                if (result0 !== null) {\n                  result1 = parse_h16();\n                  if (result1 !== null) {\n                    if (input.charCodeAt(pos) === 58) {\n                      result2 = \":\";\n                      pos++;\n                    } else {\n                      result2 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\":\\\"\");\n                      }\n                    }\n                    if (result2 !== null) {\n                      result3 = parse_h16();\n                      if (result3 !== null) {\n                        if (input.charCodeAt(pos) === 58) {\n                          result4 = \":\";\n                          pos++;\n                        } else {\n                          result4 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\":\\\"\");\n                          }\n                        }\n                        if (result4 !== null) {\n                          result5 = parse_ls32();\n                          if (result5 !== null) {\n                            result0 = [result0, result1, result2, result3, result4, result5];\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n                if (result0 === null) {\n                  pos1 = pos;\n                  if (input.substr(pos, 2) === \"::\") {\n                    result0 = \"::\";\n                    pos += 2;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"::\\\"\");\n                    }\n                  }\n                  if (result0 !== null) {\n                    result1 = parse_h16();\n                    if (result1 !== null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result2 = \":\";\n                        pos++;\n                      } else {\n                        result2 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result2 !== null) {\n                        result3 = parse_ls32();\n                        if (result3 !== null) {\n                          result0 = [result0, result1, result2, result3];\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                  if (result0 === null) {\n                    pos1 = pos;\n                    if (input.substr(pos, 2) === \"::\") {\n                      result0 = \"::\";\n                      pos += 2;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"::\\\"\");\n                      }\n                    }\n                    if (result0 !== null) {\n                      result1 = parse_ls32();\n                      if (result1 !== null) {\n                        result0 = [result0, result1];\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                    if (result0 === null) {\n                      pos1 = pos;\n                      if (input.substr(pos, 2) === \"::\") {\n                        result0 = \"::\";\n                        pos += 2;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"::\\\"\");\n                        }\n                      }\n                      if (result0 !== null) {\n                        result1 = parse_h16();\n                        if (result1 !== null) {\n                          result0 = [result0, result1];\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                      if (result0 === null) {\n                        pos1 = pos;\n                        result0 = parse_h16();\n                        if (result0 !== null) {\n                          if (input.substr(pos, 2) === \"::\") {\n                            result1 = \"::\";\n                            pos += 2;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"::\\\"\");\n                            }\n                          }\n                          if (result1 !== null) {\n                            result2 = parse_h16();\n                            if (result2 !== null) {\n                              if (input.charCodeAt(pos) === 58) {\n                                result3 = \":\";\n                                pos++;\n                              } else {\n                                result3 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\":\\\"\");\n                                }\n                              }\n                              if (result3 !== null) {\n                                result4 = parse_h16();\n                                if (result4 !== null) {\n                                  if (input.charCodeAt(pos) === 58) {\n                                    result5 = \":\";\n                                    pos++;\n                                  } else {\n                                    result5 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\":\\\"\");\n                                    }\n                                  }\n                                  if (result5 !== null) {\n                                    result6 = parse_h16();\n                                    if (result6 !== null) {\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result7 = \":\";\n                                        pos++;\n                                      } else {\n                                        result7 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result7 !== null) {\n                                        result8 = parse_h16();\n                                        if (result8 !== null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result9 = \":\";\n                                            pos++;\n                                          } else {\n                                            result9 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result9 !== null) {\n                                            result10 = parse_ls32();\n                                            if (result10 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                        if (result0 === null) {\n                          pos1 = pos;\n                          result0 = parse_h16();\n                          if (result0 !== null) {\n                            pos2 = pos;\n                            if (input.charCodeAt(pos) === 58) {\n                              result1 = \":\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\":\\\"\");\n                              }\n                            }\n                            if (result1 !== null) {\n                              result2 = parse_h16();\n                              if (result2 !== null) {\n                                result1 = [result1, result2];\n                              } else {\n                                result1 = null;\n                                pos = pos2;\n                              }\n                            } else {\n                              result1 = null;\n                              pos = pos2;\n                            }\n                            result1 = result1 !== null ? result1 : \"\";\n                            if (result1 !== null) {\n                              if (input.substr(pos, 2) === \"::\") {\n                                result2 = \"::\";\n                                pos += 2;\n                              } else {\n                                result2 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"::\\\"\");\n                                }\n                              }\n                              if (result2 !== null) {\n                                result3 = parse_h16();\n                                if (result3 !== null) {\n                                  if (input.charCodeAt(pos) === 58) {\n                                    result4 = \":\";\n                                    pos++;\n                                  } else {\n                                    result4 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\":\\\"\");\n                                    }\n                                  }\n                                  if (result4 !== null) {\n                                    result5 = parse_h16();\n                                    if (result5 !== null) {\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result6 = \":\";\n                                        pos++;\n                                      } else {\n                                        result6 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result6 !== null) {\n                                        result7 = parse_h16();\n                                        if (result7 !== null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result8 = \":\";\n                                            pos++;\n                                          } else {\n                                            result8 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result8 !== null) {\n                                            result9 = parse_ls32();\n                                            if (result9 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                          if (result0 === null) {\n                            pos1 = pos;\n                            result0 = parse_h16();\n                            if (result0 !== null) {\n                              pos2 = pos;\n                              if (input.charCodeAt(pos) === 58) {\n                                result1 = \":\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\":\\\"\");\n                                }\n                              }\n                              if (result1 !== null) {\n                                result2 = parse_h16();\n                                if (result2 !== null) {\n                                  result1 = [result1, result2];\n                                } else {\n                                  result1 = null;\n                                  pos = pos2;\n                                }\n                              } else {\n                                result1 = null;\n                                pos = pos2;\n                              }\n                              result1 = result1 !== null ? result1 : \"\";\n                              if (result1 !== null) {\n                                pos2 = pos;\n                                if (input.charCodeAt(pos) === 58) {\n                                  result2 = \":\";\n                                  pos++;\n                                } else {\n                                  result2 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\":\\\"\");\n                                  }\n                                }\n                                if (result2 !== null) {\n                                  result3 = parse_h16();\n                                  if (result3 !== null) {\n                                    result2 = [result2, result3];\n                                  } else {\n                                    result2 = null;\n                                    pos = pos2;\n                                  }\n                                } else {\n                                  result2 = null;\n                                  pos = pos2;\n                                }\n                                result2 = result2 !== null ? result2 : \"\";\n                                if (result2 !== null) {\n                                  if (input.substr(pos, 2) === \"::\") {\n                                    result3 = \"::\";\n                                    pos += 2;\n                                  } else {\n                                    result3 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\"::\\\"\");\n                                    }\n                                  }\n                                  if (result3 !== null) {\n                                    result4 = parse_h16();\n                                    if (result4 !== null) {\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result5 = \":\";\n                                        pos++;\n                                      } else {\n                                        result5 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result5 !== null) {\n                                        result6 = parse_h16();\n                                        if (result6 !== null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result7 = \":\";\n                                            pos++;\n                                          } else {\n                                            result7 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result7 !== null) {\n                                            result8 = parse_ls32();\n                                            if (result8 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                            if (result0 === null) {\n                              pos1 = pos;\n                              result0 = parse_h16();\n                              if (result0 !== null) {\n                                pos2 = pos;\n                                if (input.charCodeAt(pos) === 58) {\n                                  result1 = \":\";\n                                  pos++;\n                                } else {\n                                  result1 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\":\\\"\");\n                                  }\n                                }\n                                if (result1 !== null) {\n                                  result2 = parse_h16();\n                                  if (result2 !== null) {\n                                    result1 = [result1, result2];\n                                  } else {\n                                    result1 = null;\n                                    pos = pos2;\n                                  }\n                                } else {\n                                  result1 = null;\n                                  pos = pos2;\n                                }\n                                result1 = result1 !== null ? result1 : \"\";\n                                if (result1 !== null) {\n                                  pos2 = pos;\n                                  if (input.charCodeAt(pos) === 58) {\n                                    result2 = \":\";\n                                    pos++;\n                                  } else {\n                                    result2 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\":\\\"\");\n                                    }\n                                  }\n                                  if (result2 !== null) {\n                                    result3 = parse_h16();\n                                    if (result3 !== null) {\n                                      result2 = [result2, result3];\n                                    } else {\n                                      result2 = null;\n                                      pos = pos2;\n                                    }\n                                  } else {\n                                    result2 = null;\n                                    pos = pos2;\n                                  }\n                                  result2 = result2 !== null ? result2 : \"\";\n                                  if (result2 !== null) {\n                                    pos2 = pos;\n                                    if (input.charCodeAt(pos) === 58) {\n                                      result3 = \":\";\n                                      pos++;\n                                    } else {\n                                      result3 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\":\\\"\");\n                                      }\n                                    }\n                                    if (result3 !== null) {\n                                      result4 = parse_h16();\n                                      if (result4 !== null) {\n                                        result3 = [result3, result4];\n                                      } else {\n                                        result3 = null;\n                                        pos = pos2;\n                                      }\n                                    } else {\n                                      result3 = null;\n                                      pos = pos2;\n                                    }\n                                    result3 = result3 !== null ? result3 : \"\";\n                                    if (result3 !== null) {\n                                      if (input.substr(pos, 2) === \"::\") {\n                                        result4 = \"::\";\n                                        pos += 2;\n                                      } else {\n                                        result4 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\"::\\\"\");\n                                        }\n                                      }\n                                      if (result4 !== null) {\n                                        result5 = parse_h16();\n                                        if (result5 !== null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result6 = \":\";\n                                            pos++;\n                                          } else {\n                                            result6 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result6 !== null) {\n                                            result7 = parse_ls32();\n                                            if (result7 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                              if (result0 === null) {\n                                pos1 = pos;\n                                result0 = parse_h16();\n                                if (result0 !== null) {\n                                  pos2 = pos;\n                                  if (input.charCodeAt(pos) === 58) {\n                                    result1 = \":\";\n                                    pos++;\n                                  } else {\n                                    result1 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\":\\\"\");\n                                    }\n                                  }\n                                  if (result1 !== null) {\n                                    result2 = parse_h16();\n                                    if (result2 !== null) {\n                                      result1 = [result1, result2];\n                                    } else {\n                                      result1 = null;\n                                      pos = pos2;\n                                    }\n                                  } else {\n                                    result1 = null;\n                                    pos = pos2;\n                                  }\n                                  result1 = result1 !== null ? result1 : \"\";\n                                  if (result1 !== null) {\n                                    pos2 = pos;\n                                    if (input.charCodeAt(pos) === 58) {\n                                      result2 = \":\";\n                                      pos++;\n                                    } else {\n                                      result2 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\":\\\"\");\n                                      }\n                                    }\n                                    if (result2 !== null) {\n                                      result3 = parse_h16();\n                                      if (result3 !== null) {\n                                        result2 = [result2, result3];\n                                      } else {\n                                        result2 = null;\n                                        pos = pos2;\n                                      }\n                                    } else {\n                                      result2 = null;\n                                      pos = pos2;\n                                    }\n                                    result2 = result2 !== null ? result2 : \"\";\n                                    if (result2 !== null) {\n                                      pos2 = pos;\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result3 = \":\";\n                                        pos++;\n                                      } else {\n                                        result3 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result3 !== null) {\n                                        result4 = parse_h16();\n                                        if (result4 !== null) {\n                                          result3 = [result3, result4];\n                                        } else {\n                                          result3 = null;\n                                          pos = pos2;\n                                        }\n                                      } else {\n                                        result3 = null;\n                                        pos = pos2;\n                                      }\n                                      result3 = result3 !== null ? result3 : \"\";\n                                      if (result3 !== null) {\n                                        pos2 = pos;\n                                        if (input.charCodeAt(pos) === 58) {\n                                          result4 = \":\";\n                                          pos++;\n                                        } else {\n                                          result4 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\":\\\"\");\n                                          }\n                                        }\n                                        if (result4 !== null) {\n                                          result5 = parse_h16();\n                                          if (result5 !== null) {\n                                            result4 = [result4, result5];\n                                          } else {\n                                            result4 = null;\n                                            pos = pos2;\n                                          }\n                                        } else {\n                                          result4 = null;\n                                          pos = pos2;\n                                        }\n                                        result4 = result4 !== null ? result4 : \"\";\n                                        if (result4 !== null) {\n                                          if (input.substr(pos, 2) === \"::\") {\n                                            result5 = \"::\";\n                                            pos += 2;\n                                          } else {\n                                            result5 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\"::\\\"\");\n                                            }\n                                          }\n                                          if (result5 !== null) {\n                                            result6 = parse_ls32();\n                                            if (result6 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                                if (result0 === null) {\n                                  pos1 = pos;\n                                  result0 = parse_h16();\n                                  if (result0 !== null) {\n                                    pos2 = pos;\n                                    if (input.charCodeAt(pos) === 58) {\n                                      result1 = \":\";\n                                      pos++;\n                                    } else {\n                                      result1 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\":\\\"\");\n                                      }\n                                    }\n                                    if (result1 !== null) {\n                                      result2 = parse_h16();\n                                      if (result2 !== null) {\n                                        result1 = [result1, result2];\n                                      } else {\n                                        result1 = null;\n                                        pos = pos2;\n                                      }\n                                    } else {\n                                      result1 = null;\n                                      pos = pos2;\n                                    }\n                                    result1 = result1 !== null ? result1 : \"\";\n                                    if (result1 !== null) {\n                                      pos2 = pos;\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result2 = \":\";\n                                        pos++;\n                                      } else {\n                                        result2 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result2 !== null) {\n                                        result3 = parse_h16();\n                                        if (result3 !== null) {\n                                          result2 = [result2, result3];\n                                        } else {\n                                          result2 = null;\n                                          pos = pos2;\n                                        }\n                                      } else {\n                                        result2 = null;\n                                        pos = pos2;\n                                      }\n                                      result2 = result2 !== null ? result2 : \"\";\n                                      if (result2 !== null) {\n                                        pos2 = pos;\n                                        if (input.charCodeAt(pos) === 58) {\n                                          result3 = \":\";\n                                          pos++;\n                                        } else {\n                                          result3 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\":\\\"\");\n                                          }\n                                        }\n                                        if (result3 !== null) {\n                                          result4 = parse_h16();\n                                          if (result4 !== null) {\n                                            result3 = [result3, result4];\n                                          } else {\n                                            result3 = null;\n                                            pos = pos2;\n                                          }\n                                        } else {\n                                          result3 = null;\n                                          pos = pos2;\n                                        }\n                                        result3 = result3 !== null ? result3 : \"\";\n                                        if (result3 !== null) {\n                                          pos2 = pos;\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result4 = \":\";\n                                            pos++;\n                                          } else {\n                                            result4 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result4 !== null) {\n                                            result5 = parse_h16();\n                                            if (result5 !== null) {\n                                              result4 = [result4, result5];\n                                            } else {\n                                              result4 = null;\n                                              pos = pos2;\n                                            }\n                                          } else {\n                                            result4 = null;\n                                            pos = pos2;\n                                          }\n                                          result4 = result4 !== null ? result4 : \"\";\n                                          if (result4 !== null) {\n                                            pos2 = pos;\n                                            if (input.charCodeAt(pos) === 58) {\n                                              result5 = \":\";\n                                              pos++;\n                                            } else {\n                                              result5 = null;\n                                              if (reportFailures === 0) {\n                                                matchFailed(\"\\\":\\\"\");\n                                              }\n                                            }\n                                            if (result5 !== null) {\n                                              result6 = parse_h16();\n                                              if (result6 !== null) {\n                                                result5 = [result5, result6];\n                                              } else {\n                                                result5 = null;\n                                                pos = pos2;\n                                              }\n                                            } else {\n                                              result5 = null;\n                                              pos = pos2;\n                                            }\n                                            result5 = result5 !== null ? result5 : \"\";\n                                            if (result5 !== null) {\n                                              if (input.substr(pos, 2) === \"::\") {\n                                                result6 = \"::\";\n                                                pos += 2;\n                                              } else {\n                                                result6 = null;\n                                                if (reportFailures === 0) {\n                                                  matchFailed(\"\\\"::\\\"\");\n                                                }\n                                              }\n                                              if (result6 !== null) {\n                                                result7 = parse_h16();\n                                                if (result7 !== null) {\n                                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                                                } else {\n                                                  result0 = null;\n                                                  pos = pos1;\n                                                }\n                                              } else {\n                                                result0 = null;\n                                                pos = pos1;\n                                              }\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                  if (result0 === null) {\n                                    pos1 = pos;\n                                    result0 = parse_h16();\n                                    if (result0 !== null) {\n                                      pos2 = pos;\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result1 = \":\";\n                                        pos++;\n                                      } else {\n                                        result1 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result1 !== null) {\n                                        result2 = parse_h16();\n                                        if (result2 !== null) {\n                                          result1 = [result1, result2];\n                                        } else {\n                                          result1 = null;\n                                          pos = pos2;\n                                        }\n                                      } else {\n                                        result1 = null;\n                                        pos = pos2;\n                                      }\n                                      result1 = result1 !== null ? result1 : \"\";\n                                      if (result1 !== null) {\n                                        pos2 = pos;\n                                        if (input.charCodeAt(pos) === 58) {\n                                          result2 = \":\";\n                                          pos++;\n                                        } else {\n                                          result2 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\":\\\"\");\n                                          }\n                                        }\n                                        if (result2 !== null) {\n                                          result3 = parse_h16();\n                                          if (result3 !== null) {\n                                            result2 = [result2, result3];\n                                          } else {\n                                            result2 = null;\n                                            pos = pos2;\n                                          }\n                                        } else {\n                                          result2 = null;\n                                          pos = pos2;\n                                        }\n                                        result2 = result2 !== null ? result2 : \"\";\n                                        if (result2 !== null) {\n                                          pos2 = pos;\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result3 = \":\";\n                                            pos++;\n                                          } else {\n                                            result3 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result3 !== null) {\n                                            result4 = parse_h16();\n                                            if (result4 !== null) {\n                                              result3 = [result3, result4];\n                                            } else {\n                                              result3 = null;\n                                              pos = pos2;\n                                            }\n                                          } else {\n                                            result3 = null;\n                                            pos = pos2;\n                                          }\n                                          result3 = result3 !== null ? result3 : \"\";\n                                          if (result3 !== null) {\n                                            pos2 = pos;\n                                            if (input.charCodeAt(pos) === 58) {\n                                              result4 = \":\";\n                                              pos++;\n                                            } else {\n                                              result4 = null;\n                                              if (reportFailures === 0) {\n                                                matchFailed(\"\\\":\\\"\");\n                                              }\n                                            }\n                                            if (result4 !== null) {\n                                              result5 = parse_h16();\n                                              if (result5 !== null) {\n                                                result4 = [result4, result5];\n                                              } else {\n                                                result4 = null;\n                                                pos = pos2;\n                                              }\n                                            } else {\n                                              result4 = null;\n                                              pos = pos2;\n                                            }\n                                            result4 = result4 !== null ? result4 : \"\";\n                                            if (result4 !== null) {\n                                              pos2 = pos;\n                                              if (input.charCodeAt(pos) === 58) {\n                                                result5 = \":\";\n                                                pos++;\n                                              } else {\n                                                result5 = null;\n                                                if (reportFailures === 0) {\n                                                  matchFailed(\"\\\":\\\"\");\n                                                }\n                                              }\n                                              if (result5 !== null) {\n                                                result6 = parse_h16();\n                                                if (result6 !== null) {\n                                                  result5 = [result5, result6];\n                                                } else {\n                                                  result5 = null;\n                                                  pos = pos2;\n                                                }\n                                              } else {\n                                                result5 = null;\n                                                pos = pos2;\n                                              }\n                                              result5 = result5 !== null ? result5 : \"\";\n                                              if (result5 !== null) {\n                                                pos2 = pos;\n                                                if (input.charCodeAt(pos) === 58) {\n                                                  result6 = \":\";\n                                                  pos++;\n                                                } else {\n                                                  result6 = null;\n                                                  if (reportFailures === 0) {\n                                                    matchFailed(\"\\\":\\\"\");\n                                                  }\n                                                }\n                                                if (result6 !== null) {\n                                                  result7 = parse_h16();\n                                                  if (result7 !== null) {\n                                                    result6 = [result6, result7];\n                                                  } else {\n                                                    result6 = null;\n                                                    pos = pos2;\n                                                  }\n                                                } else {\n                                                  result6 = null;\n                                                  pos = pos2;\n                                                }\n                                                result6 = result6 !== null ? result6 : \"\";\n                                                if (result6 !== null) {\n                                                  if (input.substr(pos, 2) === \"::\") {\n                                                    result7 = \"::\";\n                                                    pos += 2;\n                                                  } else {\n                                                    result7 = null;\n                                                    if (reportFailures === 0) {\n                                                      matchFailed(\"\\\"::\\\"\");\n                                                    }\n                                                  }\n                                                  if (result7 !== null) {\n                                                    result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                                                  } else {\n                                                    result0 = null;\n                                                    pos = pos1;\n                                                  }\n                                                } else {\n                                                  result0 = null;\n                                                  pos = pos1;\n                                                }\n                                              } else {\n                                                result0 = null;\n                                                pos = pos1;\n                                              }\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.host_type = 'IPv6';\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_h16() {\n        var result0, result1, result2, result3;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_HEXDIG();\n        if (result0 !== null) {\n          result1 = parse_HEXDIG();\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result2 = parse_HEXDIG();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_HEXDIG();\n              result3 = result3 !== null ? result3 : \"\";\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_ls32() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_h16();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_h16();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        if (result0 === null) {\n          result0 = parse_IPv4address();\n        }\n        return result0;\n      }\n      function parse_IPv4address() {\n        var result0, result1, result2, result3, result4, result5, result6;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_dec_octet();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 46) {\n            result1 = \".\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_dec_octet();\n            if (result2 !== null) {\n              if (input.charCodeAt(pos) === 46) {\n                result3 = \".\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\".\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result4 = parse_dec_octet();\n                if (result4 !== null) {\n                  if (input.charCodeAt(pos) === 46) {\n                    result5 = \".\";\n                    pos++;\n                  } else {\n                    result5 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\".\\\"\");\n                    }\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_dec_octet();\n                    if (result6 !== null) {\n                      result0 = [result0, result1, result2, result3, result4, result5, result6];\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.host_type = 'IPv4';\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_dec_octet() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 2) === \"25\") {\n          result0 = \"25\";\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"25\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (/^[0-5]/.test(input.charAt(pos))) {\n            result1 = input.charAt(pos);\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[0-5]\");\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          if (input.charCodeAt(pos) === 50) {\n            result0 = \"2\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"2\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            if (/^[0-4]/.test(input.charAt(pos))) {\n              result1 = input.charAt(pos);\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[0-4]\");\n              }\n            }\n            if (result1 !== null) {\n              result2 = parse_DIGIT();\n              if (result2 !== null) {\n                result0 = [result0, result1, result2];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            if (input.charCodeAt(pos) === 49) {\n              result0 = \"1\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"1\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result1 = parse_DIGIT();\n              if (result1 !== null) {\n                result2 = parse_DIGIT();\n                if (result2 !== null) {\n                  result0 = [result0, result1, result2];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n            if (result0 === null) {\n              pos0 = pos;\n              if (/^[1-9]/.test(input.charAt(pos))) {\n                result0 = input.charAt(pos);\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[1-9]\");\n                }\n              }\n              if (result0 !== null) {\n                result1 = parse_DIGIT();\n                if (result1 !== null) {\n                  result0 = [result0, result1];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n              if (result0 === null) {\n                result0 = parse_DIGIT();\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_port() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_DIGIT();\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result1 = parse_DIGIT();\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_DIGIT();\n              result3 = result3 !== null ? result3 : \"\";\n              if (result3 !== null) {\n                result4 = parse_DIGIT();\n                result4 = result4 !== null ? result4 : \"\";\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, port) {\n            port = parseInt(port.join(''));\n            data.port = port;\n            return port;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uri_parameters() {\n        var result0, result1, result2;\n        var pos0;\n        result0 = [];\n        pos0 = pos;\n        if (input.charCodeAt(pos) === 59) {\n          result1 = \";\";\n          pos++;\n        } else {\n          result1 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\";\\\"\");\n          }\n        }\n        if (result1 !== null) {\n          result2 = parse_uri_parameter();\n          if (result2 !== null) {\n            result1 = [result1, result2];\n          } else {\n            result1 = null;\n            pos = pos0;\n          }\n        } else {\n          result1 = null;\n          pos = pos0;\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          pos0 = pos;\n          if (input.charCodeAt(pos) === 59) {\n            result1 = \";\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\";\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_uri_parameter();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos0;\n            }\n          } else {\n            result1 = null;\n            pos = pos0;\n          }\n        }\n        return result0;\n      }\n      function parse_uri_parameter() {\n        var result0;\n        result0 = parse_transport_param();\n        if (result0 === null) {\n          result0 = parse_user_param();\n          if (result0 === null) {\n            result0 = parse_method_param();\n            if (result0 === null) {\n              result0 = parse_ttl_param();\n              if (result0 === null) {\n                result0 = parse_maddr_param();\n                if (result0 === null) {\n                  result0 = parse_lr_param();\n                  if (result0 === null) {\n                    result0 = parse_other_param();\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_transport_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 10).toLowerCase() === \"transport=\") {\n          result0 = input.substr(pos, 10);\n          pos += 10;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"transport=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (input.substr(pos, 3).toLowerCase() === \"udp\") {\n            result1 = input.substr(pos, 3);\n            pos += 3;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"udp\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.substr(pos, 3).toLowerCase() === \"tcp\") {\n              result1 = input.substr(pos, 3);\n              pos += 3;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"tcp\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.substr(pos, 4).toLowerCase() === \"sctp\") {\n                result1 = input.substr(pos, 4);\n                pos += 4;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"sctp\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.substr(pos, 3).toLowerCase() === \"tls\") {\n                  result1 = input.substr(pos, 3);\n                  pos += 3;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"tls\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  result1 = parse_token();\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, transport) {\n            if (!data.uri_params) data.uri_params = {};\n            data.uri_params['transport'] = transport.toLowerCase();\n          }(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_user_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"user=\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"user=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (input.substr(pos, 5).toLowerCase() === \"phone\") {\n            result1 = input.substr(pos, 5);\n            pos += 5;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"phone\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.substr(pos, 2).toLowerCase() === \"ip\") {\n              result1 = input.substr(pos, 2);\n              pos += 2;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"ip\\\"\");\n              }\n            }\n            if (result1 === null) {\n              result1 = parse_token();\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, user) {\n            if (!data.uri_params) data.uri_params = {};\n            data.uri_params['user'] = user.toLowerCase();\n          }(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_method_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 7).toLowerCase() === \"method=\") {\n          result0 = input.substr(pos, 7);\n          pos += 7;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"method=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_Method();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, method) {\n            if (!data.uri_params) data.uri_params = {};\n            data.uri_params['method'] = method;\n          }(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_ttl_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 4).toLowerCase() === \"ttl=\") {\n          result0 = input.substr(pos, 4);\n          pos += 4;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"ttl=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_ttl();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, ttl) {\n            if (!data.params) data.params = {};\n            data.params['ttl'] = ttl;\n          }(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_maddr_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"maddr=\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"maddr=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_host();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, maddr) {\n            if (!data.uri_params) data.uri_params = {};\n            data.uri_params['maddr'] = maddr;\n          }(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_lr_param() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 2).toLowerCase() === \"lr\") {\n          result0 = input.substr(pos, 2);\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"lr\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 61) {\n            result1 = \"=\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            if (!data.uri_params) data.uri_params = {};\n            data.uri_params['lr'] = undefined;\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_other_param() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_pname();\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 61) {\n            result1 = \"=\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_pvalue();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, param, value) {\n            if (!data.uri_params) data.uri_params = {};\n            if (typeof value === 'undefined') {\n              value = undefined;\n            } else {\n              value = value[1];\n            }\n            data.uri_params[param.toLowerCase()] = value;\n          }(pos0, result0[0], result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_pname() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_paramchar();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_paramchar();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, pname) {\n            return pname.join('');\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_pvalue() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_paramchar();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_paramchar();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, pvalue) {\n            return pvalue.join('');\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_paramchar() {\n        var result0;\n        result0 = parse_param_unreserved();\n        if (result0 === null) {\n          result0 = parse_unreserved();\n          if (result0 === null) {\n            result0 = parse_escaped();\n          }\n        }\n        return result0;\n      }\n      function parse_param_unreserved() {\n        var result0;\n        if (input.charCodeAt(pos) === 91) {\n          result0 = \"[\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"[\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 93) {\n            result0 = \"]\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"]\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 47) {\n              result0 = \"/\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"/\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 58) {\n                result0 = \":\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\":\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 38) {\n                  result0 = \"&\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"&\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 43) {\n                    result0 = \"+\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"+\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 36) {\n                      result0 = \"$\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"$\\\"\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_headers() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1;\n        pos0 = pos;\n        if (input.charCodeAt(pos) === 63) {\n          result0 = \"?\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"?\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_header();\n          if (result1 !== null) {\n            result2 = [];\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 38) {\n              result3 = \"&\";\n              pos++;\n            } else {\n              result3 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"&\\\"\");\n              }\n            }\n            if (result3 !== null) {\n              result4 = parse_header();\n              if (result4 !== null) {\n                result3 = [result3, result4];\n              } else {\n                result3 = null;\n                pos = pos1;\n              }\n            } else {\n              result3 = null;\n              pos = pos1;\n            }\n            while (result3 !== null) {\n              result2.push(result3);\n              pos1 = pos;\n              if (input.charCodeAt(pos) === 38) {\n                result3 = \"&\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"&\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result4 = parse_header();\n                if (result4 !== null) {\n                  result3 = [result3, result4];\n                } else {\n                  result3 = null;\n                  pos = pos1;\n                }\n              } else {\n                result3 = null;\n                pos = pos1;\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_header() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_hname();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 61) {\n            result1 = \"=\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_hvalue();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, hname, hvalue) {\n            hname = hname.join('').toLowerCase();\n            hvalue = hvalue.join('');\n            if (!data.uri_headers) data.uri_headers = {};\n            if (!data.uri_headers[hname]) {\n              data.uri_headers[hname] = [hvalue];\n            } else {\n              data.uri_headers[hname].push(hvalue);\n            }\n          }(pos0, result0[0], result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hname() {\n        var result0, result1;\n        result1 = parse_hnv_unreserved();\n        if (result1 === null) {\n          result1 = parse_unreserved();\n          if (result1 === null) {\n            result1 = parse_escaped();\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_hnv_unreserved();\n            if (result1 === null) {\n              result1 = parse_unreserved();\n              if (result1 === null) {\n                result1 = parse_escaped();\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        return result0;\n      }\n      function parse_hvalue() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_hnv_unreserved();\n        if (result1 === null) {\n          result1 = parse_unreserved();\n          if (result1 === null) {\n            result1 = parse_escaped();\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_hnv_unreserved();\n          if (result1 === null) {\n            result1 = parse_unreserved();\n            if (result1 === null) {\n              result1 = parse_escaped();\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_hnv_unreserved() {\n        var result0;\n        if (input.charCodeAt(pos) === 91) {\n          result0 = \"[\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"[\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 93) {\n            result0 = \"]\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"]\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 47) {\n              result0 = \"/\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"/\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 63) {\n                result0 = \"?\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"?\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 58) {\n                  result0 = \":\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\":\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 43) {\n                    result0 = \"+\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"+\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 36) {\n                      result0 = \"$\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"$\\\"\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_Request_Response() {\n        var result0;\n        result0 = parse_Status_Line();\n        if (result0 === null) {\n          result0 = parse_Request_Line();\n        }\n        return result0;\n      }\n      function parse_Request_Line() {\n        var result0, result1, result2, result3, result4;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_Method();\n        if (result0 !== null) {\n          result1 = parse_SP();\n          if (result1 !== null) {\n            result2 = parse_Request_URI();\n            if (result2 !== null) {\n              result3 = parse_SP();\n              if (result3 !== null) {\n                result4 = parse_SIP_Version();\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Request_URI() {\n        var result0;\n        result0 = parse_SIP_URI();\n        if (result0 === null) {\n          result0 = parse_absoluteURI();\n        }\n        return result0;\n      }\n      function parse_absoluteURI() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_scheme();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_hier_part();\n            if (result2 === null) {\n              result2 = parse_opaque_part();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hier_part() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_net_path();\n        if (result0 === null) {\n          result0 = parse_abs_path();\n        }\n        if (result0 !== null) {\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 63) {\n            result1 = \"?\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"?\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_query();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos1;\n            }\n          } else {\n            result1 = null;\n            pos = pos1;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_net_path() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 2) === \"//\") {\n          result0 = \"//\";\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"//\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_authority();\n          if (result1 !== null) {\n            result2 = parse_abs_path();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_abs_path() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        if (input.charCodeAt(pos) === 47) {\n          result0 = \"/\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"/\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_path_segments();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_opaque_part() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_uric_no_slash();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_uric();\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_uric();\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uric() {\n        var result0;\n        result0 = parse_reserved();\n        if (result0 === null) {\n          result0 = parse_unreserved();\n          if (result0 === null) {\n            result0 = parse_escaped();\n          }\n        }\n        return result0;\n      }\n      function parse_uric_no_slash() {\n        var result0;\n        result0 = parse_unreserved();\n        if (result0 === null) {\n          result0 = parse_escaped();\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 59) {\n              result0 = \";\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\";\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 63) {\n                result0 = \"?\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"?\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 58) {\n                  result0 = \":\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\":\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 64) {\n                    result0 = \"@\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"@\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 38) {\n                      result0 = \"&\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"&\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 61) {\n                        result0 = \"=\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"=\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 43) {\n                          result0 = \"+\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"+\\\"\");\n                          }\n                        }\n                        if (result0 === null) {\n                          if (input.charCodeAt(pos) === 36) {\n                            result0 = \"$\";\n                            pos++;\n                          } else {\n                            result0 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"$\\\"\");\n                            }\n                          }\n                          if (result0 === null) {\n                            if (input.charCodeAt(pos) === 44) {\n                              result0 = \",\";\n                              pos++;\n                            } else {\n                              result0 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\",\\\"\");\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_path_segments() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_segment();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 47) {\n            result2 = \"/\";\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result2 !== null) {\n            result3 = parse_segment();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 47) {\n              result2 = \"/\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"/\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_segment();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_segment() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = [];\n        result1 = parse_pchar();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_pchar();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 59) {\n            result2 = \";\";\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\";\\\"\");\n            }\n          }\n          if (result2 !== null) {\n            result3 = parse_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 59) {\n              result2 = \";\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\";\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_param() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_pchar();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_pchar();\n        }\n        return result0;\n      }\n      function parse_pchar() {\n        var result0;\n        result0 = parse_unreserved();\n        if (result0 === null) {\n          result0 = parse_escaped();\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 58) {\n              result0 = \":\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\":\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 64) {\n                result0 = \"@\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"@\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 38) {\n                  result0 = \"&\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"&\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 61) {\n                    result0 = \"=\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"=\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 43) {\n                      result0 = \"+\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"+\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 36) {\n                        result0 = \"$\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"$\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 44) {\n                          result0 = \",\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\",\\\"\");\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_scheme() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_ALPHA();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_ALPHA();\n          if (result2 === null) {\n            result2 = parse_DIGIT();\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 43) {\n                result2 = \"+\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"+\\\"\");\n                }\n              }\n              if (result2 === null) {\n                if (input.charCodeAt(pos) === 45) {\n                  result2 = \"-\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"-\\\"\");\n                  }\n                }\n                if (result2 === null) {\n                  if (input.charCodeAt(pos) === 46) {\n                    result2 = \".\";\n                    pos++;\n                  } else {\n                    result2 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\".\\\"\");\n                    }\n                  }\n                }\n              }\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_ALPHA();\n            if (result2 === null) {\n              result2 = parse_DIGIT();\n              if (result2 === null) {\n                if (input.charCodeAt(pos) === 43) {\n                  result2 = \"+\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"+\\\"\");\n                  }\n                }\n                if (result2 === null) {\n                  if (input.charCodeAt(pos) === 45) {\n                    result2 = \"-\";\n                    pos++;\n                  } else {\n                    result2 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"-\\\"\");\n                    }\n                  }\n                  if (result2 === null) {\n                    if (input.charCodeAt(pos) === 46) {\n                      result2 = \".\";\n                      pos++;\n                    } else {\n                      result2 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\".\\\"\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.scheme = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_authority() {\n        var result0;\n        result0 = parse_srvr();\n        if (result0 === null) {\n          result0 = parse_reg_name();\n        }\n        return result0;\n      }\n      function parse_srvr() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_userinfo();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 64) {\n            result1 = \"@\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"@\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result1 = parse_hostport();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        result0 = result0 !== null ? result0 : \"\";\n        return result0;\n      }\n      function parse_reg_name() {\n        var result0, result1;\n        result1 = parse_unreserved();\n        if (result1 === null) {\n          result1 = parse_escaped();\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 36) {\n              result1 = \"$\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"$\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 44) {\n                result1 = \",\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\",\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 59) {\n                  result1 = \";\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\";\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 58) {\n                    result1 = \":\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\":\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 64) {\n                      result1 = \"@\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"@\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 38) {\n                        result1 = \"&\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"&\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 61) {\n                          result1 = \"=\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"=\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 43) {\n                            result1 = \"+\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"+\\\"\");\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_unreserved();\n            if (result1 === null) {\n              result1 = parse_escaped();\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 36) {\n                  result1 = \"$\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"$\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 44) {\n                    result1 = \",\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\",\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 59) {\n                      result1 = \";\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\";\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result1 = \":\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 64) {\n                          result1 = \"@\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"@\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 38) {\n                            result1 = \"&\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"&\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 61) {\n                              result1 = \"=\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"=\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 43) {\n                                result1 = \"+\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"+\\\"\");\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        return result0;\n      }\n      function parse_query() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_uric();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_uric();\n        }\n        return result0;\n      }\n      function parse_SIP_Version() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"sip\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"SIP\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 47) {\n            result1 = \"/\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result3 = parse_DIGIT();\n            if (result3 !== null) {\n              result2 = [];\n              while (result3 !== null) {\n                result2.push(result3);\n                result3 = parse_DIGIT();\n              }\n            } else {\n              result2 = null;\n            }\n            if (result2 !== null) {\n              if (input.charCodeAt(pos) === 46) {\n                result3 = \".\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\".\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result5 = parse_DIGIT();\n                if (result5 !== null) {\n                  result4 = [];\n                  while (result5 !== null) {\n                    result4.push(result5);\n                    result5 = parse_DIGIT();\n                  }\n                } else {\n                  result4 = null;\n                }\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.sip_version = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_INVITEm() {\n        var result0;\n        if (input.substr(pos, 6) === \"INVITE\") {\n          result0 = \"INVITE\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"INVITE\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_ACKm() {\n        var result0;\n        if (input.substr(pos, 3) === \"ACK\") {\n          result0 = \"ACK\";\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"ACK\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_OPTIONSm() {\n        var result0;\n        if (input.substr(pos, 7) === \"OPTIONS\") {\n          result0 = \"OPTIONS\";\n          pos += 7;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"OPTIONS\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_BYEm() {\n        var result0;\n        if (input.substr(pos, 3) === \"BYE\") {\n          result0 = \"BYE\";\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"BYE\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_CANCELm() {\n        var result0;\n        if (input.substr(pos, 6) === \"CANCEL\") {\n          result0 = \"CANCEL\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"CANCEL\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_REGISTERm() {\n        var result0;\n        if (input.substr(pos, 8) === \"REGISTER\") {\n          result0 = \"REGISTER\";\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"REGISTER\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_SUBSCRIBEm() {\n        var result0;\n        if (input.substr(pos, 9) === \"SUBSCRIBE\") {\n          result0 = \"SUBSCRIBE\";\n          pos += 9;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"SUBSCRIBE\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_NOTIFYm() {\n        var result0;\n        if (input.substr(pos, 6) === \"NOTIFY\") {\n          result0 = \"NOTIFY\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"NOTIFY\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_REFERm() {\n        var result0;\n        if (input.substr(pos, 5) === \"REFER\") {\n          result0 = \"REFER\";\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"REFER\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_Method() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_INVITEm();\n        if (result0 === null) {\n          result0 = parse_ACKm();\n          if (result0 === null) {\n            result0 = parse_OPTIONSm();\n            if (result0 === null) {\n              result0 = parse_BYEm();\n              if (result0 === null) {\n                result0 = parse_CANCELm();\n                if (result0 === null) {\n                  result0 = parse_REGISTERm();\n                  if (result0 === null) {\n                    result0 = parse_SUBSCRIBEm();\n                    if (result0 === null) {\n                      result0 = parse_NOTIFYm();\n                      if (result0 === null) {\n                        result0 = parse_REFERm();\n                        if (result0 === null) {\n                          result0 = parse_token();\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.method = input.substring(pos, offset);\n            return data.method;\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Status_Line() {\n        var result0, result1, result2, result3, result4;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_SIP_Version();\n        if (result0 !== null) {\n          result1 = parse_SP();\n          if (result1 !== null) {\n            result2 = parse_Status_Code();\n            if (result2 !== null) {\n              result3 = parse_SP();\n              if (result3 !== null) {\n                result4 = parse_Reason_Phrase();\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Status_Code() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_extension_code();\n        if (result0 !== null) {\n          result0 = function (offset, status_code) {\n            data.status_code = parseInt(status_code.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_extension_code() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_DIGIT();\n        if (result0 !== null) {\n          result1 = parse_DIGIT();\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Reason_Phrase() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result0 = [];\n        result1 = parse_reserved();\n        if (result1 === null) {\n          result1 = parse_unreserved();\n          if (result1 === null) {\n            result1 = parse_escaped();\n            if (result1 === null) {\n              result1 = parse_UTF8_NONASCII();\n              if (result1 === null) {\n                result1 = parse_UTF8_CONT();\n                if (result1 === null) {\n                  result1 = parse_SP();\n                  if (result1 === null) {\n                    result1 = parse_HTAB();\n                  }\n                }\n              }\n            }\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_reserved();\n          if (result1 === null) {\n            result1 = parse_unreserved();\n            if (result1 === null) {\n              result1 = parse_escaped();\n              if (result1 === null) {\n                result1 = parse_UTF8_NONASCII();\n                if (result1 === null) {\n                  result1 = parse_UTF8_CONT();\n                  if (result1 === null) {\n                    result1 = parse_SP();\n                    if (result1 === null) {\n                      result1 = parse_HTAB();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.reason_phrase = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Allow_Events() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_event_type();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_event_type();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_event_type();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Call_ID() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_word();\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 64) {\n            result1 = \"@\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"@\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_word();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Contact() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        result0 = parse_STAR();\n        if (result0 === null) {\n          pos1 = pos;\n          result0 = parse_contact_param();\n          if (result0 !== null) {\n            result1 = [];\n            pos2 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_contact_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n            while (result2 !== null) {\n              result1.push(result2);\n              pos2 = pos;\n              result2 = parse_COMMA();\n              if (result2 !== null) {\n                result3 = parse_contact_param();\n                if (result3 !== null) {\n                  result2 = [result2, result3];\n                } else {\n                  result2 = null;\n                  pos = pos2;\n                }\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            }\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var idx, length;\n            length = data.multi_header.length;\n            for (idx = 0; idx < length; idx++) {\n              if (data.multi_header[idx].parsed === null) {\n                data = null;\n                break;\n              }\n            }\n            if (data !== null) {\n              data = data.multi_header;\n            } else {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_contact_param() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SIP_URI_noparams();\n        if (result0 === null) {\n          result0 = parse_name_addr();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_contact_params();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_contact_params();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var header;\n            if (!data.multi_header) data.multi_header = [];\n            try {\n              header = new NameAddrHeader(data.uri, data.display_name, data.params);\n              delete data.uri;\n              delete data.display_name;\n              delete data.params;\n            } catch (e) {\n              header = null;\n            }\n            data.multi_header.push({ 'possition': pos,\n              'offset': offset,\n              'parsed': header\n            });\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_name_addr() {\n        var result0, result1, result2, result3;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_display_name();\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result1 = parse_LAQUOT();\n          if (result1 !== null) {\n            result2 = parse_SIP_URI();\n            if (result2 !== null) {\n              result3 = parse_RAQUOT();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_display_name() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_LWS();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_LWS();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 === null) {\n          result0 = parse_quoted_string();\n        }\n        if (result0 !== null) {\n          result0 = function (offset, display_name) {\n            display_name = input.substring(pos, offset).trim();\n            if (display_name[0] === '\\\"') {\n              display_name = display_name.substring(1, display_name.length - 1);\n            }\n            data.display_name = display_name;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_contact_params() {\n        var result0;\n        result0 = parse_c_p_q();\n        if (result0 === null) {\n          result0 = parse_c_p_expires();\n          if (result0 === null) {\n            result0 = parse_generic_param();\n          }\n        }\n        return result0;\n      }\n      function parse_c_p_q() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 1).toLowerCase() === \"q\") {\n          result0 = input.substr(pos, 1);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"q\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_qvalue();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, q) {\n            if (!data.params) data.params = {};\n            data.params['q'] = q;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_c_p_expires() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 7).toLowerCase() === \"expires\") {\n          result0 = input.substr(pos, 7);\n          pos += 7;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"expires\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_delta_seconds();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, expires) {\n            if (!data.params) data.params = {};\n            data.params['expires'] = expires;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_delta_seconds() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_DIGIT();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_DIGIT();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, delta_seconds) {\n            return parseInt(delta_seconds.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_qvalue() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 48) {\n          result0 = \"0\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"0\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 46) {\n            result1 = \".\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_DIGIT();\n              result3 = result3 !== null ? result3 : \"\";\n              if (result3 !== null) {\n                result4 = parse_DIGIT();\n                result4 = result4 !== null ? result4 : \"\";\n                if (result4 !== null) {\n                  result1 = [result1, result2, result3, result4];\n                } else {\n                  result1 = null;\n                  pos = pos2;\n                }\n              } else {\n                result1 = null;\n                pos = pos2;\n              }\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return parseFloat(input.substring(pos, offset));\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_generic_param() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          pos2 = pos;\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_gen_value();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, param, value) {\n            if (!data.params) data.params = {};\n            if (typeof value === 'undefined') {\n              value = undefined;\n            } else {\n              value = value[1];\n            }\n            data.params[param.toLowerCase()] = value;\n          }(pos0, result0[0], result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_gen_value() {\n        var result0;\n        result0 = parse_token();\n        if (result0 === null) {\n          result0 = parse_host();\n          if (result0 === null) {\n            result0 = parse_quoted_string();\n          }\n        }\n        return result0;\n      }\n      function parse_Content_Disposition() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_disp_type();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_disp_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_disp_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_disp_type() {\n        var result0;\n        if (input.substr(pos, 6).toLowerCase() === \"render\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"render\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 7).toLowerCase() === \"session\") {\n            result0 = input.substr(pos, 7);\n            pos += 7;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"session\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 4).toLowerCase() === \"icon\") {\n              result0 = input.substr(pos, 4);\n              pos += 4;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"icon\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 5).toLowerCase() === \"alert\") {\n                result0 = input.substr(pos, 5);\n                pos += 5;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"alert\\\"\");\n                }\n              }\n              if (result0 === null) {\n                result0 = parse_token();\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_disp_param() {\n        var result0;\n        result0 = parse_handling_param();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_handling_param() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 8).toLowerCase() === \"handling\") {\n          result0 = input.substr(pos, 8);\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"handling\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            if (input.substr(pos, 8).toLowerCase() === \"optional\") {\n              result2 = input.substr(pos, 8);\n              pos += 8;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"optional\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.substr(pos, 8).toLowerCase() === \"required\") {\n                result2 = input.substr(pos, 8);\n                pos += 8;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"required\\\"\");\n                }\n              }\n              if (result2 === null) {\n                result2 = parse_token();\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Content_Encoding() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Content_Length() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_DIGIT();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_DIGIT();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, length) {\n            data = parseInt(length.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Content_Type() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_media_type();\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_media_type() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_m_type();\n        if (result0 !== null) {\n          result1 = parse_SLASH();\n          if (result1 !== null) {\n            result2 = parse_m_subtype();\n            if (result2 !== null) {\n              result3 = [];\n              pos1 = pos;\n              result4 = parse_SEMI();\n              if (result4 !== null) {\n                result5 = parse_m_parameter();\n                if (result5 !== null) {\n                  result4 = [result4, result5];\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              } else {\n                result4 = null;\n                pos = pos1;\n              }\n              while (result4 !== null) {\n                result3.push(result4);\n                pos1 = pos;\n                result4 = parse_SEMI();\n                if (result4 !== null) {\n                  result5 = parse_m_parameter();\n                  if (result5 !== null) {\n                    result4 = [result4, result5];\n                  } else {\n                    result4 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              }\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_m_type() {\n        var result0;\n        result0 = parse_discrete_type();\n        if (result0 === null) {\n          result0 = parse_composite_type();\n        }\n        return result0;\n      }\n      function parse_discrete_type() {\n        var result0;\n        if (input.substr(pos, 4).toLowerCase() === \"text\") {\n          result0 = input.substr(pos, 4);\n          pos += 4;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"text\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 5).toLowerCase() === \"image\") {\n            result0 = input.substr(pos, 5);\n            pos += 5;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"image\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 5).toLowerCase() === \"audio\") {\n              result0 = input.substr(pos, 5);\n              pos += 5;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"audio\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 5).toLowerCase() === \"video\") {\n                result0 = input.substr(pos, 5);\n                pos += 5;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"video\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.substr(pos, 11).toLowerCase() === \"application\") {\n                  result0 = input.substr(pos, 11);\n                  pos += 11;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"application\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  result0 = parse_extension_token();\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_composite_type() {\n        var result0;\n        if (input.substr(pos, 7).toLowerCase() === \"message\") {\n          result0 = input.substr(pos, 7);\n          pos += 7;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"message\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 9).toLowerCase() === \"multipart\") {\n            result0 = input.substr(pos, 9);\n            pos += 9;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"multipart\\\"\");\n            }\n          }\n          if (result0 === null) {\n            result0 = parse_extension_token();\n          }\n        }\n        return result0;\n      }\n      function parse_extension_token() {\n        var result0;\n        result0 = parse_token();\n        if (result0 === null) {\n          result0 = parse_x_token();\n        }\n        return result0;\n      }\n      function parse_x_token() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 2).toLowerCase() === \"x-\") {\n          result0 = input.substr(pos, 2);\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"x-\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_token();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_m_subtype() {\n        var result0;\n        result0 = parse_extension_token();\n        if (result0 === null) {\n          result0 = parse_token();\n        }\n        return result0;\n      }\n      function parse_m_parameter() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_m_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_m_value() {\n        var result0;\n        result0 = parse_token();\n        if (result0 === null) {\n          result0 = parse_quoted_string();\n        }\n        return result0;\n      }\n      function parse_CSeq() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_CSeq_value();\n        if (result0 !== null) {\n          result1 = parse_LWS();\n          if (result1 !== null) {\n            result2 = parse_Method();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_CSeq_value() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_DIGIT();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_DIGIT();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, cseq_value) {\n            data.value = parseInt(cseq_value.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Expires() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_delta_seconds();\n        if (result0 !== null) {\n          result0 = function (offset, expires) {\n            data = expires;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Event() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_event_type();\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_generic_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_generic_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, event_type) {\n            data.event = event_type.join('').toLowerCase();\n          }(pos0, result0[0]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_event_type() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token_nodot();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 46) {\n            result2 = \".\";\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result2 !== null) {\n            result3 = parse_token_nodot();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 46) {\n              result2 = \".\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_token_nodot();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_From() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SIP_URI_noparams();\n        if (result0 === null) {\n          result0 = parse_name_addr();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_from_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_from_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var tag = data.tag;\n            try {\n              data = new NameAddrHeader(data.uri, data.display_name, data.params);\n              if (tag) {\n                data.setParam('tag', tag);\n              }\n            } catch (e) {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_from_param() {\n        var result0;\n        result0 = parse_tag_param();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_tag_param() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"tag\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"tag\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, tag) {\n            data.tag = tag;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Max_Forwards() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_DIGIT();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_DIGIT();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, forwards) {\n            data = parseInt(forwards.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Min_Expires() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_delta_seconds();\n        if (result0 !== null) {\n          result0 = function (offset, min_expires) {\n            data = min_expires;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Name_Addr_Header() {\n        var result0, result1, result2, result3, result4, result5, result6;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = [];\n        result1 = parse_display_name();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_display_name();\n        }\n        if (result0 !== null) {\n          result1 = parse_LAQUOT();\n          if (result1 !== null) {\n            result2 = parse_SIP_URI();\n            if (result2 !== null) {\n              result3 = parse_RAQUOT();\n              if (result3 !== null) {\n                result4 = [];\n                pos2 = pos;\n                result5 = parse_SEMI();\n                if (result5 !== null) {\n                  result6 = parse_generic_param();\n                  if (result6 !== null) {\n                    result5 = [result5, result6];\n                  } else {\n                    result5 = null;\n                    pos = pos2;\n                  }\n                } else {\n                  result5 = null;\n                  pos = pos2;\n                }\n                while (result5 !== null) {\n                  result4.push(result5);\n                  pos2 = pos;\n                  result5 = parse_SEMI();\n                  if (result5 !== null) {\n                    result6 = parse_generic_param();\n                    if (result6 !== null) {\n                      result5 = [result5, result6];\n                    } else {\n                      result5 = null;\n                      pos = pos2;\n                    }\n                  } else {\n                    result5 = null;\n                    pos = pos2;\n                  }\n                }\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            try {\n              data = new NameAddrHeader(data.uri, data.display_name, data.params);\n            } catch (e) {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Proxy_Authenticate() {\n        var result0;\n        result0 = parse_challenge();\n        return result0;\n      }\n      function parse_challenge() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"digest\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"Digest\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_LWS();\n          if (result1 !== null) {\n            result2 = parse_digest_cln();\n            if (result2 !== null) {\n              result3 = [];\n              pos1 = pos;\n              result4 = parse_COMMA();\n              if (result4 !== null) {\n                result5 = parse_digest_cln();\n                if (result5 !== null) {\n                  result4 = [result4, result5];\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              } else {\n                result4 = null;\n                pos = pos1;\n              }\n              while (result4 !== null) {\n                result3.push(result4);\n                pos1 = pos;\n                result4 = parse_COMMA();\n                if (result4 !== null) {\n                  result5 = parse_digest_cln();\n                  if (result5 !== null) {\n                    result4 = [result4, result5];\n                  } else {\n                    result4 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              }\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        if (result0 === null) {\n          result0 = parse_other_challenge();\n        }\n        return result0;\n      }\n      function parse_other_challenge() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = parse_LWS();\n          if (result1 !== null) {\n            result2 = parse_auth_param();\n            if (result2 !== null) {\n              result3 = [];\n              pos1 = pos;\n              result4 = parse_COMMA();\n              if (result4 !== null) {\n                result5 = parse_auth_param();\n                if (result5 !== null) {\n                  result4 = [result4, result5];\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              } else {\n                result4 = null;\n                pos = pos1;\n              }\n              while (result4 !== null) {\n                result3.push(result4);\n                pos1 = pos;\n                result4 = parse_COMMA();\n                if (result4 !== null) {\n                  result5 = parse_auth_param();\n                  if (result5 !== null) {\n                    result4 = [result4, result5];\n                  } else {\n                    result4 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              }\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_auth_param() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 === null) {\n              result2 = parse_quoted_string();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_digest_cln() {\n        var result0;\n        result0 = parse_realm();\n        if (result0 === null) {\n          result0 = parse_domain();\n          if (result0 === null) {\n            result0 = parse_nonce();\n            if (result0 === null) {\n              result0 = parse_opaque();\n              if (result0 === null) {\n                result0 = parse_stale();\n                if (result0 === null) {\n                  result0 = parse_algorithm();\n                  if (result0 === null) {\n                    result0 = parse_qop_options();\n                    if (result0 === null) {\n                      result0 = parse_auth_param();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_realm() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"realm\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"realm\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_realm_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_realm_value() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_quoted_string_clean();\n        if (result0 !== null) {\n          result0 = function (offset, realm) {\n            data.realm = realm;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_domain() {\n        var result0, result1, result2, result3, result4, result5, result6;\n        var pos0, pos1;\n        pos0 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"domain\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"domain\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_LDQUOT();\n            if (result2 !== null) {\n              result3 = parse_URI();\n              if (result3 !== null) {\n                result4 = [];\n                pos1 = pos;\n                result6 = parse_SP();\n                if (result6 !== null) {\n                  result5 = [];\n                  while (result6 !== null) {\n                    result5.push(result6);\n                    result6 = parse_SP();\n                  }\n                } else {\n                  result5 = null;\n                }\n                if (result5 !== null) {\n                  result6 = parse_URI();\n                  if (result6 !== null) {\n                    result5 = [result5, result6];\n                  } else {\n                    result5 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result5 = null;\n                  pos = pos1;\n                }\n                while (result5 !== null) {\n                  result4.push(result5);\n                  pos1 = pos;\n                  result6 = parse_SP();\n                  if (result6 !== null) {\n                    result5 = [];\n                    while (result6 !== null) {\n                      result5.push(result6);\n                      result6 = parse_SP();\n                    }\n                  } else {\n                    result5 = null;\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_URI();\n                    if (result6 !== null) {\n                      result5 = [result5, result6];\n                    } else {\n                      result5 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result5 = null;\n                    pos = pos1;\n                  }\n                }\n                if (result4 !== null) {\n                  result5 = parse_RDQUOT();\n                  if (result5 !== null) {\n                    result0 = [result0, result1, result2, result3, result4, result5];\n                  } else {\n                    result0 = null;\n                    pos = pos0;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_URI() {\n        var result0;\n        result0 = parse_absoluteURI();\n        if (result0 === null) {\n          result0 = parse_abs_path();\n        }\n        return result0;\n      }\n      function parse_nonce() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"nonce\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"nonce\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_nonce_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_nonce_value() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_quoted_string_clean();\n        if (result0 !== null) {\n          result0 = function (offset, nonce) {\n            data.nonce = nonce;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_opaque() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"opaque\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"opaque\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_quoted_string_clean();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, opaque) {\n            data.opaque = opaque;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_stale() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"stale\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"stale\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            pos1 = pos;\n            if (input.substr(pos, 4).toLowerCase() === \"true\") {\n              result2 = input.substr(pos, 4);\n              pos += 4;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"true\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result2 = function (offset) {\n                data.stale = true;\n              }(pos1);\n            }\n            if (result2 === null) {\n              pos = pos1;\n            }\n            if (result2 === null) {\n              pos1 = pos;\n              if (input.substr(pos, 5).toLowerCase() === \"false\") {\n                result2 = input.substr(pos, 5);\n                pos += 5;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"false\\\"\");\n                }\n              }\n              if (result2 !== null) {\n                result2 = function (offset) {\n                  data.stale = false;\n                }(pos1);\n              }\n              if (result2 === null) {\n                pos = pos1;\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_algorithm() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 9).toLowerCase() === \"algorithm\") {\n          result0 = input.substr(pos, 9);\n          pos += 9;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"algorithm\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            if (input.substr(pos, 3).toLowerCase() === \"md5\") {\n              result2 = input.substr(pos, 3);\n              pos += 3;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"MD5\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.substr(pos, 8).toLowerCase() === \"md5-sess\") {\n                result2 = input.substr(pos, 8);\n                pos += 8;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"MD5-sess\\\"\");\n                }\n              }\n              if (result2 === null) {\n                result2 = parse_token();\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, algorithm) {\n            data.algorithm = algorithm.toUpperCase();\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_qop_options() {\n        var result0, result1, result2, result3, result4, result5, result6;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"qop\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"qop\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_LDQUOT();\n            if (result2 !== null) {\n              pos1 = pos;\n              result3 = parse_qop_value();\n              if (result3 !== null) {\n                result4 = [];\n                pos2 = pos;\n                if (input.charCodeAt(pos) === 44) {\n                  result5 = \",\";\n                  pos++;\n                } else {\n                  result5 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\",\\\"\");\n                  }\n                }\n                if (result5 !== null) {\n                  result6 = parse_qop_value();\n                  if (result6 !== null) {\n                    result5 = [result5, result6];\n                  } else {\n                    result5 = null;\n                    pos = pos2;\n                  }\n                } else {\n                  result5 = null;\n                  pos = pos2;\n                }\n                while (result5 !== null) {\n                  result4.push(result5);\n                  pos2 = pos;\n                  if (input.charCodeAt(pos) === 44) {\n                    result5 = \",\";\n                    pos++;\n                  } else {\n                    result5 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\",\\\"\");\n                    }\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_qop_value();\n                    if (result6 !== null) {\n                      result5 = [result5, result6];\n                    } else {\n                      result5 = null;\n                      pos = pos2;\n                    }\n                  } else {\n                    result5 = null;\n                    pos = pos2;\n                  }\n                }\n                if (result4 !== null) {\n                  result3 = [result3, result4];\n                } else {\n                  result3 = null;\n                  pos = pos1;\n                }\n              } else {\n                result3 = null;\n                pos = pos1;\n              }\n              if (result3 !== null) {\n                result4 = parse_RDQUOT();\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_qop_value() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 8).toLowerCase() === \"auth-int\") {\n          result0 = input.substr(pos, 8);\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"auth-int\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 4).toLowerCase() === \"auth\") {\n            result0 = input.substr(pos, 4);\n            pos += 4;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"auth\\\"\");\n            }\n          }\n          if (result0 === null) {\n            result0 = parse_token();\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset, qop_value) {\n            data.qop || (data.qop = []);\n            data.qop.push(qop_value.toLowerCase());\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Proxy_Require() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Record_Route() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_rec_route();\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_rec_route();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_rec_route();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var idx, length;\n            length = data.multi_header.length;\n            for (idx = 0; idx < length; idx++) {\n              if (data.multi_header[idx].parsed === null) {\n                data = null;\n                break;\n              }\n            }\n            if (data !== null) {\n              data = data.multi_header;\n            } else {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_rec_route() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_name_addr();\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_generic_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_generic_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var header;\n            if (!data.multi_header) data.multi_header = [];\n            try {\n              header = new NameAddrHeader(data.uri, data.display_name, data.params);\n              delete data.uri;\n              delete data.display_name;\n              delete data.params;\n            } catch (e) {\n              header = null;\n            }\n            data.multi_header.push({ 'possition': pos,\n              'offset': offset,\n              'parsed': header\n            });\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Reason() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"sip\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"SIP\\\"\");\n          }\n        }\n        if (result0 === null) {\n          result0 = parse_token();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_reason_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_reason_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, protocol) {\n            data.protocol = protocol.toLowerCase();\n            if (!data.params) data.params = {};\n            if (data.params.text && data.params.text[0] === '\"') {\n              var text = data.params.text;\n              data.text = text.substring(1, text.length - 1);\n              delete data.params.text;\n            }\n          }(pos0, result0[0]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_reason_param() {\n        var result0;\n        result0 = parse_reason_cause();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_reason_cause() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"cause\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"cause\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result3 = parse_DIGIT();\n            if (result3 !== null) {\n              result2 = [];\n              while (result3 !== null) {\n                result2.push(result3);\n                result3 = parse_DIGIT();\n              }\n            } else {\n              result2 = null;\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, cause) {\n            data.cause = parseInt(cause.join(''));\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Require() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Route() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_route_param();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_route_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_route_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_route_param() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_name_addr();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_generic_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_generic_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Subscription_State() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_substate_value();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_subexp_params();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_subexp_params();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_substate_value() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"active\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"active\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 7).toLowerCase() === \"pending\") {\n            result0 = input.substr(pos, 7);\n            pos += 7;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"pending\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 10).toLowerCase() === \"terminated\") {\n              result0 = input.substr(pos, 10);\n              pos += 10;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"terminated\\\"\");\n              }\n            }\n            if (result0 === null) {\n              result0 = parse_token();\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.state = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_subexp_params() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"reason\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"reason\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_event_reason_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, reason) {\n            if (typeof reason !== 'undefined') data.reason = reason;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          pos1 = pos;\n          if (input.substr(pos, 7).toLowerCase() === \"expires\") {\n            result0 = input.substr(pos, 7);\n            pos += 7;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"expires\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = parse_EQUAL();\n            if (result1 !== null) {\n              result2 = parse_delta_seconds();\n              if (result2 !== null) {\n                result0 = [result0, result1, result2];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = function (offset, expires) {\n              if (typeof expires !== 'undefined') data.expires = expires;\n            }(pos0, result0[2]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            pos1 = pos;\n            if (input.substr(pos, 11).toLowerCase() === \"retry_after\") {\n              result0 = input.substr(pos, 11);\n              pos += 11;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"retry_after\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result1 = parse_EQUAL();\n              if (result1 !== null) {\n                result2 = parse_delta_seconds();\n                if (result2 !== null) {\n                  result0 = [result0, result1, result2];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n            if (result0 !== null) {\n              result0 = function (offset, retry_after) {\n                if (typeof retry_after !== 'undefined') data.retry_after = retry_after;\n              }(pos0, result0[2]);\n            }\n            if (result0 === null) {\n              pos = pos0;\n            }\n            if (result0 === null) {\n              result0 = parse_generic_param();\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_event_reason_value() {\n        var result0;\n        if (input.substr(pos, 11).toLowerCase() === \"deactivated\") {\n          result0 = input.substr(pos, 11);\n          pos += 11;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"deactivated\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 9).toLowerCase() === \"probation\") {\n            result0 = input.substr(pos, 9);\n            pos += 9;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"probation\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 8).toLowerCase() === \"rejected\") {\n              result0 = input.substr(pos, 8);\n              pos += 8;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"rejected\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 7).toLowerCase() === \"timeout\") {\n                result0 = input.substr(pos, 7);\n                pos += 7;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"timeout\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.substr(pos, 6).toLowerCase() === \"giveup\") {\n                  result0 = input.substr(pos, 6);\n                  pos += 6;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"giveup\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.substr(pos, 10).toLowerCase() === \"noresource\") {\n                    result0 = input.substr(pos, 10);\n                    pos += 10;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"noresource\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.substr(pos, 9).toLowerCase() === \"invariant\") {\n                      result0 = input.substr(pos, 9);\n                      pos += 9;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"invariant\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      result0 = parse_token();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_Subject() {\n        var result0;\n        result0 = parse_TEXT_UTF8_TRIM();\n        result0 = result0 !== null ? result0 : \"\";\n        return result0;\n      }\n      function parse_Supported() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        result0 = result0 !== null ? result0 : \"\";\n        return result0;\n      }\n      function parse_To() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SIP_URI_noparams();\n        if (result0 === null) {\n          result0 = parse_name_addr();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_to_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_to_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var tag = data.tag;\n            try {\n              data = new NameAddrHeader(data.uri, data.display_name, data.params);\n              if (tag) {\n                data.setParam('tag', tag);\n              }\n            } catch (e) {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_to_param() {\n        var result0;\n        result0 = parse_tag_param();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_Via() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_via_param();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_via_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_via_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_param() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_sent_protocol();\n        if (result0 !== null) {\n          result1 = parse_LWS();\n          if (result1 !== null) {\n            result2 = parse_sent_by();\n            if (result2 !== null) {\n              result3 = [];\n              pos1 = pos;\n              result4 = parse_SEMI();\n              if (result4 !== null) {\n                result5 = parse_via_params();\n                if (result5 !== null) {\n                  result4 = [result4, result5];\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              } else {\n                result4 = null;\n                pos = pos1;\n              }\n              while (result4 !== null) {\n                result3.push(result4);\n                pos1 = pos;\n                result4 = parse_SEMI();\n                if (result4 !== null) {\n                  result5 = parse_via_params();\n                  if (result5 !== null) {\n                    result4 = [result4, result5];\n                  } else {\n                    result4 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              }\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_params() {\n        var result0;\n        result0 = parse_via_ttl();\n        if (result0 === null) {\n          result0 = parse_via_maddr();\n          if (result0 === null) {\n            result0 = parse_via_received();\n            if (result0 === null) {\n              result0 = parse_via_branch();\n              if (result0 === null) {\n                result0 = parse_response_port();\n                if (result0 === null) {\n                  result0 = parse_generic_param();\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_via_ttl() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"ttl\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"ttl\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_ttl();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_ttl_value) {\n            data.ttl = via_ttl_value;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_maddr() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"maddr\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"maddr\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_host();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_maddr) {\n            data.maddr = via_maddr;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_received() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 8).toLowerCase() === \"received\") {\n          result0 = input.substr(pos, 8);\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"received\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_IPv4address();\n            if (result2 === null) {\n              result2 = parse_IPv6address();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_received) {\n            data.received = via_received;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_branch() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"branch\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"branch\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_branch) {\n            data.branch = via_branch;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_response_port() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"rport\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"rport\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          pos2 = pos;\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_DIGIT();\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_DIGIT();\n            }\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            if (typeof response_port !== 'undefined') data.rport = response_port.join('');\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_sent_protocol() {\n        var result0, result1, result2, result3, result4;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_protocol_name();\n        if (result0 !== null) {\n          result1 = parse_SLASH();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result3 = parse_SLASH();\n              if (result3 !== null) {\n                result4 = parse_transport();\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_protocol_name() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"sip\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"SIP\\\"\");\n          }\n        }\n        if (result0 === null) {\n          result0 = parse_token();\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_protocol) {\n            data.protocol = via_protocol;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_transport() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"udp\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"UDP\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 3).toLowerCase() === \"tcp\") {\n            result0 = input.substr(pos, 3);\n            pos += 3;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"TCP\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 3).toLowerCase() === \"tls\") {\n              result0 = input.substr(pos, 3);\n              pos += 3;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"TLS\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 4).toLowerCase() === \"sctp\") {\n                result0 = input.substr(pos, 4);\n                pos += 4;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"SCTP\\\"\");\n                }\n              }\n              if (result0 === null) {\n                result0 = parse_token();\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_transport) {\n            data.transport = via_transport;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_sent_by() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_via_host();\n        if (result0 !== null) {\n          pos1 = pos;\n          result1 = parse_COLON();\n          if (result1 !== null) {\n            result2 = parse_via_port();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos1;\n            }\n          } else {\n            result1 = null;\n            pos = pos1;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_host() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_IPv4address();\n        if (result0 === null) {\n          result0 = parse_IPv6reference();\n          if (result0 === null) {\n            result0 = parse_hostname();\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.host = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_port() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_DIGIT();\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result1 = parse_DIGIT();\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_DIGIT();\n              result3 = result3 !== null ? result3 : \"\";\n              if (result3 !== null) {\n                result4 = parse_DIGIT();\n                result4 = result4 !== null ? result4 : \"\";\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_sent_by_port) {\n            data.port = parseInt(via_sent_by_port.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_ttl() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_DIGIT();\n        if (result0 !== null) {\n          result1 = parse_DIGIT();\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, ttl) {\n            return parseInt(ttl.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_WWW_Authenticate() {\n        var result0;\n        result0 = parse_challenge();\n        return result0;\n      }\n      function parse_Session_Expires() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_s_e_expires();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_s_e_params();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_s_e_params();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_s_e_expires() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_delta_seconds();\n        if (result0 !== null) {\n          result0 = function (offset, expires) {\n            data.expires = expires;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_s_e_params() {\n        var result0;\n        result0 = parse_s_e_refresher();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_s_e_refresher() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 9).toLowerCase() === \"refresher\") {\n          result0 = input.substr(pos, 9);\n          pos += 9;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"refresher\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            if (input.substr(pos, 3).toLowerCase() === \"uac\") {\n              result2 = input.substr(pos, 3);\n              pos += 3;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"uac\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.substr(pos, 3).toLowerCase() === \"uas\") {\n                result2 = input.substr(pos, 3);\n                pos += 3;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"uas\\\"\");\n                }\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, s_e_refresher_value) {\n            data.refresher = s_e_refresher_value.toLowerCase();\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_extension_header() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = parse_HCOLON();\n          if (result1 !== null) {\n            result2 = parse_header_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_header_value() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_TEXT_UTF8char();\n        if (result1 === null) {\n          result1 = parse_UTF8_CONT();\n          if (result1 === null) {\n            result1 = parse_LWS();\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_TEXT_UTF8char();\n          if (result1 === null) {\n            result1 = parse_UTF8_CONT();\n            if (result1 === null) {\n              result1 = parse_LWS();\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_message_body() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_OCTET();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_OCTET();\n        }\n        return result0;\n      }\n      function parse_uuid_URI() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 5) === \"uuid:\") {\n          result0 = \"uuid:\";\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"uuid:\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_uuid();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uuid() {\n        var result0, result1, result2, result3, result4, result5, result6, result7, result8;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_hex8();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 45) {\n            result1 = \"-\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"-\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_hex4();\n            if (result2 !== null) {\n              if (input.charCodeAt(pos) === 45) {\n                result3 = \"-\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result4 = parse_hex4();\n                if (result4 !== null) {\n                  if (input.charCodeAt(pos) === 45) {\n                    result5 = \"-\";\n                    pos++;\n                  } else {\n                    result5 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"-\\\"\");\n                    }\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_hex4();\n                    if (result6 !== null) {\n                      if (input.charCodeAt(pos) === 45) {\n                        result7 = \"-\";\n                        pos++;\n                      } else {\n                        result7 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"-\\\"\");\n                        }\n                      }\n                      if (result7 !== null) {\n                        result8 = parse_hex12();\n                        if (result8 !== null) {\n                          result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, uuid) {\n            data = input.substring(pos + 5, offset);\n          }(pos0, result0[0]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hex4() {\n        var result0, result1, result2, result3;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_HEXDIG();\n        if (result0 !== null) {\n          result1 = parse_HEXDIG();\n          if (result1 !== null) {\n            result2 = parse_HEXDIG();\n            if (result2 !== null) {\n              result3 = parse_HEXDIG();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hex8() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_hex4();\n        if (result0 !== null) {\n          result1 = parse_hex4();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hex12() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_hex4();\n        if (result0 !== null) {\n          result1 = parse_hex4();\n          if (result1 !== null) {\n            result2 = parse_hex4();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Refer_To() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SIP_URI_noparams();\n        if (result0 === null) {\n          result0 = parse_name_addr();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_generic_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_generic_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            try {\n              data = new NameAddrHeader(data.uri, data.display_name, data.params);\n            } catch (e) {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Replaces() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_call_id();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_replaces_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_replaces_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_call_id() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_word();\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 64) {\n            result1 = \"@\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"@\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_word();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.call_id = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_replaces_param() {\n        var result0;\n        result0 = parse_to_tag();\n        if (result0 === null) {\n          result0 = parse_from_tag();\n          if (result0 === null) {\n            result0 = parse_early_flag();\n            if (result0 === null) {\n              result0 = parse_generic_param();\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_to_tag() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6) === \"to-tag\") {\n          result0 = \"to-tag\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"to-tag\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, to_tag) {\n            data.to_tag = to_tag;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_from_tag() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 8) === \"from-tag\") {\n          result0 = \"from-tag\";\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"from-tag\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, from_tag) {\n            data.from_tag = from_tag;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_early_flag() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 10) === \"early-only\") {\n          result0 = \"early-only\";\n          pos += 10;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"early-only\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.early_only = true;\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function cleanupExpected(expected) {\n        expected.sort();\n        var lastExpected = null;\n        var cleanExpected = [];\n        for (var i = 0; i < expected.length; i++) {\n          if (expected[i] !== lastExpected) {\n            cleanExpected.push(expected[i]);\n            lastExpected = expected[i];\n          }\n        }\n        return cleanExpected;\n      }\n      function computeErrorPosition() {\n        /*\n         * The first idea was to use |String.split| to break the input up to the\n         * error position along newlines and derive the line and column from\n         * there. However IE's |split| implementation is so broken that it was\n         * enough to prevent it.\n         */\n        var line = 1;\n        var column = 1;\n        var seenCR = false;\n        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {\n          var ch = input.charAt(i);\n          if (ch === \"\\n\") {\n            if (!seenCR) {\n              line++;\n            }\n            column = 1;\n            seenCR = false;\n          } else if (ch === \"\\r\" || ch === '\\u2028' || ch === '\\u2029') {\n            line++;\n            column = 1;\n            seenCR = true;\n          } else {\n            column++;\n            seenCR = false;\n          }\n        }\n        return { line: line, column: column };\n      }\n      var URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib-es5/URI.js\");\n      var NameAddrHeader = __webpack_require__(/*! ./NameAddrHeader */ \"./node_modules/jssip/lib-es5/NameAddrHeader.js\");\n      var data = {};\n      var result = parseFunctions[startRule]();\n      /*\n       * The parser is now in one of the following three states:\n       *\n       * 1. The parser successfully parsed the whole input.\n       *\n       *    - |result !== null|\n       *    - |pos === input.length|\n       *    - |rightmostFailuresExpected| may or may not contain something\n       *\n       * 2. The parser successfully parsed only a part of the input.\n       *\n       *    - |result !== null|\n       *    - |pos < input.length|\n       *    - |rightmostFailuresExpected| may or may not contain something\n       *\n       * 3. The parser did not successfully parse any part of the input.\n       *\n       *   - |result === null|\n       *   - |pos === 0|\n       *   - |rightmostFailuresExpected| contains at least one failure\n       *\n       * All code following this comment (including called functions) must\n       * handle these states.\n       */\n      if (result === null || pos !== input.length) {\n        var offset = Math.max(pos, rightmostFailuresPos);\n        var found = offset < input.length ? input.charAt(offset) : null;\n        var errorPosition = computeErrorPosition();\n        new this.SyntaxError(cleanupExpected(rightmostFailuresExpected), found, offset, errorPosition.line, errorPosition.column);\n        return -1;\n      }\n      return data;\n    },\n    /* Returns the parser source code. */\n    toSource: function toSource() {\n      return this._source;\n    }\n  };\n  /* Thrown when a parser encounters a syntax error. */\n  result.SyntaxError = function (expected, found, offset, line, column) {\n    function buildMessage(expected, found) {\n      var expectedHumanized, foundHumanized;\n      switch (expected.length) {\n        case 0:\n          expectedHumanized = \"end of input\";\n          break;\n        case 1:\n          expectedHumanized = expected[0];\n          break;\n        default:\n          expectedHumanized = expected.slice(0, expected.length - 1).join(\", \") + \" or \" + expected[expected.length - 1];\n      }\n      foundHumanized = found ? quote(found) : \"end of input\";\n      return \"Expected \" + expectedHumanized + \" but \" + foundHumanized + \" found.\";\n    }\n    this.name = \"SyntaxError\";\n    this.expected = expected;\n    this.found = found;\n    this.message = buildMessage(expected, found);\n    this.offset = offset;\n    this.line = line;\n    this.column = column;\n  };\n  result.SyntaxError.prototype = Error.prototype;\n  return result;\n}();\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Grammar.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/JsSIP.js":
/*!*********************************************!*\
  !*** ./node_modules/jssip/lib-es5/JsSIP.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! webrtc-adapter */ \"./node_modules/webrtc-adapter/src/js/adapter_core.js\");\nvar pkg = __webpack_require__(/*! ../package.json */ \"./node_modules/jssip/package.json\");\nvar C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar Exceptions = __webpack_require__(/*! ./Exceptions */ \"./node_modules/jssip/lib-es5/Exceptions.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar UA = __webpack_require__(/*! ./UA */ \"./node_modules/jssip/lib-es5/UA.js\");\nvar URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib-es5/URI.js\");\nvar NameAddrHeader = __webpack_require__(/*! ./NameAddrHeader */ \"./node_modules/jssip/lib-es5/NameAddrHeader.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib-es5/Grammar.js\");\nvar WebSocketInterface = __webpack_require__(/*! ./WebSocketInterface */ \"./node_modules/jssip/lib-es5/WebSocketInterface.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP');\n\ndebug('version %s', pkg.version);\n\n/**\n * Expose the JsSIP module.\n */\nmodule.exports = {\n  C: C,\n  Exceptions: Exceptions,\n  Utils: Utils,\n  UA: UA,\n  URI: URI,\n  NameAddrHeader: NameAddrHeader,\n  WebSocketInterface: WebSocketInterface,\n  Grammar: Grammar,\n  // Expose the debug module.\n  debug: __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\"),\n  // Expose the adapter module.\n  adapter: adapter,\n  get name() {\n    return pkg.title;\n  },\n  get version() {\n    return pkg.version;\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/JsSIP.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Message.js":
/*!***********************************************!*\
  !*** ./node_modules/jssip/lib-es5/Message.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib-es5/SIPMessage.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar RequestSender = __webpack_require__(/*! ./RequestSender */ \"./node_modules/jssip/lib-es5/RequestSender.js\");\nvar Exceptions = __webpack_require__(/*! ./Exceptions */ \"./node_modules/jssip/lib-es5/Exceptions.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:Message');\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(Message, _EventEmitter);\n\n  function Message(ua) {\n    _classCallCheck(this, Message);\n\n    var _this = _possibleConstructorReturn(this, (Message.__proto__ || Object.getPrototypeOf(Message)).call(this));\n\n    _this._ua = ua;\n    _this._request = null;\n    _this._closed = false;\n\n    _this._direction = null;\n    _this._local_identity = null;\n    _this._remote_identity = null;\n\n    // Whether an incoming message has been replied.\n    _this._is_replied = false;\n\n    // Custom message empty object for high level use.\n    _this._data = {};\n    return _this;\n  }\n\n  _createClass(Message, [{\n    key: 'send',\n    value: function send(target, body) {\n      var _this2 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var originalTarget = target;\n\n      if (target === undefined || body === undefined) {\n        throw new TypeError('Not enough arguments');\n      }\n\n      // Check target validity.\n      target = this._ua.normalizeTarget(target);\n      if (!target) {\n        throw new TypeError('Invalid target: ' + originalTarget);\n      }\n\n      // Get call options.\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n      var contentType = options.contentType || 'text/plain';\n\n      // Set event handlers.\n      for (var event in eventHandlers) {\n        if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {\n          this.on(event, eventHandlers[event]);\n        }\n      }\n\n      extraHeaders.push('Content-Type: ' + contentType);\n\n      this._request = new SIPMessage.OutgoingRequest(JsSIP_C.MESSAGE, target, this._ua, null, extraHeaders);\n\n      if (body) {\n        this._request.body = body;\n      }\n\n      var request_sender = new RequestSender(this._ua, this._request, {\n        onRequestTimeout: function onRequestTimeout() {\n          _this2._onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          _this2._onTransportError();\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          _this2._receiveResponse(response);\n        }\n      });\n\n      this._newMessage('local', this._request);\n\n      request_sender.send();\n    }\n  }, {\n    key: 'init_incoming',\n    value: function init_incoming(request) {\n      this._request = request;\n\n      this._newMessage('remote', request);\n\n      // Reply with a 200 OK if the user didn't reply.\n      if (!this._is_replied) {\n        this._is_replied = true;\n        request.reply(200);\n      }\n\n      this._close();\n    }\n\n    /**\n     * Accept the incoming Message\n     * Only valid for incoming Messages\n     */\n\n  }, {\n    key: 'accept',\n    value: function accept() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var body = options.body;\n\n      if (this._direction !== 'incoming') {\n        throw new Exceptions.NotSupportedError('\"accept\" not supported for outgoing Message');\n      }\n\n      if (this._is_replied) {\n        throw new Error('incoming Message already replied');\n      }\n\n      this._is_replied = true;\n      this._request.reply(200, null, extraHeaders, body);\n    }\n\n    /**\n     * Reject the incoming Message\n     * Only valid for incoming Messages\n     */\n\n  }, {\n    key: 'reject',\n    value: function reject() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var status_code = options.status_code || 480;\n      var reason_phrase = options.reason_phrase;\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var body = options.body;\n\n      if (this._direction !== 'incoming') {\n        throw new Exceptions.NotSupportedError('\"reject\" not supported for outgoing Message');\n      }\n\n      if (this._is_replied) {\n        throw new Error('incoming Message already replied');\n      }\n\n      if (status_code < 300 || status_code >= 700) {\n        throw new TypeError('Invalid status_code: ' + status_code);\n      }\n\n      this._is_replied = true;\n      this._request.reply(status_code, reason_phrase, extraHeaders, body);\n    }\n  }, {\n    key: '_receiveResponse',\n    value: function _receiveResponse(response) {\n      if (this._closed) {\n        return;\n      }\n      switch (true) {\n        case /^1[0-9]{2}$/.test(response.status_code):\n          // Ignore provisional responses.\n          break;\n\n        case /^2[0-9]{2}$/.test(response.status_code):\n          this._succeeded('remote', response);\n          break;\n\n        default:\n          {\n            var cause = Utils.sipErrorCause(response.status_code);\n\n            this._failed('remote', response, cause);\n            break;\n          }\n      }\n    }\n  }, {\n    key: '_onRequestTimeout',\n    value: function _onRequestTimeout() {\n      if (this._closed) {\n        return;\n      }\n      this._failed('system', null, JsSIP_C.causes.REQUEST_TIMEOUT);\n    }\n  }, {\n    key: '_onTransportError',\n    value: function _onTransportError() {\n      if (this._closed) {\n        return;\n      }\n      this._failed('system', null, JsSIP_C.causes.CONNECTION_ERROR);\n    }\n  }, {\n    key: '_close',\n    value: function _close() {\n      this._closed = true;\n      this._ua.destroyMessage(this);\n    }\n\n    /**\n     * Internal Callbacks\n     */\n\n  }, {\n    key: '_newMessage',\n    value: function _newMessage(originator, request) {\n      if (originator === 'remote') {\n        this._direction = 'incoming';\n        this._local_identity = request.to;\n        this._remote_identity = request.from;\n      } else if (originator === 'local') {\n        this._direction = 'outgoing';\n        this._local_identity = request.from;\n        this._remote_identity = request.to;\n      }\n\n      this._ua.newMessage(this, {\n        originator: originator,\n        message: this,\n        request: request\n      });\n    }\n  }, {\n    key: '_failed',\n    value: function _failed(originator, response, cause) {\n      debug('MESSAGE failed');\n\n      this._close();\n\n      debug('emit \"failed\"');\n\n      this.emit('failed', {\n        originator: originator,\n        response: response || null,\n        cause: cause\n      });\n    }\n  }, {\n    key: '_succeeded',\n    value: function _succeeded(originator, response) {\n      debug('MESSAGE succeeded');\n\n      this._close();\n\n      debug('emit \"succeeded\"');\n\n      this.emit('succeeded', {\n        originator: originator,\n        response: response\n      });\n    }\n  }, {\n    key: 'direction',\n    get: function get() {\n      return this._direction;\n    }\n  }, {\n    key: 'local_identity',\n    get: function get() {\n      return this._local_identity;\n    }\n  }, {\n    key: 'remote_identity',\n    get: function get() {\n      return this._remote_identity;\n    }\n  }]);\n\n  return Message;\n}(EventEmitter);\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Message.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/NameAddrHeader.js":
/*!******************************************************!*\
  !*** ./node_modules/jssip/lib-es5/NameAddrHeader.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib-es5/URI.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib-es5/Grammar.js\");\n\nmodule.exports = function () {\n  _createClass(NameAddrHeader, null, [{\n    key: 'parse',\n\n    /**\n     * Parse the given string and returns a NameAddrHeader instance or undefined if\n     * it is an invalid NameAddrHeader.\n     */\n    value: function parse(name_addr_header) {\n      name_addr_header = Grammar.parse(name_addr_header, 'Name_Addr_Header');\n\n      if (name_addr_header !== -1) {\n        return name_addr_header;\n      } else {\n        return undefined;\n      }\n    }\n  }]);\n\n  function NameAddrHeader(uri, display_name, parameters) {\n    _classCallCheck(this, NameAddrHeader);\n\n    // Checks.\n    if (!uri || !(uri instanceof URI)) {\n      throw new TypeError('missing or invalid \"uri\" parameter');\n    }\n\n    // Initialize parameters.\n    this._uri = uri;\n    this._parameters = {};\n    this._display_name = display_name;\n\n    for (var param in parameters) {\n      if (Object.prototype.hasOwnProperty.call(parameters, param)) {\n        this.setParam(param, parameters[param]);\n      }\n    }\n  }\n\n  _createClass(NameAddrHeader, [{\n    key: 'setParam',\n    value: function setParam(key, value) {\n      if (key) {\n        this._parameters[key.toLowerCase()] = typeof value === 'undefined' || value === null ? null : value.toString();\n      }\n    }\n  }, {\n    key: 'getParam',\n    value: function getParam(key) {\n      if (key) {\n        return this._parameters[key.toLowerCase()];\n      }\n    }\n  }, {\n    key: 'hasParam',\n    value: function hasParam(key) {\n      if (key) {\n        return this._parameters.hasOwnProperty(key.toLowerCase()) && true || false;\n      }\n    }\n  }, {\n    key: 'deleteParam',\n    value: function deleteParam(parameter) {\n      parameter = parameter.toLowerCase();\n      if (this._parameters.hasOwnProperty(parameter)) {\n        var value = this._parameters[parameter];\n\n        delete this._parameters[parameter];\n\n        return value;\n      }\n    }\n  }, {\n    key: 'clearParams',\n    value: function clearParams() {\n      this._parameters = {};\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      return new NameAddrHeader(this._uri.clone(), this._display_name, JSON.parse(JSON.stringify(this._parameters)));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var body = this._display_name || this._display_name === 0 ? '\"' + this._display_name + '\" ' : '';\n\n      body += '<' + this._uri.toString() + '>';\n\n      for (var parameter in this._parameters) {\n        if (Object.prototype.hasOwnProperty.call(this._parameters, parameter)) {\n          body += ';' + parameter;\n\n          if (this._parameters[parameter] !== null) {\n            body += '=' + this._parameters[parameter];\n          }\n        }\n      }\n\n      return body;\n    }\n  }, {\n    key: 'uri',\n    get: function get() {\n      return this._uri;\n    }\n  }, {\n    key: 'display_name',\n    get: function get() {\n      return this._display_name;\n    },\n    set: function set(value) {\n      this._display_name = value === 0 ? '0' : value;\n    }\n  }]);\n\n  return NameAddrHeader;\n}();\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/NameAddrHeader.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Parser.js":
/*!**********************************************!*\
  !*** ./node_modules/jssip/lib-es5/Parser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib-es5/Grammar.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib-es5/SIPMessage.js\");\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:ERROR:Parser');\n\ndebugerror.log = console.warn.bind(console);\n\n/**\n * Parse SIP Message\n */\nexports.parseMessage = function (data, ua) {\n  var message = void 0;\n  var bodyStart = void 0;\n  var headerEnd = data.indexOf('\\r\\n');\n\n  if (headerEnd === -1) {\n    debugerror('parseMessage() | no CRLF found, not a SIP message');\n\n    return;\n  }\n\n  // Parse first line. Check if it is a Request or a Reply.\n  var firstLine = data.substring(0, headerEnd);\n  var parsed = Grammar.parse(firstLine, 'Request_Response');\n\n  if (parsed === -1) {\n    debugerror('parseMessage() | error parsing first line of SIP message: \"' + firstLine + '\"');\n\n    return;\n  } else if (!parsed.status_code) {\n    message = new SIPMessage.IncomingRequest(ua);\n    message.method = parsed.method;\n    message.ruri = parsed.uri;\n  } else {\n    message = new SIPMessage.IncomingResponse();\n    message.status_code = parsed.status_code;\n    message.reason_phrase = parsed.reason_phrase;\n  }\n\n  message.data = data;\n  var headerStart = headerEnd + 2;\n\n  /* Loop over every line in data. Detect the end of each header and parse\n  * it or simply add to the headers collection.\n  */\n  while (true) {\n    headerEnd = getHeader(data, headerStart);\n\n    // The SIP message has normally finished.\n    if (headerEnd === -2) {\n      bodyStart = headerStart + 2;\n      break;\n    }\n    // Data.indexOf returned -1 due to a malformed message.\n    else if (headerEnd === -1) {\n        debugerror('parseMessage() | malformed message');\n\n        return;\n      }\n\n    parsed = parseHeader(message, data, headerStart, headerEnd);\n\n    if (parsed !== true) {\n      debugerror('parseMessage() |', parsed.error);\n\n      return;\n    }\n\n    headerStart = headerEnd + 2;\n  }\n\n  /* RFC3261 18.3.\n   * If there are additional bytes in the transport packet\n   * beyond the end of the body, they MUST be discarded.\n   */\n  if (message.hasHeader('content-length')) {\n    var contentLength = message.getHeader('content-length');\n\n    message.body = data.substr(bodyStart, contentLength);\n  } else {\n    message.body = data.substring(bodyStart);\n  }\n\n  return message;\n};\n\n/**\n * Extract and parse every header of a SIP message.\n */\nfunction getHeader(data, headerStart) {\n  // 'start' position of the header.\n  var start = headerStart;\n  // 'end' position of the header.\n  var end = 0;\n  // 'partial end' position of the header.\n  var partialEnd = 0;\n\n  // End of message.\n  if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n    return -2;\n  }\n\n  while (end === 0) {\n    // Partial End of Header.\n    partialEnd = data.indexOf('\\r\\n', start);\n\n    // 'indexOf' returns -1 if the value to be found never occurs.\n    if (partialEnd === -1) {\n      return partialEnd;\n    }\n\n    if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n      // Not the end of the message. Continue from the next position.\n      start = partialEnd + 2;\n    } else {\n      end = partialEnd;\n    }\n  }\n\n  return end;\n}\n\nfunction parseHeader(message, data, headerStart, headerEnd) {\n  var parsed = void 0;\n  var hcolonIndex = data.indexOf(':', headerStart);\n  var headerName = data.substring(headerStart, hcolonIndex).trim();\n  var headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();\n\n  // If header-field is well-known, parse it.\n  switch (headerName.toLowerCase()) {\n    case 'via':\n    case 'v':\n      message.addHeader('via', headerValue);\n      if (message.getHeaders('via').length === 1) {\n        parsed = message.parseHeader('Via');\n        if (parsed) {\n          message.via = parsed;\n          message.via_branch = parsed.branch;\n        }\n      } else {\n        parsed = 0;\n      }\n      break;\n    case 'from':\n    case 'f':\n      message.setHeader('from', headerValue);\n      parsed = message.parseHeader('from');\n      if (parsed) {\n        message.from = parsed;\n        message.from_tag = parsed.getParam('tag');\n      }\n      break;\n    case 'to':\n    case 't':\n      message.setHeader('to', headerValue);\n      parsed = message.parseHeader('to');\n      if (parsed) {\n        message.to = parsed;\n        message.to_tag = parsed.getParam('tag');\n      }\n      break;\n    case 'record-route':\n      parsed = Grammar.parse(headerValue, 'Record_Route');\n\n      if (parsed === -1) {\n        parsed = undefined;\n      } else {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = parsed[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var header = _step.value;\n\n            message.addHeader('record-route', headerValue.substring(header.possition, header.offset));\n            message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n      break;\n    case 'call-id':\n    case 'i':\n      message.setHeader('call-id', headerValue);\n      parsed = message.parseHeader('call-id');\n      if (parsed) {\n        message.call_id = headerValue;\n      }\n      break;\n    case 'contact':\n    case 'm':\n      parsed = Grammar.parse(headerValue, 'Contact');\n\n      if (parsed === -1) {\n        parsed = undefined;\n      } else {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = parsed[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _header = _step2.value;\n\n            message.addHeader('contact', headerValue.substring(_header.possition, _header.offset));\n            message.headers.Contact[message.getHeaders('contact').length - 1].parsed = _header.parsed;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n      break;\n    case 'content-length':\n    case 'l':\n      message.setHeader('content-length', headerValue);\n      parsed = message.parseHeader('content-length');\n      break;\n    case 'content-type':\n    case 'c':\n      message.setHeader('content-type', headerValue);\n      parsed = message.parseHeader('content-type');\n      break;\n    case 'cseq':\n      message.setHeader('cseq', headerValue);\n      parsed = message.parseHeader('cseq');\n      if (parsed) {\n        message.cseq = parsed.value;\n      }\n      if (message instanceof SIPMessage.IncomingResponse) {\n        message.method = parsed.method;\n      }\n      break;\n    case 'max-forwards':\n      message.setHeader('max-forwards', headerValue);\n      parsed = message.parseHeader('max-forwards');\n      break;\n    case 'www-authenticate':\n      message.setHeader('www-authenticate', headerValue);\n      parsed = message.parseHeader('www-authenticate');\n      break;\n    case 'proxy-authenticate':\n      message.setHeader('proxy-authenticate', headerValue);\n      parsed = message.parseHeader('proxy-authenticate');\n      break;\n    case 'session-expires':\n    case 'x':\n      message.setHeader('session-expires', headerValue);\n      parsed = message.parseHeader('session-expires');\n      if (parsed) {\n        message.session_expires = parsed.expires;\n        message.session_expires_refresher = parsed.refresher;\n      }\n      break;\n    case 'refer-to':\n    case 'r':\n      message.setHeader('refer-to', headerValue);\n      parsed = message.parseHeader('refer-to');\n      if (parsed) {\n        message.refer_to = parsed;\n      }\n      break;\n    case 'replaces':\n      message.setHeader('replaces', headerValue);\n      parsed = message.parseHeader('replaces');\n      if (parsed) {\n        message.replaces = parsed;\n      }\n      break;\n    case 'event':\n    case 'o':\n      message.setHeader('event', headerValue);\n      parsed = message.parseHeader('event');\n      if (parsed) {\n        message.event = parsed;\n      }\n      break;\n    default:\n      // Do not parse this header.\n      message.addHeader(headerName, headerValue);\n      parsed = 0;\n  }\n\n  if (parsed === undefined) {\n    return {\n      error: 'error parsing header \"' + headerName + '\"'\n    };\n  } else {\n    return true;\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Parser.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/RTCSession.js":
/*!**************************************************!*\
  !*** ./node_modules/jssip/lib-es5/RTCSession.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof2(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof2(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/* globals RTCPeerConnection: false, RTCSessionDescription: false */\n\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar sdp_transform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nvar JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar Exceptions = __webpack_require__(/*! ./Exceptions */ \"./node_modules/jssip/lib-es5/Exceptions.js\");\nvar Transactions = __webpack_require__(/*! ./Transactions */ \"./node_modules/jssip/lib-es5/Transactions.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar Timers = __webpack_require__(/*! ./Timers */ \"./node_modules/jssip/lib-es5/Timers.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib-es5/SIPMessage.js\");\nvar Dialog = __webpack_require__(/*! ./Dialog */ \"./node_modules/jssip/lib-es5/Dialog.js\");\nvar RequestSender = __webpack_require__(/*! ./RequestSender */ \"./node_modules/jssip/lib-es5/RequestSender.js\");\nvar RTCSession_DTMF = __webpack_require__(/*! ./RTCSession/DTMF */ \"./node_modules/jssip/lib-es5/RTCSession/DTMF.js\");\nvar RTCSession_Info = __webpack_require__(/*! ./RTCSession/Info */ \"./node_modules/jssip/lib-es5/RTCSession/Info.js\");\nvar RTCSession_ReferNotifier = __webpack_require__(/*! ./RTCSession/ReferNotifier */ \"./node_modules/jssip/lib-es5/RTCSession/ReferNotifier.js\");\nvar RTCSession_ReferSubscriber = __webpack_require__(/*! ./RTCSession/ReferSubscriber */ \"./node_modules/jssip/lib-es5/RTCSession/ReferSubscriber.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:RTCSession');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:ERROR:RTCSession');\n\ndebugerror.log = console.warn.bind(console);\n\nvar C = {\n  // RTCSession states.\n  STATUS_NULL: 0,\n  STATUS_INVITE_SENT: 1,\n  STATUS_1XX_RECEIVED: 2,\n  STATUS_INVITE_RECEIVED: 3,\n  STATUS_WAITING_FOR_ANSWER: 4,\n  STATUS_ANSWERED: 5,\n  STATUS_WAITING_FOR_ACK: 6,\n  STATUS_CANCELED: 7,\n  STATUS_TERMINATED: 8,\n  STATUS_CONFIRMED: 9\n};\n\n/**\n * Local variables.\n */\nvar holdMediaTypes = ['audio', 'video'];\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(RTCSession, _EventEmitter);\n\n  _createClass(RTCSession, null, [{\n    key: 'C',\n\n    /**\n     * Expose C object.\n     */\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  function RTCSession(ua) {\n    _classCallCheck(this, RTCSession);\n\n    debug('new');\n\n    var _this = _possibleConstructorReturn(this, (RTCSession.__proto__ || Object.getPrototypeOf(RTCSession)).call(this));\n\n    _this._id = null;\n    _this._ua = ua;\n    _this._status = C.STATUS_NULL;\n    _this._dialog = null;\n    _this._earlyDialogs = {};\n    _this._contact = null;\n    _this._from_tag = null;\n    _this._to_tag = null;\n\n    // The RTCPeerConnection instance (public attribute).\n    _this._connection = null;\n\n    // Prevent races on serial PeerConnction operations.\n    _this._connectionPromiseQueue = Promise.resolve();\n\n    // Incoming/Outgoing request being currently processed.\n    _this._request = null;\n\n    // Cancel state for initial outgoing request.\n    _this._is_canceled = false;\n    _this._cancel_reason = '';\n\n    // RTCSession confirmation flag.\n    _this._is_confirmed = false;\n\n    // Is late SDP being negotiated.\n    _this._late_sdp = false;\n\n    // Default rtcOfferConstraints and rtcAnswerConstrainsts (passed in connect() or answer()).\n    _this._rtcOfferConstraints = null;\n    _this._rtcAnswerConstraints = null;\n\n    // Local MediaStream.\n    _this._localMediaStream = null;\n    _this._localMediaStreamLocallyGenerated = false;\n\n    // Flag to indicate PeerConnection ready for new actions.\n    _this._rtcReady = true;\n\n    // SIP Timers.\n    _this._timers = {\n      ackTimer: null,\n      expiresTimer: null,\n      invite2xxTimer: null,\n      userNoAnswerTimer: null\n    };\n\n    // Session info.\n    _this._direction = null;\n    _this._local_identity = null;\n    _this._remote_identity = null;\n    _this._start_time = null;\n    _this._end_time = null;\n    _this._tones = null;\n\n    // Mute/Hold state.\n    _this._audioMuted = false;\n    _this._videoMuted = false;\n    _this._localHold = false;\n    _this._remoteHold = false;\n\n    // Session Timers (RFC 4028).\n    _this._sessionTimers = {\n      enabled: _this._ua.configuration.session_timers,\n      refreshMethod: _this._ua.configuration.session_timers_refresh_method,\n      defaultExpires: JsSIP_C.SESSION_EXPIRES,\n      currentExpires: null,\n      running: false,\n      refresher: false,\n      timer: null // A setTimeout.\n    };\n\n    // Map of ReferSubscriber instances indexed by the REFER's CSeq number.\n    _this._referSubscribers = {};\n\n    // Custom session empty object for high level use.\n    _this._data = {};\n    return _this;\n  }\n\n  /**\n   * User API\n   */\n\n  // Expose RTCSession constants as a property of the RTCSession instance.\n\n\n  _createClass(RTCSession, [{\n    key: 'isInProgress',\n    value: function isInProgress() {\n      switch (this._status) {\n        case C.STATUS_NULL:\n        case C.STATUS_INVITE_SENT:\n        case C.STATUS_1XX_RECEIVED:\n        case C.STATUS_INVITE_RECEIVED:\n        case C.STATUS_WAITING_FOR_ANSWER:\n          return true;\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: 'isEstablished',\n    value: function isEstablished() {\n      switch (this._status) {\n        case C.STATUS_ANSWERED:\n        case C.STATUS_WAITING_FOR_ACK:\n        case C.STATUS_CONFIRMED:\n          return true;\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: 'isEnded',\n    value: function isEnded() {\n      switch (this._status) {\n        case C.STATUS_CANCELED:\n        case C.STATUS_TERMINATED:\n          return true;\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: 'isMuted',\n    value: function isMuted() {\n      return {\n        audio: this._audioMuted,\n        video: this._videoMuted\n      };\n    }\n  }, {\n    key: 'isOnHold',\n    value: function isOnHold() {\n      return {\n        local: this._localHold,\n        remote: this._remoteHold\n      };\n    }\n  }, {\n    key: 'connect',\n    value: function connect(target) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var initCallback = arguments[2];\n\n      debug('connect()');\n\n      var originalTarget = target;\n      var eventHandlers = options.eventHandlers || {};\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var mediaConstraints = options.mediaConstraints || { audio: true, video: true };\n      var mediaStream = options.mediaStream || null;\n      var pcConfig = options.pcConfig || { iceServers: [] };\n      var rtcConstraints = options.rtcConstraints || null;\n      var rtcOfferConstraints = options.rtcOfferConstraints || null;\n\n      this._rtcOfferConstraints = rtcOfferConstraints;\n      this._rtcAnswerConstraints = options.rtcAnswerConstraints || null;\n\n      this._data = options.data || this._data;\n\n      // Check target.\n      if (target === undefined) {\n        throw new TypeError('Not enough arguments');\n      }\n\n      // Check Session Status.\n      if (this._status !== C.STATUS_NULL) {\n        throw new Exceptions.InvalidStateError(this._status);\n      }\n\n      // Check WebRTC support.\n      if (!window.RTCPeerConnection) {\n        throw new Exceptions.NotSupportedError('WebRTC not supported');\n      }\n\n      // Check target validity.\n      target = this._ua.normalizeTarget(target);\n      if (!target) {\n        throw new TypeError('Invalid target: ' + originalTarget);\n      }\n\n      // Session Timers.\n      if (this._sessionTimers.enabled) {\n        if (Utils.isDecimal(options.sessionTimersExpires)) {\n          if (options.sessionTimersExpires >= JsSIP_C.MIN_SESSION_EXPIRES) {\n            this._sessionTimers.defaultExpires = options.sessionTimersExpires;\n          } else {\n            this._sessionTimers.defaultExpires = JsSIP_C.SESSION_EXPIRES;\n          }\n        }\n      }\n\n      // Set event handlers.\n      for (var event in eventHandlers) {\n        if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {\n          this.on(event, eventHandlers[event]);\n        }\n      }\n\n      // Session parameter initialization.\n      this._from_tag = Utils.newTag();\n\n      // Set anonymous property.\n      var anonymous = options.anonymous || false;\n\n      var requestParams = { from_tag: this._from_tag };\n\n      this._contact = this._ua.contact.toString({\n        anonymous: anonymous,\n        outbound: true\n      });\n\n      if (anonymous) {\n        requestParams.from_display_name = 'Anonymous';\n        requestParams.from_uri = 'sip:anonymous@anonymous.invalid';\n\n        extraHeaders.push('P-Preferred-Identity: ' + this._ua.configuration.uri.toString());\n        extraHeaders.push('Privacy: id');\n      }\n\n      extraHeaders.push('Contact: ' + this._contact);\n      extraHeaders.push('Content-Type: application/sdp');\n      if (this._sessionTimers.enabled) {\n        extraHeaders.push('Session-Expires: ' + this._sessionTimers.defaultExpires);\n      }\n\n      this._request = new SIPMessage.InitialOutgoingInviteRequest(target, this._ua, requestParams, extraHeaders);\n\n      this._id = this._request.call_id + this._from_tag;\n\n      // Create a new RTCPeerConnection instance.\n      this._createRTCConnection(pcConfig, rtcConstraints);\n\n      // Set internal properties.\n      this._direction = 'outgoing';\n      this._local_identity = this._request.from;\n      this._remote_identity = this._request.to;\n\n      // User explicitly provided a newRTCSession callback for this session.\n      if (initCallback) {\n        initCallback(this);\n      }\n\n      this._newRTCSession('local', this._request);\n\n      this._sendInitialRequest(mediaConstraints, rtcOfferConstraints, mediaStream);\n    }\n  }, {\n    key: 'init_incoming',\n    value: function init_incoming(request, initCallback) {\n      var _this2 = this;\n\n      debug('init_incoming()');\n\n      var expires = void 0;\n      var contentType = request.getHeader('Content-Type');\n\n      // Check body and content type.\n      if (request.body && contentType !== 'application/sdp') {\n        request.reply(415);\n\n        return;\n      }\n\n      // Session parameter initialization.\n      this._status = C.STATUS_INVITE_RECEIVED;\n      this._from_tag = request.from_tag;\n      this._id = request.call_id + this._from_tag;\n      this._request = request;\n      this._contact = this._ua.contact.toString();\n\n      // Get the Expires header value if exists.\n      if (request.hasHeader('expires')) {\n        expires = request.getHeader('expires') * 1000;\n      }\n\n      /* Set the to_tag before\n       * replying a response code that will create a dialog.\n       */\n      request.to_tag = Utils.newTag();\n\n      // An error on dialog creation will fire 'failed' event.\n      if (!this._createDialog(request, 'UAS', true)) {\n        request.reply(500, 'Missing Contact header field');\n\n        return;\n      }\n\n      if (request.body) {\n        this._late_sdp = false;\n      } else {\n        this._late_sdp = true;\n      }\n\n      this._status = C.STATUS_WAITING_FOR_ANSWER;\n\n      // Set userNoAnswerTimer.\n      this._timers.userNoAnswerTimer = setTimeout(function () {\n        request.reply(408);\n        _this2._failed('local', null, JsSIP_C.causes.NO_ANSWER);\n      }, this._ua.configuration.no_answer_timeout);\n\n      /* Set expiresTimer\n       * RFC3261 13.3.1\n       */\n      if (expires) {\n        this._timers.expiresTimer = setTimeout(function () {\n          if (_this2._status === C.STATUS_WAITING_FOR_ANSWER) {\n            request.reply(487);\n            _this2._failed('system', null, JsSIP_C.causes.EXPIRES);\n          }\n        }, expires);\n      }\n\n      // Set internal properties.\n      this._direction = 'incoming';\n      this._local_identity = request.to;\n      this._remote_identity = request.from;\n\n      // A init callback was specifically defined.\n      if (initCallback) {\n        initCallback(this);\n      }\n\n      // Fire 'newRTCSession' event.\n      this._newRTCSession('remote', request);\n\n      // The user may have rejected the call in the 'newRTCSession' event.\n      if (this._status === C.STATUS_TERMINATED) {\n        return;\n      }\n\n      // Reply 180.\n      request.reply(180, null, ['Contact: ' + this._contact]);\n\n      // Fire 'progress' event.\n      // TODO: Document that 'response' field in 'progress' event is null for incoming calls.\n      this._progress('local', null);\n    }\n\n    /**\n     * Answer the call.\n     */\n\n  }, {\n    key: 'answer',\n    value: function answer() {\n      var _this3 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      debug('answer()');\n\n      var request = this._request;\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var mediaConstraints = options.mediaConstraints || {};\n      var mediaStream = options.mediaStream || null;\n      var pcConfig = options.pcConfig || { iceServers: [] };\n      var rtcConstraints = options.rtcConstraints || null;\n      var rtcAnswerConstraints = options.rtcAnswerConstraints || null;\n\n      var tracks = void 0;\n      var peerHasAudioLine = false;\n      var peerHasVideoLine = false;\n      var peerOffersFullAudio = false;\n      var peerOffersFullVideo = false;\n\n      this._rtcAnswerConstraints = rtcAnswerConstraints;\n      this._rtcOfferConstraints = options.rtcOfferConstraints || null;\n\n      this._data = options.data || this._data;\n\n      // Check Session Direction and Status.\n      if (this._direction !== 'incoming') {\n        throw new Exceptions.NotSupportedError('\"answer\" not supported for outgoing RTCSession');\n      }\n\n      // Check Session status.\n      if (this._status !== C.STATUS_WAITING_FOR_ANSWER) {\n        throw new Exceptions.InvalidStateError(this._status);\n      }\n\n      // Session Timers.\n      if (this._sessionTimers.enabled) {\n        if (Utils.isDecimal(options.sessionTimersExpires)) {\n          if (options.sessionTimersExpires >= JsSIP_C.MIN_SESSION_EXPIRES) {\n            this._sessionTimers.defaultExpires = options.sessionTimersExpires;\n          } else {\n            this._sessionTimers.defaultExpires = JsSIP_C.SESSION_EXPIRES;\n          }\n        }\n      }\n\n      this._status = C.STATUS_ANSWERED;\n\n      // An error on dialog creation will fire 'failed' event.\n      if (!this._createDialog(request, 'UAS')) {\n        request.reply(500, 'Error creating dialog');\n\n        return;\n      }\n\n      clearTimeout(this._timers.userNoAnswerTimer);\n\n      extraHeaders.unshift('Contact: ' + this._contact);\n\n      // Determine incoming media from incoming SDP offer (if any).\n      var sdp = request.parseSDP();\n\n      // Make sure sdp.media is an array, not the case if there is only one media.\n      if (!Array.isArray(sdp.media)) {\n        sdp.media = [sdp.media];\n      }\n\n      // Go through all medias in SDP to find offered capabilities to answer with.\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = sdp.media[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var m = _step.value;\n\n          if (m.type === 'audio') {\n            peerHasAudioLine = true;\n            if (!m.direction || m.direction === 'sendrecv') {\n              peerOffersFullAudio = true;\n            }\n          }\n          if (m.type === 'video') {\n            peerHasVideoLine = true;\n            if (!m.direction || m.direction === 'sendrecv') {\n              peerOffersFullVideo = true;\n            }\n          }\n        }\n\n        // Remove audio from mediaStream if suggested by mediaConstraints.\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (mediaStream && mediaConstraints.audio === false) {\n        tracks = mediaStream.getAudioTracks();\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = tracks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var track = _step2.value;\n\n            mediaStream.removeTrack(track);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n\n      // Remove video from mediaStream if suggested by mediaConstraints.\n      if (mediaStream && mediaConstraints.video === false) {\n        tracks = mediaStream.getVideoTracks();\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = tracks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _track = _step3.value;\n\n            mediaStream.removeTrack(_track);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      // Set audio constraints based on incoming stream if not supplied.\n      if (!mediaStream && mediaConstraints.audio === undefined) {\n        mediaConstraints.audio = peerOffersFullAudio;\n      }\n\n      // Set video constraints based on incoming stream if not supplied.\n      if (!mediaStream && mediaConstraints.video === undefined) {\n        mediaConstraints.video = peerOffersFullVideo;\n      }\n\n      // Don't ask for audio if the incoming offer has no audio section.\n      if (!mediaStream && !peerHasAudioLine) {\n        mediaConstraints.audio = false;\n      }\n\n      // Don't ask for video if the incoming offer has no video section.\n      if (!mediaStream && !peerHasVideoLine) {\n        mediaConstraints.video = false;\n      }\n\n      // Create a new RTCPeerConnection instance.\n      // TODO: This may throw an error, should react.\n      this._createRTCConnection(pcConfig, rtcConstraints);\n\n      Promise.resolve()\n      // Handle local MediaStream.\n      .then(function () {\n        // A local MediaStream is given, use it.\n        if (mediaStream) {\n          return mediaStream;\n        }\n\n        // Audio and/or video requested, prompt getUserMedia.\n        else if (mediaConstraints.audio || mediaConstraints.video) {\n            _this3._localMediaStreamLocallyGenerated = true;\n\n            return navigator.mediaDevices.getUserMedia(mediaConstraints).catch(function (error) {\n              if (_this3._status === C.STATUS_TERMINATED) {\n                throw new Error('terminated');\n              }\n\n              request.reply(480);\n              _this3._failed('local', null, JsSIP_C.causes.USER_DENIED_MEDIA_ACCESS);\n\n              debugerror('emit \"getusermediafailed\" [error:%o]', error);\n\n              _this3.emit('getusermediafailed', error);\n\n              throw new Error('getUserMedia() failed');\n            });\n          }\n      })\n      // Attach MediaStream to RTCPeerconnection.\n      .then(function (stream) {\n        if (_this3._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        _this3._localMediaStream = stream;\n        if (stream) {\n          _this3._connection.addStream(stream);\n        }\n      })\n      // Set remote description.\n      .then(function () {\n        if (_this3._late_sdp) {\n          return;\n        }\n\n        var e = { originator: 'remote', type: 'offer', sdp: request.body };\n\n        debug('emit \"sdp\"');\n        _this3.emit('sdp', e);\n\n        var offer = new RTCSessionDescription({ type: 'offer', sdp: e.sdp });\n\n        _this3._connectionPromiseQueue = _this3._connectionPromiseQueue.then(function () {\n          return _this3._connection.setRemoteDescription(offer);\n        }).catch(function (error) {\n          request.reply(488);\n\n          _this3._failed('system', null, JsSIP_C.causes.WEBRTC_ERROR);\n\n          debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n          _this3.emit('peerconnection:setremotedescriptionfailed', error);\n\n          throw new Error('peerconnection.setRemoteDescription() failed');\n        });\n\n        return _this3._connectionPromiseQueue;\n      })\n      // Create local description.\n      .then(function () {\n        if (_this3._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        // TODO: Is this event already useful?\n        _this3._connecting(request);\n\n        if (!_this3._late_sdp) {\n          return _this3._createLocalDescription('answer', rtcAnswerConstraints).catch(function () {\n            request.reply(500);\n\n            throw new Error('_createLocalDescription() failed');\n          });\n        } else {\n          return _this3._createLocalDescription('offer', _this3._rtcOfferConstraints).catch(function () {\n            request.reply(500);\n\n            throw new Error('_createLocalDescription() failed');\n          });\n        }\n      })\n      // Send reply.\n      .then(function (desc) {\n        if (_this3._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        _this3._handleSessionTimersInIncomingRequest(request, extraHeaders);\n\n        request.reply(200, null, extraHeaders, desc, function () {\n          _this3._status = C.STATUS_WAITING_FOR_ACK;\n\n          _this3._setInvite2xxTimer(request, desc);\n          _this3._setACKTimer();\n          _this3._accepted('local');\n        }, function () {\n          _this3._failed('system', null, JsSIP_C.causes.CONNECTION_ERROR);\n        });\n      }).catch(function (error) {\n        if (_this3._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        debugerror(error);\n      });\n    }\n\n    /**\n     * Terminate the call.\n     */\n\n  }, {\n    key: 'terminate',\n    value: function terminate() {\n      var _this4 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      debug('terminate()');\n\n      var cause = options.cause || JsSIP_C.causes.BYE;\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var body = options.body;\n\n      var cancel_reason = void 0;\n      var status_code = options.status_code;\n      var reason_phrase = options.reason_phrase;\n\n      // Check Session Status.\n      if (this._status === C.STATUS_TERMINATED) {\n        throw new Exceptions.InvalidStateError(this._status);\n      }\n\n      switch (this._status) {\n        // - UAC -\n        case C.STATUS_NULL:\n        case C.STATUS_INVITE_SENT:\n        case C.STATUS_1XX_RECEIVED:\n          debug('canceling session');\n\n          if (status_code && (status_code < 200 || status_code >= 700)) {\n            throw new TypeError('Invalid status_code: ' + status_code);\n          } else if (status_code) {\n            reason_phrase = reason_phrase || JsSIP_C.REASON_PHRASE[status_code] || '';\n            cancel_reason = 'SIP ;cause=' + status_code + ' ;text=\"' + reason_phrase + '\"';\n          }\n\n          // Check Session Status.\n          if (this._status === C.STATUS_NULL || this._status === C.STATUS_INVITE_SENT) {\n            this._is_canceled = true;\n            this._cancel_reason = cancel_reason;\n          } else if (this._status === C.STATUS_1XX_RECEIVED) {\n            this._request.cancel(cancel_reason);\n          }\n\n          this._status = C.STATUS_CANCELED;\n\n          this._failed('local', null, JsSIP_C.causes.CANCELED);\n          break;\n\n        // - UAS -\n        case C.STATUS_WAITING_FOR_ANSWER:\n        case C.STATUS_ANSWERED:\n          debug('rejecting session');\n\n          status_code = status_code || 480;\n\n          if (status_code < 300 || status_code >= 700) {\n            throw new TypeError('Invalid status_code: ' + status_code);\n          }\n\n          this._request.reply(status_code, reason_phrase, extraHeaders, body);\n          this._failed('local', null, JsSIP_C.causes.REJECTED);\n          break;\n\n        case C.STATUS_WAITING_FOR_ACK:\n        case C.STATUS_CONFIRMED:\n          debug('terminating session');\n\n          reason_phrase = options.reason_phrase || JsSIP_C.REASON_PHRASE[status_code] || '';\n\n          if (status_code && (status_code < 200 || status_code >= 700)) {\n            throw new TypeError('Invalid status_code: ' + status_code);\n          } else if (status_code) {\n            extraHeaders.push('Reason: SIP ;cause=' + status_code + '; text=\"' + reason_phrase + '\"');\n          }\n\n          /* RFC 3261 section 15 (Terminating a session):\n            *\n            * \"...the callee's UA MUST NOT send a BYE on a confirmed dialog\n            * until it has received an ACK for its 2xx response or until the server\n            * transaction times out.\"\n            */\n          if (this._status === C.STATUS_WAITING_FOR_ACK && this._direction === 'incoming' && this._request.server_transaction.state !== Transactions.C.STATUS_TERMINATED) {\n\n            // Save the dialog for later restoration.\n            var dialog = this._dialog;\n\n            // Send the BYE as soon as the ACK is received...\n            this.receiveRequest = function (_ref) {\n              var method = _ref.method;\n\n              if (method === JsSIP_C.ACK) {\n                _this4.sendRequest(JsSIP_C.BYE, {\n                  extraHeaders: extraHeaders,\n                  body: body\n                });\n                dialog.terminate();\n              }\n            };\n\n            // .., or when the INVITE transaction times out\n            this._request.server_transaction.on('stateChanged', function () {\n              if (_this4._request.server_transaction.state === Transactions.C.STATUS_TERMINATED) {\n                _this4.sendRequest(JsSIP_C.BYE, {\n                  extraHeaders: extraHeaders,\n                  body: body\n                });\n                dialog.terminate();\n              }\n            });\n\n            this._ended('local', null, cause);\n\n            // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-).\n            this._dialog = dialog;\n\n            // Restore the dialog into 'ua' so the ACK can reach 'this' session.\n            this._ua.newDialog(dialog);\n          } else {\n            this.sendRequest(JsSIP_C.BYE, {\n              extraHeaders: extraHeaders,\n              body: body\n            });\n\n            this._ended('local', null, cause);\n          }\n      }\n    }\n  }, {\n    key: 'sendDTMF',\n    value: function sendDTMF(tones) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      debug('sendDTMF() | tones: %s', tones);\n\n      var position = 0;\n      var duration = options.duration || null;\n      var interToneGap = options.interToneGap || null;\n\n      if (tones === undefined) {\n        throw new TypeError('Not enough arguments');\n      }\n\n      // Check Session Status.\n      if (this._status !== C.STATUS_CONFIRMED && this._status !== C.STATUS_WAITING_FOR_ACK) {\n        throw new Exceptions.InvalidStateError(this._status);\n      }\n\n      // Convert to string.\n      if (typeof tones === 'number') {\n        tones = tones.toString();\n      }\n\n      // Check tones.\n      if (!tones || typeof tones !== 'string' || !tones.match(/^[0-9A-DR#*,]+$/i)) {\n        throw new TypeError('Invalid tones: ' + tones);\n      }\n\n      // Check duration.\n      if (duration && !Utils.isDecimal(duration)) {\n        throw new TypeError('Invalid tone duration: ' + duration);\n      } else if (!duration) {\n        duration = RTCSession_DTMF.C.DEFAULT_DURATION;\n      } else if (duration < RTCSession_DTMF.C.MIN_DURATION) {\n        debug('\"duration\" value is lower than the minimum allowed, setting it to ' + RTCSession_DTMF.C.MIN_DURATION + ' milliseconds');\n        duration = RTCSession_DTMF.C.MIN_DURATION;\n      } else if (duration > RTCSession_DTMF.C.MAX_DURATION) {\n        debug('\"duration\" value is greater than the maximum allowed, setting it to ' + RTCSession_DTMF.C.MAX_DURATION + ' milliseconds');\n        duration = RTCSession_DTMF.C.MAX_DURATION;\n      } else {\n        duration = Math.abs(duration);\n      }\n      options.duration = duration;\n\n      // Check interToneGap.\n      if (interToneGap && !Utils.isDecimal(interToneGap)) {\n        throw new TypeError('Invalid interToneGap: ' + interToneGap);\n      } else if (!interToneGap) {\n        interToneGap = RTCSession_DTMF.C.DEFAULT_INTER_TONE_GAP;\n      } else if (interToneGap < RTCSession_DTMF.C.MIN_INTER_TONE_GAP) {\n        debug('\"interToneGap\" value is lower than the minimum allowed, setting it to ' + RTCSession_DTMF.C.MIN_INTER_TONE_GAP + ' milliseconds');\n        interToneGap = RTCSession_DTMF.C.MIN_INTER_TONE_GAP;\n      } else {\n        interToneGap = Math.abs(interToneGap);\n      }\n\n      if (this._tones) {\n        // Tones are already queued, just add to the queue.\n        this._tones += tones;\n\n        return;\n      }\n\n      this._tones = tones;\n\n      // Send the first tone.\n      _sendDTMF.call(this);\n\n      function _sendDTMF() {\n        var _this5 = this;\n\n        var timeout = void 0;\n\n        if (this._status === C.STATUS_TERMINATED || !this._tones || position >= this._tones.length) {\n          // Stop sending DTMF.\n          this._tones = null;\n\n          return;\n        }\n\n        var tone = this._tones[position];\n\n        position += 1;\n\n        if (tone === ',') {\n          timeout = 2000;\n        } else {\n          var dtmf = new RTCSession_DTMF(this);\n\n          options.eventHandlers = {\n            onFailed: function onFailed() {\n              _this5._tones = null;\n            }\n          };\n          dtmf.send(tone, options);\n          timeout = duration + interToneGap;\n        }\n\n        // Set timeout for the next tone.\n        setTimeout(_sendDTMF.bind(this), timeout);\n      }\n    }\n  }, {\n    key: 'sendInfo',\n    value: function sendInfo(contentType, body) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      debug('sendInfo()');\n\n      // Check Session Status.\n      if (this._status !== C.STATUS_CONFIRMED && this._status !== C.STATUS_WAITING_FOR_ACK) {\n        throw new Exceptions.InvalidStateError(this._status);\n      }\n\n      var info = new RTCSession_Info(this);\n\n      info.send(contentType, body, options);\n    }\n\n    /**\n     * Mute\n     */\n\n  }, {\n    key: 'mute',\n    value: function mute() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { audio: true, video: false };\n\n      debug('mute()');\n\n      var audioMuted = false,\n          videoMuted = false;\n\n      if (this._audioMuted === false && options.audio) {\n        audioMuted = true;\n        this._audioMuted = true;\n        this._toogleMuteAudio(true);\n      }\n\n      if (this._videoMuted === false && options.video) {\n        videoMuted = true;\n        this._videoMuted = true;\n        this._toogleMuteVideo(true);\n      }\n\n      if (audioMuted === true || videoMuted === true) {\n        this._onmute({\n          audio: audioMuted,\n          video: videoMuted\n        });\n      }\n    }\n\n    /**\n     * Unmute\n     */\n\n  }, {\n    key: 'unmute',\n    value: function unmute() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { audio: true, video: true };\n\n      debug('unmute()');\n\n      var audioUnMuted = false,\n          videoUnMuted = false;\n\n      if (this._audioMuted === true && options.audio) {\n        audioUnMuted = true;\n        this._audioMuted = false;\n\n        if (this._localHold === false) {\n          this._toogleMuteAudio(false);\n        }\n      }\n\n      if (this._videoMuted === true && options.video) {\n        videoUnMuted = true;\n        this._videoMuted = false;\n\n        if (this._localHold === false) {\n          this._toogleMuteVideo(false);\n        }\n      }\n\n      if (audioUnMuted === true || videoUnMuted === true) {\n        this._onunmute({\n          audio: audioUnMuted,\n          video: videoUnMuted\n        });\n      }\n    }\n\n    /**\n     * Hold\n     */\n\n  }, {\n    key: 'hold',\n    value: function hold() {\n      var _this6 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var done = arguments[1];\n\n      debug('hold()');\n\n      if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n        return false;\n      }\n\n      if (this._localHold === true) {\n        return false;\n      }\n\n      if (!this._isReadyToReOffer()) {\n        return false;\n      }\n\n      this._localHold = true;\n      this._onhold('local');\n\n      var eventHandlers = {\n        succeeded: function succeeded() {\n          if (done) {\n            done();\n          }\n        },\n        failed: function failed() {\n          _this6.terminate({\n            cause: JsSIP_C.causes.WEBRTC_ERROR,\n            status_code: 500,\n            reason_phrase: 'Hold Failed'\n          });\n        }\n      };\n\n      if (options.useUpdate) {\n        this._sendUpdate({\n          sdpOffer: true,\n          eventHandlers: eventHandlers,\n          extraHeaders: options.extraHeaders\n        });\n      } else {\n        this._sendReinvite({\n          eventHandlers: eventHandlers,\n          extraHeaders: options.extraHeaders\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: 'unhold',\n    value: function unhold() {\n      var _this7 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var done = arguments[1];\n\n      debug('unhold()');\n\n      if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n        return false;\n      }\n\n      if (this._localHold === false) {\n        return false;\n      }\n\n      if (!this._isReadyToReOffer()) {\n        return false;\n      }\n\n      this._localHold = false;\n      this._onunhold('local');\n\n      var eventHandlers = {\n        succeeded: function succeeded() {\n          if (done) {\n            done();\n          }\n        },\n        failed: function failed() {\n          _this7.terminate({\n            cause: JsSIP_C.causes.WEBRTC_ERROR,\n            status_code: 500,\n            reason_phrase: 'Unhold Failed'\n          });\n        }\n      };\n\n      if (options.useUpdate) {\n        this._sendUpdate({\n          sdpOffer: true,\n          eventHandlers: eventHandlers,\n          extraHeaders: options.extraHeaders\n        });\n      } else {\n        this._sendReinvite({\n          eventHandlers: eventHandlers,\n          extraHeaders: options.extraHeaders\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: 'renegotiate',\n    value: function renegotiate() {\n      var _this8 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var done = arguments[1];\n\n      debug('renegotiate()');\n\n      var rtcOfferConstraints = options.rtcOfferConstraints || null;\n\n      if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n        return false;\n      }\n\n      if (!this._isReadyToReOffer()) {\n        return false;\n      }\n\n      var eventHandlers = {\n        succeeded: function succeeded() {\n          if (done) {\n            done();\n          }\n        },\n        failed: function failed() {\n          _this8.terminate({\n            cause: JsSIP_C.causes.WEBRTC_ERROR,\n            status_code: 500,\n            reason_phrase: 'Media Renegotiation Failed'\n          });\n        }\n      };\n\n      this._setLocalMediaStatus();\n\n      if (options.useUpdate) {\n        this._sendUpdate({\n          sdpOffer: true,\n          eventHandlers: eventHandlers,\n          rtcOfferConstraints: rtcOfferConstraints,\n          extraHeaders: options.extraHeaders\n        });\n      } else {\n        this._sendReinvite({\n          eventHandlers: eventHandlers,\n          rtcOfferConstraints: rtcOfferConstraints,\n          extraHeaders: options.extraHeaders\n        });\n      }\n\n      return true;\n    }\n\n    /**\n     * Refer\n     */\n\n  }, {\n    key: 'refer',\n    value: function refer(target, options) {\n      var _this9 = this;\n\n      debug('refer()');\n\n      var originalTarget = target;\n\n      if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n        return false;\n      }\n\n      // Check target validity.\n      target = this._ua.normalizeTarget(target);\n      if (!target) {\n        throw new TypeError('Invalid target: ' + originalTarget);\n      }\n\n      var referSubscriber = new RTCSession_ReferSubscriber(this);\n\n      referSubscriber.sendRefer(target, options);\n\n      // Store in the map.\n      var id = referSubscriber.id;\n\n      this._referSubscribers[id] = referSubscriber;\n\n      // Listen for ending events so we can remove it from the map.\n      referSubscriber.on('requestFailed', function () {\n        delete _this9._referSubscribers[id];\n      });\n      referSubscriber.on('accepted', function () {\n        delete _this9._referSubscribers[id];\n      });\n      referSubscriber.on('failed', function () {\n        delete _this9._referSubscribers[id];\n      });\n\n      return referSubscriber;\n    }\n\n    /**\n     * Send a generic in-dialog Request\n     */\n\n  }, {\n    key: 'sendRequest',\n    value: function sendRequest(method, options) {\n      debug('sendRequest()');\n\n      return this._dialog.sendRequest(method, options);\n    }\n\n    /**\n     * In dialog Request Reception\n     */\n\n  }, {\n    key: 'receiveRequest',\n    value: function receiveRequest(request) {\n      var _this10 = this;\n\n      debug('receiveRequest()');\n\n      if (request.method === JsSIP_C.CANCEL) {\n        /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL\n        * was in progress and that the UAC MAY continue with the session established by\n        * any 2xx response, or MAY terminate with BYE. JsSIP does continue with the\n        * established session. So the CANCEL is processed only if the session is not yet\n        * established.\n        */\n\n        /*\n        * Terminate the whole session in case the user didn't accept (or yet send the answer)\n        * nor reject the request opening the session.\n        */\n        if (this._status === C.STATUS_WAITING_FOR_ANSWER || this._status === C.STATUS_ANSWERED) {\n          this._status = C.STATUS_CANCELED;\n          this._request.reply(487);\n          this._failed('remote', request, JsSIP_C.causes.CANCELED);\n        }\n      } else {\n        // Requests arriving here are in-dialog requests.\n        switch (request.method) {\n          case JsSIP_C.ACK:\n            if (this._status !== C.STATUS_WAITING_FOR_ACK) {\n              return;\n            }\n\n            // Update signaling status.\n            this._status = C.STATUS_CONFIRMED;\n\n            clearTimeout(this._timers.ackTimer);\n            clearTimeout(this._timers.invite2xxTimer);\n\n            if (this._late_sdp) {\n              if (!request.body) {\n                this.terminate({\n                  cause: JsSIP_C.causes.MISSING_SDP,\n                  status_code: 400\n                });\n                break;\n              }\n\n              var e = { originator: 'remote', type: 'answer', sdp: request.body };\n\n              debug('emit \"sdp\"');\n              this.emit('sdp', e);\n\n              var answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n              this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n                return _this10._connection.setRemoteDescription(answer);\n              }).then(function () {\n                if (!_this10._is_confirmed) {\n                  _this10._confirmed('remote', request);\n                }\n              }).catch(function (error) {\n                _this10.terminate({\n                  cause: JsSIP_C.causes.BAD_MEDIA_DESCRIPTION,\n                  status_code: 488\n                });\n\n                debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n                _this10.emit('peerconnection:setremotedescriptionfailed', error);\n              });\n            } else if (!this._is_confirmed) {\n              this._confirmed('remote', request);\n            }\n\n            break;\n          case JsSIP_C.BYE:\n            if (this._status === C.STATUS_CONFIRMED) {\n              request.reply(200);\n              this._ended('remote', request, JsSIP_C.causes.BYE);\n            } else if (this._status === C.STATUS_INVITE_RECEIVED) {\n              request.reply(200);\n              this._request.reply(487, 'BYE Received');\n              this._ended('remote', request, JsSIP_C.causes.BYE);\n            } else {\n              request.reply(403, 'Wrong Status');\n            }\n            break;\n          case JsSIP_C.INVITE:\n            if (this._status === C.STATUS_CONFIRMED) {\n              if (request.hasHeader('replaces')) {\n                this._receiveReplaces(request);\n              } else {\n                this._receiveReinvite(request);\n              }\n            } else {\n              request.reply(403, 'Wrong Status');\n            }\n            break;\n          case JsSIP_C.INFO:\n            if (this._status === C.STATUS_1XX_RECEIVED || this._status === C.STATUS_WAITING_FOR_ANSWER || this._status === C.STATUS_ANSWERED || this._status === C.STATUS_WAITING_FOR_ACK || this._status === C.STATUS_CONFIRMED) {\n              var contentType = request.getHeader('content-type');\n\n              if (contentType && contentType.match(/^application\\/dtmf-relay/i)) {\n                new RTCSession_DTMF(this).init_incoming(request);\n              } else if (contentType !== undefined) {\n                new RTCSession_Info(this).init_incoming(request);\n              } else {\n                request.reply(415);\n              }\n            } else {\n              request.reply(403, 'Wrong Status');\n            }\n            break;\n          case JsSIP_C.UPDATE:\n            if (this._status === C.STATUS_CONFIRMED) {\n              this._receiveUpdate(request);\n            } else {\n              request.reply(403, 'Wrong Status');\n            }\n            break;\n          case JsSIP_C.REFER:\n            if (this._status === C.STATUS_CONFIRMED) {\n              this._receiveRefer(request);\n            } else {\n              request.reply(403, 'Wrong Status');\n            }\n            break;\n          case JsSIP_C.NOTIFY:\n            if (this._status === C.STATUS_CONFIRMED) {\n              this._receiveNotify(request);\n            } else {\n              request.reply(403, 'Wrong Status');\n            }\n            break;\n          default:\n            request.reply(501);\n        }\n      }\n    }\n\n    /**\n     * Session Callbacks\n     */\n\n  }, {\n    key: 'onTransportError',\n    value: function onTransportError() {\n      debugerror('onTransportError()');\n\n      if (this._status !== C.STATUS_TERMINATED) {\n        this.terminate({\n          status_code: 500,\n          reason_phrase: JsSIP_C.causes.CONNECTION_ERROR,\n          cause: JsSIP_C.causes.CONNECTION_ERROR\n        });\n      }\n    }\n  }, {\n    key: 'onRequestTimeout',\n    value: function onRequestTimeout() {\n      debugerror('onRequestTimeout()');\n\n      if (this._status !== C.STATUS_TERMINATED) {\n        this.terminate({\n          status_code: 408,\n          reason_phrase: JsSIP_C.causes.REQUEST_TIMEOUT,\n          cause: JsSIP_C.causes.REQUEST_TIMEOUT\n        });\n      }\n    }\n  }, {\n    key: 'onDialogError',\n    value: function onDialogError() {\n      debugerror('onDialogError()');\n\n      if (this._status !== C.STATUS_TERMINATED) {\n        this.terminate({\n          status_code: 500,\n          reason_phrase: JsSIP_C.causes.DIALOG_ERROR,\n          cause: JsSIP_C.causes.DIALOG_ERROR\n        });\n      }\n    }\n\n    // Called from DTMF handler.\n\n  }, {\n    key: 'newDTMF',\n    value: function newDTMF(data) {\n      debug('newDTMF()');\n\n      this.emit('newDTMF', data);\n    }\n\n    // Called from Info handler.\n\n  }, {\n    key: 'newInfo',\n    value: function newInfo(data) {\n      debug('newInfo()');\n\n      this.emit('newInfo', data);\n    }\n\n    /**\n     * Check if RTCSession is ready for an outgoing re-INVITE or UPDATE with SDP.\n     */\n\n  }, {\n    key: '_isReadyToReOffer',\n    value: function _isReadyToReOffer() {\n      if (!this._rtcReady) {\n        debug('_isReadyToReOffer() | internal WebRTC status not ready');\n\n        return false;\n      }\n\n      // No established yet.\n      if (!this._dialog) {\n        debug('_isReadyToReOffer() | session not established yet');\n\n        return false;\n      }\n\n      // Another INVITE transaction is in progress.\n      if (this._dialog.uac_pending_reply === true || this._dialog.uas_pending_reply === true) {\n        debug('_isReadyToReOffer() | there is another INVITE/UPDATE transaction in progress');\n\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: '_close',\n    value: function _close() {\n      debug('close()');\n\n      if (this._status === C.STATUS_TERMINATED) {\n        return;\n      }\n\n      this._status = C.STATUS_TERMINATED;\n\n      // Terminate RTC.\n      if (this._connection) {\n        try {\n          this._connection.close();\n        } catch (error) {\n          debugerror('close() | error closing the RTCPeerConnection: %o', error);\n        }\n      }\n\n      // Close local MediaStream if it was not given by the user.\n      if (this._localMediaStream && this._localMediaStreamLocallyGenerated) {\n        debug('close() | closing local MediaStream');\n\n        Utils.closeMediaStream(this._localMediaStream);\n      }\n\n      // Terminate signaling.\n\n      // Clear SIP timers.\n      for (var timer in this._timers) {\n        if (Object.prototype.hasOwnProperty.call(this._timers, timer)) {\n          clearTimeout(this._timers[timer]);\n        }\n      }\n\n      // Clear Session Timers.\n      clearTimeout(this._sessionTimers.timer);\n\n      // Terminate confirmed dialog.\n      if (this._dialog) {\n        this._dialog.terminate();\n        delete this._dialog;\n      }\n\n      // Terminate early dialogs.\n      for (var dialog in this._earlyDialogs) {\n        if (Object.prototype.hasOwnProperty.call(this._earlyDialogs, dialog)) {\n          this._earlyDialogs[dialog].terminate();\n          delete this._earlyDialogs[dialog];\n        }\n      }\n\n      // Terminate REFER subscribers.\n      for (var subscriber in this._referSubscribers) {\n        if (Object.prototype.hasOwnProperty.call(this._referSubscribers, subscriber)) {\n          delete this._referSubscribers[subscriber];\n        }\n      }\n\n      this._ua.destroyRTCSession(this);\n    }\n\n    /**\n     * Private API.\n     */\n\n    /**\n     * RFC3261 13.3.1.4\n     * Response retransmissions cannot be accomplished by transaction layer\n     *  since it is destroyed when receiving the first 2xx answer\n     */\n\n  }, {\n    key: '_setInvite2xxTimer',\n    value: function _setInvite2xxTimer(request, body) {\n      var timeout = Timers.T1;\n\n      function invite2xxRetransmission() {\n        if (this._status !== C.STATUS_WAITING_FOR_ACK) {\n          return;\n        }\n\n        request.reply(200, null, ['Contact: ' + this._contact], body);\n\n        if (timeout < Timers.T2) {\n          timeout = timeout * 2;\n          if (timeout > Timers.T2) {\n            timeout = Timers.T2;\n          }\n        }\n\n        this._timers.invite2xxTimer = setTimeout(invite2xxRetransmission.bind(this), timeout);\n      }\n\n      this._timers.invite2xxTimer = setTimeout(invite2xxRetransmission.bind(this), timeout);\n    }\n\n    /**\n     * RFC3261 14.2\n     * If a UAS generates a 2xx response and never receives an ACK,\n     *  it SHOULD generate a BYE to terminate the dialog.\n     */\n\n  }, {\n    key: '_setACKTimer',\n    value: function _setACKTimer() {\n      var _this11 = this;\n\n      this._timers.ackTimer = setTimeout(function () {\n        if (_this11._status === C.STATUS_WAITING_FOR_ACK) {\n          debug('no ACK received, terminating the session');\n\n          clearTimeout(_this11._timers.invite2xxTimer);\n          _this11.sendRequest(JsSIP_C.BYE);\n          _this11._ended('remote', null, JsSIP_C.causes.NO_ACK);\n        }\n      }, Timers.TIMER_H);\n    }\n  }, {\n    key: '_createRTCConnection',\n    value: function _createRTCConnection(pcConfig, rtcConstraints) {\n      var _this12 = this;\n\n      this._connection = new RTCPeerConnection(pcConfig, rtcConstraints);\n\n      this._connection.addEventListener('iceconnectionstatechange', function () {\n        var state = _this12._connection.iceConnectionState;\n\n        // TODO: Do more with different states.\n        if (state === 'failed') {\n          _this12.terminate({\n            cause: JsSIP_C.causes.RTP_TIMEOUT,\n            status_code: 408,\n            reason_phrase: JsSIP_C.causes.RTP_TIMEOUT\n          });\n        }\n      });\n\n      debug('emit \"peerconnection\"');\n\n      this.emit('peerconnection', {\n        peerconnection: this._connection\n      });\n    }\n  }, {\n    key: '_createLocalDescription',\n    value: function _createLocalDescription(type, constraints) {\n      var _this13 = this;\n\n      debug('createLocalDescription()');\n\n      if (type !== 'offer' && type !== 'answer') throw new Error('createLocalDescription() | invalid type \"' + type + '\"');\n\n      var connection = this._connection;\n\n      this._rtcReady = false;\n\n      return Promise.resolve()\n      // Create Offer or Answer.\n      .then(function () {\n        if (type === 'offer') {\n          return connection.createOffer(constraints).catch(function (error) {\n            debugerror('emit \"peerconnection:createofferfailed\" [error:%o]', error);\n\n            _this13.emit('peerconnection:createofferfailed', error);\n\n            return Promise.reject(error);\n          });\n        } else {\n          return connection.createAnswer(constraints).catch(function (error) {\n            debugerror('emit \"peerconnection:createanswerfailed\" [error:%o]', error);\n\n            _this13.emit('peerconnection:createanswerfailed', error);\n\n            return Promise.reject(error);\n          });\n        }\n      })\n      // Set local description.\n      .then(function (desc) {\n        return connection.setLocalDescription(desc).catch(function (error) {\n          _this13._rtcReady = true;\n\n          debugerror('emit \"peerconnection:setlocaldescriptionfailed\" [error:%o]', error);\n\n          _this13.emit('peerconnection:setlocaldescriptionfailed', error);\n\n          return Promise.reject(error);\n        });\n      }).then(function () {\n        // Resolve right away if 'pc.iceGatheringState' is 'complete'.\n        if (connection.iceGatheringState === 'complete') {\n          _this13._rtcReady = true;\n\n          var e = { originator: 'local', type: type, sdp: connection.localDescription.sdp };\n\n          debug('emit \"sdp\"');\n\n          _this13.emit('sdp', e);\n\n          return Promise.resolve(e.sdp);\n        }\n\n        // Add 'pc.onicencandidate' event handler to resolve on last candidate.\n        return new Promise(function (resolve) {\n          var finished = false;\n          var listener = void 0;\n\n          var ready = function ready() {\n            connection.removeEventListener('icecandidate', listener);\n\n            finished = true;\n            _this13._rtcReady = true;\n\n            var e = { originator: 'local', type: type, sdp: connection.localDescription.sdp };\n\n            debug('emit \"sdp\"');\n\n            _this13.emit('sdp', e);\n\n            resolve(e.sdp);\n          };\n\n          connection.addEventListener('icecandidate', listener = function listener(event) {\n            var candidate = event.candidate;\n\n            if (candidate) {\n              _this13.emit('icecandidate', {\n                candidate: candidate,\n                ready: ready\n              });\n            } else if (!finished) {\n              ready();\n            }\n          });\n        });\n      });\n    }\n\n    /**\n     * Dialog Management\n     */\n\n  }, {\n    key: '_createDialog',\n    value: function _createDialog(message, type, early) {\n      var local_tag = type === 'UAS' ? message.to_tag : message.from_tag;\n      var remote_tag = type === 'UAS' ? message.from_tag : message.to_tag;\n      var id = message.call_id + local_tag + remote_tag;\n\n      var early_dialog = this._earlyDialogs[id];\n\n      // Early Dialog.\n      if (early) {\n        if (early_dialog) {\n          return true;\n        } else {\n          early_dialog = new Dialog(this, message, type, Dialog.C.STATUS_EARLY);\n\n          // Dialog has been successfully created.\n          if (early_dialog.error) {\n            debug(early_dialog.error);\n            this._failed('remote', message, JsSIP_C.causes.INTERNAL_ERROR);\n\n            return false;\n          } else {\n            this._earlyDialogs[id] = early_dialog;\n\n            return true;\n          }\n        }\n      }\n\n      // Confirmed Dialog.\n      else {\n          this._from_tag = message.from_tag;\n          this._to_tag = message.to_tag;\n\n          // In case the dialog is in _early_ state, update it.\n          if (early_dialog) {\n            early_dialog.update(message, type);\n            this._dialog = early_dialog;\n            delete this._earlyDialogs[id];\n\n            return true;\n          }\n\n          // Otherwise, create a _confirmed_ dialog.\n          var dialog = new Dialog(this, message, type);\n\n          if (dialog.error) {\n            debug(dialog.error);\n            this._failed('remote', message, JsSIP_C.causes.INTERNAL_ERROR);\n\n            return false;\n          } else {\n            this._dialog = dialog;\n\n            return true;\n          }\n        }\n    }\n\n    /**\n     * In dialog INVITE Reception\n     */\n\n  }, {\n    key: '_receiveReinvite',\n    value: function _receiveReinvite(request) {\n      var _this14 = this;\n\n      debug('receiveReinvite()');\n\n      var contentType = request.getHeader('Content-Type');\n      var data = {\n        request: request,\n        callback: undefined,\n        reject: reject.bind(this)\n      };\n\n      var rejected = false;\n\n      function reject() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        rejected = true;\n\n        var status_code = options.status_code || 403;\n        var reason_phrase = options.reason_phrase || '';\n        var extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n        if (this._status !== C.STATUS_CONFIRMED) {\n          return false;\n        }\n\n        if (status_code < 300 || status_code >= 700) {\n          throw new TypeError('Invalid status_code: ' + status_code);\n        }\n\n        request.reply(status_code, reason_phrase, extraHeaders);\n      }\n\n      // Emit 'reinvite'.\n      this.emit('reinvite', data);\n\n      if (rejected) {\n        return;\n      }\n\n      this._late_sdp = false;\n\n      // Request without SDP.\n      if (!request.body) {\n        this._late_sdp = true;\n\n        this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n          return _this14._createLocalDescription('offer', _this14._rtcOfferConstraints);\n        }).then(function (sdp) {\n          sendAnswer.call(_this14, sdp);\n        }).catch(function () {\n          request.reply(500);\n        });\n\n        return;\n      }\n\n      // Request with SDP.\n      if (contentType !== 'application/sdp') {\n        debug('invalid Content-Type');\n        request.reply(415);\n\n        return;\n      }\n\n      this._processInDialogSdpOffer(request)\n      // Send answer.\n      .then(function (desc) {\n        if (_this14._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        sendAnswer.call(_this14, desc);\n      }).catch(function (error) {\n        debugerror(error);\n      });\n\n      function sendAnswer(desc) {\n        var _this15 = this;\n\n        var extraHeaders = ['Contact: ' + this._contact];\n\n        this._handleSessionTimersInIncomingRequest(request, extraHeaders);\n\n        if (this._late_sdp) {\n          desc = this._mangleOffer(desc);\n        }\n\n        request.reply(200, null, extraHeaders, desc, function () {\n          _this15._status = C.STATUS_WAITING_FOR_ACK;\n          _this15._setInvite2xxTimer(request, desc);\n          _this15._setACKTimer();\n        });\n\n        // If callback is given execute it.\n        if (typeof data.callback === 'function') {\n          data.callback();\n        }\n      }\n    }\n\n    /**\n     * In dialog UPDATE Reception\n     */\n\n  }, {\n    key: '_receiveUpdate',\n    value: function _receiveUpdate(request) {\n      var _this16 = this;\n\n      debug('receiveUpdate()');\n\n      var contentType = request.getHeader('Content-Type');\n      var data = {\n        request: request,\n        callback: undefined,\n        reject: reject.bind(this)\n      };\n\n      var rejected = false;\n\n      function reject() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        rejected = true;\n\n        var status_code = options.status_code || 403;\n        var reason_phrase = options.reason_phrase || '';\n        var extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n        if (this._status !== C.STATUS_CONFIRMED) {\n          return false;\n        }\n\n        if (status_code < 300 || status_code >= 700) {\n          throw new TypeError('Invalid status_code: ' + status_code);\n        }\n\n        request.reply(status_code, reason_phrase, extraHeaders);\n      }\n\n      // Emit 'update'.\n      this.emit('update', data);\n\n      if (rejected) {\n        return;\n      }\n\n      if (!request.body) {\n        sendAnswer.call(this, null);\n\n        return;\n      }\n\n      if (contentType !== 'application/sdp') {\n        debug('invalid Content-Type');\n\n        request.reply(415);\n\n        return;\n      }\n\n      this._processInDialogSdpOffer(request)\n      // Send answer.\n      .then(function (desc) {\n        if (_this16._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        sendAnswer.call(_this16, desc);\n      }).catch(function (error) {\n        debugerror(error);\n      });\n\n      function sendAnswer(desc) {\n        var extraHeaders = ['Contact: ' + this._contact];\n\n        this._handleSessionTimersInIncomingRequest(request, extraHeaders);\n\n        request.reply(200, null, extraHeaders, desc);\n\n        // If callback is given execute it.\n        if (typeof data.callback === 'function') {\n          data.callback();\n        }\n      }\n    }\n  }, {\n    key: '_processInDialogSdpOffer',\n    value: function _processInDialogSdpOffer(request) {\n      var _this17 = this;\n\n      debug('_processInDialogSdpOffer()');\n\n      var sdp = request.parseSDP();\n\n      var hold = false;\n\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = sdp.media[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var m = _step4.value;\n\n          if (holdMediaTypes.indexOf(m.type) === -1) {\n            continue;\n          }\n\n          var direction = m.direction || sdp.direction || 'sendrecv';\n\n          if (direction === 'sendonly' || direction === 'inactive') {\n            hold = true;\n          }\n          // If at least one of the streams is active don't emit 'hold'.\n          else {\n              hold = false;\n              break;\n            }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      var e = { originator: 'remote', type: 'offer', sdp: request.body };\n\n      debug('emit \"sdp\"');\n      this.emit('sdp', e);\n\n      var offer = new RTCSessionDescription({ type: 'offer', sdp: e.sdp });\n\n      this._connectionPromiseQueue = this._connectionPromiseQueue\n      // Set remote description.\n      .then(function () {\n        if (_this17._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        return _this17._connection.setRemoteDescription(offer).catch(function (error) {\n          request.reply(488);\n          debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n          _this17.emit('peerconnection:setremotedescriptionfailed', error);\n\n          throw new Error('peerconnection.setRemoteDescription() failed');\n        });\n      }).then(function () {\n        if (_this17._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        if (_this17._remoteHold === true && hold === false) {\n          _this17._remoteHold = false;\n          _this17._onunhold('remote');\n        } else if (_this17._remoteHold === false && hold === true) {\n          _this17._remoteHold = true;\n          _this17._onhold('remote');\n        }\n      })\n      // Create local description.\n      .then(function () {\n        if (_this17._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        return _this17._createLocalDescription('answer', _this17._rtcAnswerConstraints).catch(function () {\n          request.reply(500);\n\n          throw new Error('_createLocalDescription() failed');\n        });\n      });\n\n      return this._connectionPromiseQueue;\n    }\n\n    /**\n     * In dialog Refer Reception\n     */\n\n  }, {\n    key: '_receiveRefer',\n    value: function _receiveRefer(request) {\n      var _this18 = this;\n\n      debug('receiveRefer()');\n\n      if (_typeof(request.refer_to) === undefined) {\n        debug('no Refer-To header field present in REFER');\n        request.reply(400);\n\n        return;\n      }\n\n      if (request.refer_to.uri.scheme !== JsSIP_C.SIP) {\n        debug('Refer-To header field points to a non-SIP URI scheme');\n        request.reply(416);\n\n        return;\n      }\n\n      // Reply before the transaction timer expires.\n      request.reply(202);\n\n      var notifier = new RTCSession_ReferNotifier(this, request.cseq);\n\n      debug('emit \"refer\"');\n\n      // Emit 'refer'.\n      this.emit('refer', {\n        request: request,\n        accept: function accept(initCallback, options) {\n          _accept.call(_this18, initCallback, options);\n        },\n        reject: function reject() {\n          _reject.call(_this18);\n        }\n      });\n\n      function _accept(initCallback) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        initCallback = typeof initCallback === 'function' ? initCallback : null;\n\n        if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n          return false;\n        }\n\n        var session = new RTCSession(this._ua);\n\n        session.on('progress', function (_ref2) {\n          var response = _ref2.response;\n\n          notifier.notify(response.status_code, response.reason_phrase);\n        });\n\n        session.on('accepted', function (_ref3) {\n          var response = _ref3.response;\n\n          notifier.notify(response.status_code, response.reason_phrase);\n        });\n\n        session.on('failed', function (_ref4) {\n          var message = _ref4.message,\n              cause = _ref4.cause;\n\n          if (message) {\n            notifier.notify(message.status_code, message.reason_phrase);\n          } else {\n            notifier.notify(487, cause);\n          }\n        });\n\n        // Consider the Replaces header present in the Refer-To URI.\n        if (request.refer_to.uri.hasHeader('replaces')) {\n          var replaces = decodeURIComponent(request.refer_to.uri.getHeader('replaces'));\n\n          options.extraHeaders = Utils.cloneArray(options.extraHeaders);\n          options.extraHeaders.push('Replaces: ' + replaces);\n        }\n\n        session.connect(request.refer_to.uri.toAor(), options, initCallback);\n      }\n\n      function _reject() {\n        notifier.notify(603);\n      }\n    }\n\n    /**\n     * In dialog Notify Reception\n     */\n\n  }, {\n    key: '_receiveNotify',\n    value: function _receiveNotify(request) {\n      debug('receiveNotify()');\n\n      if (_typeof(request.event) === undefined) {\n        request.reply(400);\n      }\n\n      switch (request.event.event) {\n        case 'refer':\n          {\n            var id = void 0;\n            var referSubscriber = void 0;\n\n            if (request.event.params && request.event.params.id) {\n              id = request.event.params.id;\n              referSubscriber = this._referSubscribers[id];\n            } else if (Object.keys(this._referSubscribers).length === 1) {\n              referSubscriber = this._referSubscribers[Object.keys(this._referSubscribers)[0]];\n            } else {\n              request.reply(400, 'Missing event id parameter');\n\n              return;\n            }\n\n            if (!referSubscriber) {\n              request.reply(481, 'Subscription does not exist');\n\n              return;\n            }\n\n            referSubscriber.receiveNotify(request);\n            request.reply(200);\n\n            break;\n          }\n\n        default:\n          {\n            request.reply(489);\n          }\n      }\n    }\n\n    /**\n     * INVITE with Replaces Reception\n     */\n\n  }, {\n    key: '_receiveReplaces',\n    value: function _receiveReplaces(request) {\n      var _this20 = this;\n\n      debug('receiveReplaces()');\n\n      function _accept2(initCallback) {\n        var _this19 = this;\n\n        if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n          return false;\n        }\n\n        var session = new RTCSession(this._ua);\n\n        // Terminate the current session when the new one is confirmed.\n        session.on('confirmed', function () {\n          _this19.terminate();\n        });\n\n        session.init_incoming(request, initCallback);\n      }\n\n      function _reject2() {\n        debug('Replaced INVITE rejected by the user');\n        request.reply(486);\n      }\n\n      // Emit 'replace'.\n      this.emit('replaces', {\n        request: request,\n        accept: function accept(initCallback) {\n          _accept2.call(_this20, initCallback);\n        },\n        reject: function reject() {\n          _reject2.call(_this20);\n        }\n      });\n    }\n\n    /**\n     * Initial Request Sender\n     */\n\n  }, {\n    key: '_sendInitialRequest',\n    value: function _sendInitialRequest(mediaConstraints, rtcOfferConstraints, mediaStream) {\n      var _this21 = this;\n\n      var request_sender = new RequestSender(this._ua, this._request, {\n        onRequestTimeout: function onRequestTimeout() {\n          _this21.onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          _this21.onTransportError();\n        },\n        // Update the request on authentication.\n        onAuthenticated: function onAuthenticated(request) {\n          _this21._request = request;\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          _this21._receiveInviteResponse(response);\n        }\n      });\n\n      // This Promise is resolved within the next iteration, so the app has now\n      // a chance to set events such as 'peerconnection' and 'connecting'.\n      Promise.resolve()\n      // Get a stream if required.\n      .then(function () {\n        // A stream is given, let the app set events such as 'peerconnection' and 'connecting'.\n        if (mediaStream) {\n          return mediaStream;\n        }\n        // Request for user media access.\n        else if (mediaConstraints.audio || mediaConstraints.video) {\n            _this21._localMediaStreamLocallyGenerated = true;\n\n            return navigator.mediaDevices.getUserMedia(mediaConstraints).catch(function (error) {\n              if (_this21._status === C.STATUS_TERMINATED) {\n                throw new Error('terminated');\n              }\n\n              _this21._failed('local', null, JsSIP_C.causes.USER_DENIED_MEDIA_ACCESS);\n\n              debugerror('emit \"getusermediafailed\" [error:%o]', error);\n\n              _this21.emit('getusermediafailed');\n\n              throw error;\n            });\n          }\n      }).then(function (stream) {\n        if (_this21._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        _this21._localMediaStream = stream;\n\n        if (stream) {\n          _this21._connection.addStream(stream);\n        }\n\n        // TODO: should this be triggered here?\n        _this21._connecting(_this21._request);\n\n        return _this21._createLocalDescription('offer', rtcOfferConstraints).catch(function (error) {\n          _this21._failed('local', null, JsSIP_C.causes.WEBRTC_ERROR);\n\n          throw error;\n        });\n      }).then(function (desc) {\n        if (_this21._is_canceled || _this21._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        _this21._request.body = desc;\n        _this21._status = C.STATUS_INVITE_SENT;\n\n        debug('emit \"sending\" [request:%o]', _this21._request);\n\n        // Emit 'sending' so the app can mangle the body before the request is sent.\n        _this21.emit('sending', {\n          request: _this21._request\n        });\n\n        request_sender.send();\n      }).catch(function (error) {\n        if (_this21._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        debugerror(error);\n      });\n    }\n\n    /**\n     * Reception of Response for Initial INVITE\n     */\n\n  }, {\n    key: '_receiveInviteResponse',\n    value: function _receiveInviteResponse(response) {\n      var _this22 = this;\n\n      debug('receiveInviteResponse()');\n\n      // Handle 2XX retransmissions and responses from forked requests.\n      if (this._dialog && response.status_code >= 200 && response.status_code <= 299) {\n\n        /*\n         * If it is a retransmission from the endpoint that established\n         * the dialog, send an ACK\n         */\n        if (this._dialog.id.call_id === response.call_id && this._dialog.id.local_tag === response.from_tag && this._dialog.id.remote_tag === response.to_tag) {\n          this.sendRequest(JsSIP_C.ACK);\n\n          return;\n        }\n\n        // If not, send an ACK  and terminate.\n        else {\n            var dialog = new Dialog(this, response, 'UAC');\n\n            if (dialog.error !== undefined) {\n              debug(dialog.error);\n\n              return;\n            }\n\n            this.sendRequest(JsSIP_C.ACK);\n            this.sendRequest(JsSIP_C.BYE);\n\n            return;\n          }\n      }\n\n      // Proceed to cancellation if the user requested.\n      if (this._is_canceled) {\n        if (response.status_code >= 100 && response.status_code < 200) {\n          this._request.cancel(this._cancel_reason);\n        } else if (response.status_code >= 200 && response.status_code < 299) {\n          this._acceptAndTerminate(response);\n        }\n\n        return;\n      }\n\n      if (this._status !== C.STATUS_INVITE_SENT && this._status !== C.STATUS_1XX_RECEIVED) {\n        return;\n      }\n\n      switch (true) {\n        case /^100$/.test(response.status_code):\n          this._status = C.STATUS_1XX_RECEIVED;\n          break;\n\n        case /^1[0-9]{2}$/.test(response.status_code):\n          {\n            // Do nothing with 1xx responses without To tag.\n            if (!response.to_tag) {\n              debug('1xx response received without to tag');\n              break;\n            }\n\n            // Create Early Dialog if 1XX comes with contact.\n            if (response.hasHeader('contact')) {\n              // An error on dialog creation will fire 'failed' event.\n              if (!this._createDialog(response, 'UAC', true)) {\n                break;\n              }\n            }\n\n            this._status = C.STATUS_1XX_RECEIVED;\n            this._progress('remote', response);\n\n            if (!response.body) {\n              break;\n            }\n\n            var e = { originator: 'remote', type: 'answer', sdp: response.body };\n\n            debug('emit \"sdp\"');\n            this.emit('sdp', e);\n\n            var answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n            this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n              return _this22._connection.setRemoteDescription(answer);\n            }).catch(function (error) {\n              debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n              _this22.emit('peerconnection:setremotedescriptionfailed', error);\n            });\n            break;\n          }\n\n        case /^2[0-9]{2}$/.test(response.status_code):\n          {\n            this._status = C.STATUS_CONFIRMED;\n\n            if (!response.body) {\n              this._acceptAndTerminate(response, 400, JsSIP_C.causes.MISSING_SDP);\n              this._failed('remote', response, JsSIP_C.causes.BAD_MEDIA_DESCRIPTION);\n              break;\n            }\n\n            // An error on dialog creation will fire 'failed' event.\n            if (!this._createDialog(response, 'UAC')) {\n              break;\n            }\n\n            var _e = { originator: 'remote', type: 'answer', sdp: response.body };\n\n            debug('emit \"sdp\"');\n            this.emit('sdp', _e);\n\n            var _answer = new RTCSessionDescription({ type: 'answer', sdp: _e.sdp });\n\n            this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n              // Be ready for 200 with SDP after a 180/183 with SDP.\n              // We created a SDP 'answer' for it, so check the current signaling state.\n              if (_this22._connection.signalingState === 'stable') {\n                return _this22._connection.createOffer().then(function (offer) {\n                  return _this22._connection.setLocalDescription(offer);\n                }).catch(function (error) {\n                  _this22._acceptAndTerminate(response, 500, error.toString());\n                  _this22._failed('local', response, JsSIP_C.causes.WEBRTC_ERROR);\n                });\n              }\n            }).then(function () {\n              _this22._connection.setRemoteDescription(_answer).then(function () {\n                // Handle Session Timers.\n                _this22._handleSessionTimersInIncomingResponse(response);\n\n                _this22._accepted('remote', response);\n                _this22.sendRequest(JsSIP_C.ACK);\n                _this22._confirmed('local', null);\n              }).catch(function (error) {\n                _this22._acceptAndTerminate(response, 488, 'Not Acceptable Here');\n                _this22._failed('remote', response, JsSIP_C.causes.BAD_MEDIA_DESCRIPTION);\n\n                debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n                _this22.emit('peerconnection:setremotedescriptionfailed', error);\n              });\n            });\n            break;\n          }\n\n        default:\n          {\n            var cause = Utils.sipErrorCause(response.status_code);\n\n            this._failed('remote', response, cause);\n          }\n      }\n    }\n\n    /**\n     * Send Re-INVITE\n     */\n\n  }, {\n    key: '_sendReinvite',\n    value: function _sendReinvite() {\n      var _this23 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      debug('sendReinvite()');\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n      var rtcOfferConstraints = options.rtcOfferConstraints || this._rtcOfferConstraints || null;\n\n      var succeeded = false;\n\n      extraHeaders.push('Contact: ' + this._contact);\n      extraHeaders.push('Content-Type: application/sdp');\n\n      // Session Timers.\n      if (this._sessionTimers.running) {\n        extraHeaders.push('Session-Expires: ' + this._sessionTimers.currentExpires + ';refresher=' + (this._sessionTimers.refresher ? 'uac' : 'uas'));\n      }\n\n      this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n        return _this23._createLocalDescription('offer', rtcOfferConstraints);\n      }).then(function (sdp) {\n        sdp = _this23._mangleOffer(sdp);\n\n        _this23.sendRequest(JsSIP_C.INVITE, {\n          extraHeaders: extraHeaders,\n          body: sdp,\n          eventHandlers: {\n            onSuccessResponse: function onSuccessResponse(response) {\n              onSucceeded.call(_this23, response);\n              succeeded = true;\n            },\n            onErrorResponse: function onErrorResponse(response) {\n              onFailed.call(_this23, response);\n            },\n            onTransportError: function onTransportError() {\n              _this23.onTransportError(); // Do nothing because session ends.\n            },\n            onRequestTimeout: function onRequestTimeout() {\n              _this23.onRequestTimeout(); // Do nothing because session ends.\n            },\n            onDialogError: function onDialogError() {\n              _this23.onDialogError(); // Do nothing because session ends.\n            }\n          }\n        });\n      }).catch(function () {\n        onFailed();\n      });\n\n      function onSucceeded(response) {\n        var _this24 = this;\n\n        if (this._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        this.sendRequest(JsSIP_C.ACK);\n\n        // If it is a 2XX retransmission exit now.\n        if (succeeded) {\n          return;\n        }\n\n        // Handle Session Timers.\n        this._handleSessionTimersInIncomingResponse(response);\n\n        // Must have SDP answer.\n        if (!response.body) {\n          onFailed.call(this);\n\n          return;\n        } else if (response.getHeader('Content-Type') !== 'application/sdp') {\n          onFailed.call(this);\n\n          return;\n        }\n\n        var e = { originator: 'remote', type: 'answer', sdp: response.body };\n\n        debug('emit \"sdp\"');\n        this.emit('sdp', e);\n\n        var answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n        this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n          return _this24._connection.setRemoteDescription(answer);\n        }).then(function () {\n          if (eventHandlers.succeeded) {\n            eventHandlers.succeeded(response);\n          }\n        }).catch(function (error) {\n          onFailed.call(_this24);\n\n          debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n          _this24.emit('peerconnection:setremotedescriptionfailed', error);\n        });\n      }\n\n      function onFailed(response) {\n        if (eventHandlers.failed) {\n          eventHandlers.failed(response);\n        }\n      }\n    }\n\n    /**\n     * Send UPDATE\n     */\n\n  }, {\n    key: '_sendUpdate',\n    value: function _sendUpdate() {\n      var _this25 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      debug('sendUpdate()');\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n      var rtcOfferConstraints = options.rtcOfferConstraints || this._rtcOfferConstraints || null;\n      var sdpOffer = options.sdpOffer || false;\n\n      var succeeded = false;\n\n      extraHeaders.push('Contact: ' + this._contact);\n\n      // Session Timers.\n      if (this._sessionTimers.running) {\n        extraHeaders.push('Session-Expires: ' + this._sessionTimers.currentExpires + ';refresher=' + (this._sessionTimers.refresher ? 'uac' : 'uas'));\n      }\n\n      if (sdpOffer) {\n        extraHeaders.push('Content-Type: application/sdp');\n\n        this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n          return _this25._createLocalDescription('offer', rtcOfferConstraints);\n        }).then(function (sdp) {\n          sdp = _this25._mangleOffer(sdp);\n\n          _this25.sendRequest(JsSIP_C.UPDATE, {\n            extraHeaders: extraHeaders,\n            body: sdp,\n            eventHandlers: {\n              onSuccessResponse: function onSuccessResponse(response) {\n                onSucceeded.call(_this25, response);\n                succeeded = true;\n              },\n              onErrorResponse: function onErrorResponse(response) {\n                onFailed.call(_this25, response);\n              },\n              onTransportError: function onTransportError() {\n                _this25.onTransportError(); // Do nothing because session ends.\n              },\n              onRequestTimeout: function onRequestTimeout() {\n                _this25.onRequestTimeout(); // Do nothing because session ends.\n              },\n              onDialogError: function onDialogError() {\n                _this25.onDialogError(); // Do nothing because session ends.\n              }\n            }\n          });\n        }).catch(function () {\n          onFailed.call(_this25);\n        });\n      }\n\n      // No SDP.\n      else {\n          this.sendRequest(JsSIP_C.UPDATE, {\n            extraHeaders: extraHeaders,\n            eventHandlers: {\n              onSuccessResponse: function onSuccessResponse(response) {\n                onSucceeded.call(_this25, response);\n              },\n              onErrorResponse: function onErrorResponse(response) {\n                onFailed.call(_this25, response);\n              },\n              onTransportError: function onTransportError() {\n                _this25.onTransportError(); // Do nothing because session ends.\n              },\n              onRequestTimeout: function onRequestTimeout() {\n                _this25.onRequestTimeout(); // Do nothing because session ends.\n              },\n              onDialogError: function onDialogError() {\n                _this25.onDialogError(); // Do nothing because session ends.\n              }\n            }\n          });\n        }\n\n      function onSucceeded(response) {\n        var _this26 = this;\n\n        if (this._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        // If it is a 2XX retransmission exit now.\n        if (succeeded) {\n          return;\n        }\n\n        // Handle Session Timers.\n        this._handleSessionTimersInIncomingResponse(response);\n\n        // Must have SDP answer.\n        if (sdpOffer) {\n          if (!response.body) {\n            onFailed.call(this);\n\n            return;\n          } else if (response.getHeader('Content-Type') !== 'application/sdp') {\n            onFailed.call(this);\n\n            return;\n          }\n\n          var e = { originator: 'remote', type: 'answer', sdp: response.body };\n\n          debug('emit \"sdp\"');\n          this.emit('sdp', e);\n\n          var answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n          this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n            return _this26._connection.setRemoteDescription(answer);\n          }).then(function () {\n            if (eventHandlers.succeeded) {\n              eventHandlers.succeeded(response);\n            }\n          }).catch(function (error) {\n            onFailed.call(_this26);\n\n            debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n            _this26.emit('peerconnection:setremotedescriptionfailed', error);\n          });\n        }\n        // No SDP answer.\n        else if (eventHandlers.succeeded) {\n            eventHandlers.succeeded(response);\n          }\n      }\n\n      function onFailed(response) {\n        if (eventHandlers.failed) {\n          eventHandlers.failed(response);\n        }\n      }\n    }\n  }, {\n    key: '_acceptAndTerminate',\n    value: function _acceptAndTerminate(response, status_code, reason_phrase) {\n      debug('acceptAndTerminate()');\n\n      var extraHeaders = [];\n\n      if (status_code) {\n        reason_phrase = reason_phrase || JsSIP_C.REASON_PHRASE[status_code] || '';\n        extraHeaders.push('Reason: SIP ;cause=' + status_code + '; text=\"' + reason_phrase + '\"');\n      }\n\n      // An error on dialog creation will fire 'failed' event.\n      if (this._dialog || this._createDialog(response, 'UAC')) {\n        this.sendRequest(JsSIP_C.ACK);\n        this.sendRequest(JsSIP_C.BYE, {\n          extraHeaders: extraHeaders\n        });\n      }\n\n      // Update session status.\n      this._status = C.STATUS_TERMINATED;\n    }\n\n    /**\n     * Correctly set the SDP direction attributes if the call is on local hold\n     */\n\n  }, {\n    key: '_mangleOffer',\n    value: function _mangleOffer(sdp) {\n\n      if (!this._localHold && !this._remoteHold) {\n        return sdp;\n      }\n\n      sdp = sdp_transform.parse(sdp);\n\n      // Local hold.\n      if (this._localHold && !this._remoteHold) {\n        debug('mangleOffer() | me on hold, mangling offer');\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = sdp.media[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var m = _step5.value;\n\n            if (holdMediaTypes.indexOf(m.type) === -1) {\n              continue;\n            }\n            if (!m.direction) {\n              m.direction = 'sendonly';\n            } else if (m.direction === 'sendrecv') {\n              m.direction = 'sendonly';\n            } else if (m.direction === 'recvonly') {\n              m.direction = 'inactive';\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }\n      // Local and remote hold.\n      else if (this._localHold && this._remoteHold) {\n          debug('mangleOffer() | both on hold, mangling offer');\n          var _iteratorNormalCompletion6 = true;\n          var _didIteratorError6 = false;\n          var _iteratorError6 = undefined;\n\n          try {\n            for (var _iterator6 = sdp.media[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n              var _m = _step6.value;\n\n              if (holdMediaTypes.indexOf(_m.type) === -1) {\n                continue;\n              }\n              _m.direction = 'inactive';\n            }\n          } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                _iterator6.return();\n              }\n            } finally {\n              if (_didIteratorError6) {\n                throw _iteratorError6;\n              }\n            }\n          }\n        }\n        // Remote hold.\n        else if (this._remoteHold) {\n            debug('mangleOffer() | remote on hold, mangling offer');\n            var _iteratorNormalCompletion7 = true;\n            var _didIteratorError7 = false;\n            var _iteratorError7 = undefined;\n\n            try {\n              for (var _iterator7 = sdp.media[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                var _m2 = _step7.value;\n\n                if (holdMediaTypes.indexOf(_m2.type) === -1) {\n                  continue;\n                }\n                if (!_m2.direction) {\n                  _m2.direction = 'recvonly';\n                } else if (_m2.direction === 'sendrecv') {\n                  _m2.direction = 'recvonly';\n                } else if (_m2.direction === 'recvonly') {\n                  _m2.direction = 'inactive';\n                }\n              }\n            } catch (err) {\n              _didIteratorError7 = true;\n              _iteratorError7 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                  _iterator7.return();\n                }\n              } finally {\n                if (_didIteratorError7) {\n                  throw _iteratorError7;\n                }\n              }\n            }\n          }\n\n      return sdp_transform.write(sdp);\n    }\n  }, {\n    key: '_setLocalMediaStatus',\n    value: function _setLocalMediaStatus() {\n      var enableAudio = true,\n          enableVideo = true;\n\n      if (this._localHold || this._remoteHold) {\n        enableAudio = false;\n        enableVideo = false;\n      }\n\n      if (this._audioMuted) {\n        enableAudio = false;\n      }\n\n      if (this._videoMuted) {\n        enableVideo = false;\n      }\n\n      this._toogleMuteAudio(!enableAudio);\n      this._toogleMuteVideo(!enableVideo);\n    }\n\n    /**\n     * Handle SessionTimers for an incoming INVITE or UPDATE.\n     * @param  {IncomingRequest} request\n     * @param  {Array} responseExtraHeaders  Extra headers for the 200 response.\n     */\n\n  }, {\n    key: '_handleSessionTimersInIncomingRequest',\n    value: function _handleSessionTimersInIncomingRequest(request, responseExtraHeaders) {\n      if (!this._sessionTimers.enabled) {\n        return;\n      }\n\n      var session_expires_refresher = void 0;\n\n      if (request.session_expires && request.session_expires >= JsSIP_C.MIN_SESSION_EXPIRES) {\n        this._sessionTimers.currentExpires = request.session_expires;\n        session_expires_refresher = request.session_expires_refresher || 'uas';\n      } else {\n        this._sessionTimers.currentExpires = this._sessionTimers.defaultExpires;\n        session_expires_refresher = 'uas';\n      }\n\n      responseExtraHeaders.push('Session-Expires: ' + this._sessionTimers.currentExpires + ';refresher=' + session_expires_refresher);\n\n      this._sessionTimers.refresher = session_expires_refresher === 'uas';\n      this._runSessionTimer();\n    }\n\n    /**\n     * Handle SessionTimers for an incoming response to INVITE or UPDATE.\n     * @param  {IncomingResponse} response\n     */\n\n  }, {\n    key: '_handleSessionTimersInIncomingResponse',\n    value: function _handleSessionTimersInIncomingResponse(response) {\n      if (!this._sessionTimers.enabled) {\n        return;\n      }\n\n      var session_expires_refresher = void 0;\n\n      if (response.session_expires && response.session_expires >= JsSIP_C.MIN_SESSION_EXPIRES) {\n        this._sessionTimers.currentExpires = response.session_expires;\n        session_expires_refresher = response.session_expires_refresher || 'uac';\n      } else {\n        this._sessionTimers.currentExpires = this._sessionTimers.defaultExpires;\n        session_expires_refresher = 'uac';\n      }\n\n      this._sessionTimers.refresher = session_expires_refresher === 'uac';\n      this._runSessionTimer();\n    }\n  }, {\n    key: '_runSessionTimer',\n    value: function _runSessionTimer() {\n      var _this27 = this;\n\n      var expires = this._sessionTimers.currentExpires;\n\n      this._sessionTimers.running = true;\n\n      clearTimeout(this._sessionTimers.timer);\n\n      // I'm the refresher.\n      if (this._sessionTimers.refresher) {\n        this._sessionTimers.timer = setTimeout(function () {\n          if (_this27._status === C.STATUS_TERMINATED) {\n            return;\n          }\n\n          debug('runSessionTimer() | sending session refresh request');\n\n          if (_this27._sessionTimers.refreshMethod === JsSIP_C.UPDATE) {\n            _this27._sendUpdate();\n          } else {\n            _this27._sendReinvite();\n          }\n        }, expires * 500); // Half the given interval (as the RFC states).\n      }\n\n      // I'm not the refresher.\n      else {\n          this._sessionTimers.timer = setTimeout(function () {\n            if (_this27._status === C.STATUS_TERMINATED) {\n              return;\n            }\n\n            debugerror('runSessionTimer() | timer expired, terminating the session');\n\n            _this27.terminate({\n              cause: JsSIP_C.causes.REQUEST_TIMEOUT,\n              status_code: 408,\n              reason_phrase: 'Session Timer Expired'\n            });\n          }, expires * 1100);\n        }\n    }\n  }, {\n    key: '_toogleMuteAudio',\n    value: function _toogleMuteAudio(mute) {\n      var streams = this._connection.getLocalStreams();\n\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = streams[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var stream = _step8.value;\n\n          var tracks = stream.getAudioTracks();\n\n          var _iteratorNormalCompletion9 = true;\n          var _didIteratorError9 = false;\n          var _iteratorError9 = undefined;\n\n          try {\n            for (var _iterator9 = tracks[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n              var track = _step9.value;\n\n              track.enabled = !mute;\n            }\n          } catch (err) {\n            _didIteratorError9 = true;\n            _iteratorError9 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                _iterator9.return();\n              }\n            } finally {\n              if (_didIteratorError9) {\n                throw _iteratorError9;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n  }, {\n    key: '_toogleMuteVideo',\n    value: function _toogleMuteVideo(mute) {\n      var streams = this._connection.getLocalStreams();\n\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = streams[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var stream = _step10.value;\n\n          var tracks = stream.getVideoTracks();\n\n          var _iteratorNormalCompletion11 = true;\n          var _didIteratorError11 = false;\n          var _iteratorError11 = undefined;\n\n          try {\n            for (var _iterator11 = tracks[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n              var track = _step11.value;\n\n              track.enabled = !mute;\n            }\n          } catch (err) {\n            _didIteratorError11 = true;\n            _iteratorError11 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion11 && _iterator11.return) {\n                _iterator11.return();\n              }\n            } finally {\n              if (_didIteratorError11) {\n                throw _iteratorError11;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n  }, {\n    key: '_newRTCSession',\n    value: function _newRTCSession(originator, request) {\n      debug('newRTCSession()');\n\n      this._ua.newRTCSession(this, {\n        originator: originator,\n        session: this,\n        request: request\n      });\n    }\n  }, {\n    key: '_connecting',\n    value: function _connecting(request) {\n      debug('session connecting');\n\n      debug('emit \"connecting\"');\n\n      this.emit('connecting', {\n        request: request\n      });\n    }\n  }, {\n    key: '_progress',\n    value: function _progress(originator, response) {\n      debug('session progress');\n\n      debug('emit \"progress\"');\n\n      this.emit('progress', {\n        originator: originator,\n        response: response || null\n      });\n    }\n  }, {\n    key: '_accepted',\n    value: function _accepted(originator, message) {\n      debug('session accepted');\n\n      this._start_time = new Date();\n\n      debug('emit \"accepted\"');\n\n      this.emit('accepted', {\n        originator: originator,\n        response: message || null\n      });\n    }\n  }, {\n    key: '_confirmed',\n    value: function _confirmed(originator, ack) {\n      debug('session confirmed');\n\n      this._is_confirmed = true;\n\n      debug('emit \"confirmed\"');\n\n      this.emit('confirmed', {\n        originator: originator,\n        ack: ack || null\n      });\n    }\n  }, {\n    key: '_ended',\n    value: function _ended(originator, message, cause) {\n      debug('session ended');\n\n      this._end_time = new Date();\n\n      this._close();\n\n      debug('emit \"ended\"');\n\n      this.emit('ended', {\n        originator: originator,\n        message: message || null,\n        cause: cause\n      });\n    }\n  }, {\n    key: '_failed',\n    value: function _failed(originator, message, cause) {\n      debug('session failed');\n\n      this._close();\n\n      debug('emit \"failed\"');\n\n      this.emit('failed', {\n        originator: originator,\n        message: message || null,\n        cause: cause\n      });\n    }\n  }, {\n    key: '_onhold',\n    value: function _onhold(originator) {\n      debug('session onhold');\n\n      this._setLocalMediaStatus();\n\n      debug('emit \"hold\"');\n\n      this.emit('hold', {\n        originator: originator\n      });\n    }\n  }, {\n    key: '_onunhold',\n    value: function _onunhold(originator) {\n      debug('session onunhold');\n\n      this._setLocalMediaStatus();\n\n      debug('emit \"unhold\"');\n\n      this.emit('unhold', {\n        originator: originator\n      });\n    }\n  }, {\n    key: '_onmute',\n    value: function _onmute(_ref5) {\n      var audio = _ref5.audio,\n          video = _ref5.video;\n\n      debug('session onmute');\n\n      this._setLocalMediaStatus();\n\n      debug('emit \"muted\"');\n\n      this.emit('muted', {\n        audio: audio,\n        video: video\n      });\n    }\n  }, {\n    key: '_onunmute',\n    value: function _onunmute(_ref6) {\n      var audio = _ref6.audio,\n          video = _ref6.video;\n\n      debug('session onunmute');\n\n      this._setLocalMediaStatus();\n\n      debug('emit \"unmuted\"');\n\n      this.emit('unmuted', {\n        audio: audio,\n        video: video\n      });\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n\n    // Expose session failed/ended causes as a property of the RTCSession instance.\n\n  }, {\n    key: 'causes',\n    get: function get() {\n      return JsSIP_C.causes;\n    }\n  }, {\n    key: 'id',\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: 'connection',\n    get: function get() {\n      return this._connection;\n    }\n  }, {\n    key: 'contact',\n    get: function get() {\n      return this._contact;\n    }\n  }, {\n    key: 'direction',\n    get: function get() {\n      return this._direction;\n    }\n  }, {\n    key: 'local_identity',\n    get: function get() {\n      return this._local_identity;\n    }\n  }, {\n    key: 'remote_identity',\n    get: function get() {\n      return this._remote_identity;\n    }\n  }, {\n    key: 'start_time',\n    get: function get() {\n      return this._start_time;\n    }\n  }, {\n    key: 'end_time',\n    get: function get() {\n      return this._end_time;\n    }\n  }, {\n    key: 'data',\n    get: function get() {\n      return this._data;\n    },\n    set: function set(_data) {\n      this._data = _data;\n    }\n  }, {\n    key: 'status',\n    get: function get() {\n      return this._status;\n    }\n  }]);\n\n  return RTCSession;\n}(EventEmitter);\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/RTCSession.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/RTCSession/DTMF.js":
/*!*******************************************************!*\
  !*** ./node_modules/jssip/lib-es5/RTCSession/DTMF.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar JsSIP_C = __webpack_require__(/*! ../Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar Exceptions = __webpack_require__(/*! ../Exceptions */ \"./node_modules/jssip/lib-es5/Exceptions.js\");\nvar Utils = __webpack_require__(/*! ../Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:RTCSession:DTMF');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:ERROR:RTCSession:DTMF');\n\ndebugerror.log = console.warn.bind(console);\n\nvar C = {\n  MIN_DURATION: 70,\n  MAX_DURATION: 6000,\n  DEFAULT_DURATION: 100,\n  MIN_INTER_TONE_GAP: 50,\n  DEFAULT_INTER_TONE_GAP: 500\n};\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(DTMF, _EventEmitter);\n\n  function DTMF(session) {\n    _classCallCheck(this, DTMF);\n\n    var _this = _possibleConstructorReturn(this, (DTMF.__proto__ || Object.getPrototypeOf(DTMF)).call(this));\n\n    _this._session = session;\n    _this._direction = null;\n    _this._tone = null;\n    _this._duration = null;\n    _this._request = null;\n    return _this;\n  }\n\n  _createClass(DTMF, [{\n    key: 'send',\n    value: function send(tone) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (tone === undefined) {\n        throw new TypeError('Not enough arguments');\n      }\n\n      this._direction = 'outgoing';\n\n      // Check RTCSession Status.\n      if (this._session.status !== this._session.C.STATUS_CONFIRMED && this._session.status !== this._session.C.STATUS_WAITING_FOR_ACK) {\n        throw new Exceptions.InvalidStateError(this._session.status);\n      }\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n      this.eventHandlers = options.eventHandlers || {};\n\n      // Check tone type.\n      if (typeof tone === 'string') {\n        tone = tone.toUpperCase();\n      } else if (typeof tone === 'number') {\n        tone = tone.toString();\n      } else {\n        throw new TypeError('Invalid tone: ' + tone);\n      }\n\n      // Check tone value.\n      if (!tone.match(/^[0-9A-DR#*]$/)) {\n        throw new TypeError('Invalid tone: ' + tone);\n      } else {\n        this._tone = tone;\n      }\n\n      // Duration is checked/corrected in RTCSession.\n      this._duration = options.duration;\n\n      extraHeaders.push('Content-Type: application/dtmf-relay');\n\n      var body = 'Signal=' + this._tone + '\\r\\n';\n\n      body += 'Duration=' + this._duration;\n\n      this._session.newDTMF({\n        originator: 'local',\n        dtmf: this,\n        request: this._request\n      });\n\n      this._session.sendRequest(JsSIP_C.INFO, {\n        extraHeaders: extraHeaders,\n        eventHandlers: {\n          onSuccessResponse: function onSuccessResponse(response) {\n            _this2.emit('succeeded', {\n              originator: 'remote',\n              response: response\n            });\n          },\n          onErrorResponse: function onErrorResponse(response) {\n            if (_this2.eventHandlers.onFailed) {\n              _this2.eventHandlers.onFailed();\n            }\n\n            _this2.emit('failed', {\n              originator: 'remote',\n              response: response\n            });\n          },\n          onRequestTimeout: function onRequestTimeout() {\n            _this2._session.onRequestTimeout();\n          },\n          onTransportError: function onTransportError() {\n            _this2._session.onTransportError();\n          },\n          onDialogError: function onDialogError() {\n            _this2._session.onDialogError();\n          }\n        },\n        body: body\n      });\n    }\n  }, {\n    key: 'init_incoming',\n    value: function init_incoming(request) {\n      var reg_tone = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/;\n      var reg_duration = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n\n      this._direction = 'incoming';\n      this._request = request;\n\n      request.reply(200);\n\n      if (request.body) {\n        var body = request.body.split('\\n');\n\n        if (body.length >= 1) {\n          if (reg_tone.test(body[0])) {\n            this._tone = body[0].replace(reg_tone, '$2');\n          }\n        }\n        if (body.length >= 2) {\n          if (reg_duration.test(body[1])) {\n            this._duration = parseInt(body[1].replace(reg_duration, '$2'), 10);\n          }\n        }\n      }\n\n      if (!this._duration) {\n        this._duration = C.DEFAULT_DURATION;\n      }\n\n      if (!this._tone) {\n        debug('invalid INFO DTMF received, discarded');\n      } else {\n        this._session.newDTMF({\n          originator: 'remote',\n          dtmf: this,\n          request: request\n        });\n      }\n    }\n  }, {\n    key: 'tone',\n    get: function get() {\n      return this._tone;\n    }\n  }, {\n    key: 'duration',\n    get: function get() {\n      return this._duration;\n    }\n  }]);\n\n  return DTMF;\n}(EventEmitter);\n\n/**\n * Expose C object.\n */\nmodule.exports.C = C;\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/RTCSession/DTMF.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/RTCSession/Info.js":
/*!*******************************************************!*\
  !*** ./node_modules/jssip/lib-es5/RTCSession/Info.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:ERROR:RTCSession:Info');\n\ndebugerror.log = console.warn.bind(console);\nvar JsSIP_C = __webpack_require__(/*! ../Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar Exceptions = __webpack_require__(/*! ../Exceptions */ \"./node_modules/jssip/lib-es5/Exceptions.js\");\nvar Utils = __webpack_require__(/*! ../Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(Info, _EventEmitter);\n\n  function Info(session) {\n    _classCallCheck(this, Info);\n\n    var _this = _possibleConstructorReturn(this, (Info.__proto__ || Object.getPrototypeOf(Info)).call(this));\n\n    _this._session = session;\n    _this._direction = null;\n    _this._contentType = null;\n    _this._body = null;\n    return _this;\n  }\n\n  _createClass(Info, [{\n    key: 'send',\n    value: function send(contentType, body) {\n      var _this2 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      this._direction = 'outgoing';\n\n      if (contentType === undefined) {\n        throw new TypeError('Not enough arguments');\n      }\n\n      // Check RTCSession Status.\n      if (this._session.status !== this._session.C.STATUS_CONFIRMED && this._session.status !== this._session.C.STATUS_WAITING_FOR_ACK) {\n        throw new Exceptions.InvalidStateError(this._session.status);\n      }\n\n      this._contentType = contentType;\n      this._body = body;\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n      extraHeaders.push('Content-Type: ' + contentType);\n\n      this._session.newInfo({\n        originator: 'local',\n        info: this,\n        request: this.request\n      });\n\n      this._session.sendRequest(JsSIP_C.INFO, {\n        extraHeaders: extraHeaders,\n        eventHandlers: {\n          onSuccessResponse: function onSuccessResponse(response) {\n            _this2.emit('succeeded', {\n              originator: 'remote',\n              response: response\n            });\n          },\n          onErrorResponse: function onErrorResponse(response) {\n            _this2.emit('failed', {\n              originator: 'remote',\n              response: response\n            });\n          },\n          onTransportError: function onTransportError() {\n            _this2._session.onTransportError();\n          },\n          onRequestTimeout: function onRequestTimeout() {\n            _this2._session.onRequestTimeout();\n          },\n          onDialogError: function onDialogError() {\n            _this2._session.onDialogError();\n          }\n        },\n        body: body\n      });\n    }\n  }, {\n    key: 'init_incoming',\n    value: function init_incoming(request) {\n      this._direction = 'incoming';\n      this.request = request;\n\n      request.reply(200);\n\n      this._contentType = request.getHeader('content-type');\n      this._body = request.body;\n\n      this._session.newInfo({\n        originator: 'remote',\n        info: this,\n        request: request\n      });\n    }\n  }, {\n    key: 'contentType',\n    get: function get() {\n      return this._contentType;\n    }\n  }, {\n    key: 'body',\n    get: function get() {\n      return this._body;\n    }\n  }]);\n\n  return Info;\n}(EventEmitter);\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/RTCSession/Info.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/RTCSession/ReferNotifier.js":
/*!****************************************************************!*\
  !*** ./node_modules/jssip/lib-es5/RTCSession/ReferNotifier.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar JsSIP_C = __webpack_require__(/*! ../Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:RTCSession:ReferNotifier');\n\nvar C = {\n  event_type: 'refer',\n  body_type: 'message/sipfrag;version=2.0',\n  expires: 300\n};\n\nmodule.exports = function () {\n  function ReferNotifier(session, id, expires) {\n    _classCallCheck(this, ReferNotifier);\n\n    this._session = session;\n    this._id = id;\n    this._expires = expires || C.expires;\n    this._active = true;\n\n    // The creation of a Notifier results in an immediate NOTIFY.\n    this.notify(100);\n  }\n\n  _createClass(ReferNotifier, [{\n    key: 'notify',\n    value: function notify(code, reason) {\n      debug('notify()');\n\n      if (this._active === false) {\n        return;\n      }\n\n      reason = reason || JsSIP_C.REASON_PHRASE[code] || '';\n\n      var state = void 0;\n\n      if (code >= 200) {\n        state = 'terminated;reason=noresource';\n      } else {\n        state = 'active;expires=' + this._expires;\n      }\n\n      // Put this in a try/catch block.\n      this._session.sendRequest(JsSIP_C.NOTIFY, {\n        extraHeaders: ['Event: ' + C.event_type + ';id=' + this._id, 'Subscription-State: ' + state, 'Content-Type: ' + C.body_type],\n        body: 'SIP/2.0 ' + code + ' ' + reason,\n        eventHandlers: {\n          // If a negative response is received, subscription is canceled.\n          onErrorResponse: function onErrorResponse() {\n            this._active = false;\n          }\n        }\n      });\n    }\n  }]);\n\n  return ReferNotifier;\n}();\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/RTCSession/ReferNotifier.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/RTCSession/ReferSubscriber.js":
/*!******************************************************************!*\
  !*** ./node_modules/jssip/lib-es5/RTCSession/ReferSubscriber.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar JsSIP_C = __webpack_require__(/*! ../Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar Grammar = __webpack_require__(/*! ../Grammar */ \"./node_modules/jssip/lib-es5/Grammar.js\");\nvar Utils = __webpack_require__(/*! ../Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:RTCSession:ReferSubscriber');\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(ReferSubscriber, _EventEmitter);\n\n  function ReferSubscriber(session) {\n    _classCallCheck(this, ReferSubscriber);\n\n    var _this = _possibleConstructorReturn(this, (ReferSubscriber.__proto__ || Object.getPrototypeOf(ReferSubscriber)).call(this));\n\n    _this._id = null;\n    _this._session = session;\n    return _this;\n  }\n\n  _createClass(ReferSubscriber, [{\n    key: 'sendRefer',\n    value: function sendRefer(target) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      debug('sendRefer()');\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n\n      // Set event handlers.\n      for (var event in eventHandlers) {\n        if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {\n          this.on(event, eventHandlers[event]);\n        }\n      }\n\n      // Replaces URI header field.\n      var replaces = null;\n\n      if (options.replaces) {\n        replaces = options.replaces._request.call_id;\n        replaces += ';to-tag=' + options.replaces._to_tag;\n        replaces += ';from-tag=' + options.replaces._from_tag;\n\n        replaces = encodeURIComponent(replaces);\n      }\n\n      // Refer-To header field.\n      var referTo = 'Refer-To: <' + target + (replaces ? '?Replaces=' + replaces : '') + '>';\n\n      extraHeaders.push(referTo);\n\n      extraHeaders.push('Contact: ' + this._session.contact);\n\n      var request = this._session.sendRequest(JsSIP_C.REFER, {\n        extraHeaders: extraHeaders,\n        eventHandlers: {\n          onSuccessResponse: function onSuccessResponse(response) {\n            _this2._requestSucceeded(response);\n          },\n          onErrorResponse: function onErrorResponse(response) {\n            _this2._requestFailed(response, JsSIP_C.causes.REJECTED);\n          },\n          onTransportError: function onTransportError() {\n            _this2._requestFailed(null, JsSIP_C.causes.CONNECTION_ERROR);\n          },\n          onRequestTimeout: function onRequestTimeout() {\n            _this2._requestFailed(null, JsSIP_C.causes.REQUEST_TIMEOUT);\n          },\n          onDialogError: function onDialogError() {\n            _this2._requestFailed(null, JsSIP_C.causes.DIALOG_ERROR);\n          }\n        }\n      });\n\n      this._id = request.cseq;\n    }\n  }, {\n    key: 'receiveNotify',\n    value: function receiveNotify(request) {\n      debug('receiveNotify()');\n\n      if (!request.body) {\n        return;\n      }\n\n      var status_line = Grammar.parse(request.body.trim(), 'Status_Line');\n\n      if (status_line === -1) {\n        debug('receiveNotify() | error parsing NOTIFY body: \"' + request.body + '\"');\n\n        return;\n      }\n\n      switch (true) {\n        case /^100$/.test(status_line.status_code):\n          this.emit('trying', {\n            request: request,\n            status_line: status_line\n          });\n          break;\n\n        case /^1[0-9]{2}$/.test(status_line.status_code):\n          this.emit('progress', {\n            request: request,\n            status_line: status_line\n          });\n          break;\n\n        case /^2[0-9]{2}$/.test(status_line.status_code):\n          this.emit('accepted', {\n            request: request,\n            status_line: status_line\n          });\n          break;\n\n        default:\n          this.emit('failed', {\n            request: request,\n            status_line: status_line\n          });\n          break;\n      }\n    }\n  }, {\n    key: '_requestSucceeded',\n    value: function _requestSucceeded(response) {\n      debug('REFER succeeded');\n\n      debug('emit \"requestSucceeded\"');\n\n      this.emit('requestSucceeded', {\n        response: response\n      });\n    }\n  }, {\n    key: '_requestFailed',\n    value: function _requestFailed(response, cause) {\n      debug('REFER failed');\n\n      debug('emit \"requestFailed\"');\n\n      this.emit('requestFailed', {\n        response: response || null,\n        cause: cause\n      });\n    }\n  }, {\n    key: 'id',\n    get: function get() {\n      return this._id;\n    }\n  }]);\n\n  return ReferSubscriber;\n}(EventEmitter);\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/RTCSession/ReferSubscriber.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Registrator.js":
/*!***************************************************!*\
  !*** ./node_modules/jssip/lib-es5/Registrator.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib-es5/SIPMessage.js\");\nvar RequestSender = __webpack_require__(/*! ./RequestSender */ \"./node_modules/jssip/lib-es5/RequestSender.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:Registrator');\n\nvar MIN_REGISTER_EXPIRES = 10; // In seconds.\n\nmodule.exports = function () {\n  function Registrator(ua, transport) {\n    _classCallCheck(this, Registrator);\n\n    var reg_id = 1; // Force reg_id to 1.\n\n    this._ua = ua;\n    this._transport = transport;\n\n    this._registrar = ua.configuration.registrar_server;\n    this._expires = ua.configuration.register_expires;\n\n    // Call-ID and CSeq values RFC3261 10.2.\n    this._call_id = Utils.createRandomToken(22);\n    this._cseq = 0;\n\n    this._to_uri = ua.configuration.uri;\n\n    this._registrationTimer = null;\n\n    // Ongoing Register request.\n    this._registering = false;\n\n    // Set status.\n    this._registered = false;\n\n    // Contact header.\n    this._contact = this._ua.contact.toString();\n\n    // Sip.ice media feature tag (RFC 5768).\n    this._contact += ';+sip.ice';\n\n    // Custom headers for REGISTER and un-REGISTER.\n    this._extraHeaders = [];\n\n    // Custom Contact header params for REGISTER and un-REGISTER.\n    this._extraContactParams = '';\n\n    if (reg_id) {\n      this._contact += ';reg-id=' + reg_id;\n      this._contact += ';+sip.instance=\"<urn:uuid:' + this._ua.configuration.instance_id + '>\"';\n    }\n  }\n\n  _createClass(Registrator, [{\n    key: 'setExtraHeaders',\n    value: function setExtraHeaders(extraHeaders) {\n      if (!Array.isArray(extraHeaders)) {\n        extraHeaders = [];\n      }\n\n      this._extraHeaders = extraHeaders.slice();\n    }\n  }, {\n    key: 'setExtraContactParams',\n    value: function setExtraContactParams(extraContactParams) {\n      if (!(extraContactParams instanceof Object)) {\n        extraContactParams = {};\n      }\n\n      // Reset it.\n      this._extraContactParams = '';\n\n      for (var param_key in extraContactParams) {\n        if (Object.prototype.hasOwnProperty.call(extraContactParams, param_key)) {\n          var param_value = extraContactParams[param_key];\n\n          this._extraContactParams += ';' + param_key;\n          if (param_value) {\n            this._extraContactParams += '=' + param_value;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'register',\n    value: function register() {\n      var _this = this;\n\n      if (this._registering) {\n        debug('Register request in progress...');\n\n        return;\n      }\n\n      var extraHeaders = this._extraHeaders.slice();\n\n      extraHeaders.push('Contact: ' + this._contact + ';expires=' + this._expires + this._extraContactParams);\n      extraHeaders.push('Expires: ' + this._expires);\n\n      var request = new SIPMessage.OutgoingRequest(JsSIP_C.REGISTER, this._registrar, this._ua, {\n        'to_uri': this._to_uri,\n        'call_id': this._call_id,\n        'cseq': this._cseq += 1\n      }, extraHeaders);\n\n      var request_sender = new RequestSender(this._ua, request, {\n        onRequestTimeout: function onRequestTimeout() {\n          _this._registrationFailure(null, JsSIP_C.causes.REQUEST_TIMEOUT);\n        },\n        onTransportError: function onTransportError() {\n          _this._registrationFailure(null, JsSIP_C.causes.CONNECTION_ERROR);\n        },\n        // Increase the CSeq on authentication.\n        onAuthenticated: function onAuthenticated() {\n          _this._cseq += 1;\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          var contact = void 0;\n          var expires = void 0;\n          var numContacts = response.getHeaders('contact').length;\n\n          // Discard responses to older REGISTER/un-REGISTER requests.\n          if (response.cseq !== _this._cseq) {\n            return;\n          }\n\n          // Clear registration timer.\n          if (_this._registrationTimer !== null) {\n            clearTimeout(_this._registrationTimer);\n            _this._registrationTimer = null;\n          }\n\n          switch (true) {\n            case /^1[0-9]{2}$/.test(response.status_code):\n              // Ignore provisional responses.\n              break;\n            case /^2[0-9]{2}$/.test(response.status_code):\n              _this._registering = false;\n\n              // Search the Contact pointing to us and update the expires value accordingly.\n              if (!numContacts) {\n                debug('no Contact header in response to REGISTER, response ignored');\n                break;\n              }\n\n              while (numContacts--) {\n                contact = response.parseHeader('contact', numContacts);\n\n                if (contact.uri.user === _this._ua.contact.uri.user) {\n                  expires = contact.getParam('expires');\n                  break;\n                } else {\n                  contact = null;\n                }\n              }\n\n              if (!contact) {\n                debug('no Contact header pointing to us, response ignored');\n                break;\n              }\n\n              if (!expires && response.hasHeader('expires')) {\n                expires = response.getHeader('expires');\n              }\n\n              if (!expires) {\n                expires = _this._expires;\n              }\n\n              expires = Number(expires);\n\n              if (expires < MIN_REGISTER_EXPIRES) expires = MIN_REGISTER_EXPIRES;\n\n              // Re-Register or emit an event before the expiration interval has elapsed.\n              // For that, decrease the expires value. ie: 3 seconds.\n              _this._registrationTimer = setTimeout(function () {\n                _this._registrationTimer = null;\n                // If there are no listeners for registrationExpiring, renew registration.\n                // If there are listeners, let the function listening do the register call.\n                if (_this._ua.listeners('registrationExpiring').length === 0) {\n                  _this.register();\n                } else {\n                  _this._ua.emit('registrationExpiring');\n                }\n              }, expires * 1000 - 5000);\n\n              // Save gruu values.\n              if (contact.hasParam('temp-gruu')) {\n                _this._ua.contact.temp_gruu = contact.getParam('temp-gruu').replace(/\"/g, '');\n              }\n              if (contact.hasParam('pub-gruu')) {\n                _this._ua.contact.pub_gruu = contact.getParam('pub-gruu').replace(/\"/g, '');\n              }\n\n              if (!_this._registered) {\n                _this._registered = true;\n                _this._ua.registered({\n                  response: response\n                });\n              }\n              break;\n            // Interval too brief RFC3261 10.2.8.\n            case /^423$/.test(response.status_code):\n              if (response.hasHeader('min-expires')) {\n                // Increase our registration interval to the suggested minimum.\n                _this._expires = Number(response.getHeader('min-expires'));\n\n                if (_this._expires < MIN_REGISTER_EXPIRES) _this._expires = MIN_REGISTER_EXPIRES;\n\n                // Attempt the registration again immediately.\n                _this.register();\n              } else {\n                // This response MUST contain a Min-Expires header field\n                debug('423 response received for REGISTER without Min-Expires');\n                _this._registrationFailure(response, JsSIP_C.causes.SIP_FAILURE_CODE);\n              }\n              break;\n            default:\n              {\n                var cause = Utils.sipErrorCause(response.status_code);\n\n                _this._registrationFailure(response, cause);\n              }\n          }\n        }\n      });\n\n      this._registering = true;\n      request_sender.send();\n    }\n  }, {\n    key: 'unregister',\n    value: function unregister() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this._registered) {\n        debug('already unregistered');\n\n        return;\n      }\n\n      this._registered = false;\n\n      // Clear the registration timer.\n      if (this._registrationTimer !== null) {\n        clearTimeout(this._registrationTimer);\n        this._registrationTimer = null;\n      }\n\n      var extraHeaders = this._extraHeaders.slice();\n\n      if (options.all) {\n        extraHeaders.push('Contact: *' + this._extraContactParams);\n      } else {\n        extraHeaders.push('Contact: ' + this._contact + ';expires=0' + this._extraContactParams);\n      }\n\n      extraHeaders.push('Expires: 0');\n\n      var request = new SIPMessage.OutgoingRequest(JsSIP_C.REGISTER, this._registrar, this._ua, {\n        'to_uri': this._to_uri,\n        'call_id': this._call_id,\n        'cseq': this._cseq += 1\n      }, extraHeaders);\n\n      var request_sender = new RequestSender(this._ua, request, {\n        onRequestTimeout: function onRequestTimeout() {\n          _this2._unregistered(null, JsSIP_C.causes.REQUEST_TIMEOUT);\n        },\n        onTransportError: function onTransportError() {\n          _this2._unregistered(null, JsSIP_C.causes.CONNECTION_ERROR);\n        },\n        // Increase the CSeq on authentication.\n        onAuthenticated: function onAuthenticated() {\n          _this2._cseq += 1;\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          switch (true) {\n            case /^1[0-9]{2}$/.test(response.status_code):\n              // Ignore provisional responses.\n              break;\n            case /^2[0-9]{2}$/.test(response.status_code):\n              _this2._unregistered(response);\n              break;\n            default:\n              {\n                var cause = Utils.sipErrorCause(response.status_code);\n\n                _this2._unregistered(response, cause);\n              }\n          }\n        }\n      });\n\n      request_sender.send();\n    }\n  }, {\n    key: 'close',\n    value: function close() {\n      if (this._registered) {\n        this.unregister();\n      }\n    }\n  }, {\n    key: 'onTransportClosed',\n    value: function onTransportClosed() {\n      this._registering = false;\n      if (this._registrationTimer !== null) {\n        clearTimeout(this._registrationTimer);\n        this._registrationTimer = null;\n      }\n\n      if (this._registered) {\n        this._registered = false;\n        this._ua.unregistered({});\n      }\n    }\n  }, {\n    key: '_registrationFailure',\n    value: function _registrationFailure(response, cause) {\n      this._registering = false;\n      this._ua.registrationFailed({\n        response: response || null,\n        cause: cause\n      });\n\n      if (this._registered) {\n        this._registered = false;\n        this._ua.unregistered({\n          response: response || null,\n          cause: cause\n        });\n      }\n    }\n  }, {\n    key: '_unregistered',\n    value: function _unregistered(response, cause) {\n      this._registering = false;\n      this._registered = false;\n      this._ua.unregistered({\n        response: response || null,\n        cause: cause || null\n      });\n    }\n  }, {\n    key: 'registered',\n    get: function get() {\n      return this._registered;\n    }\n  }]);\n\n  return Registrator;\n}();\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Registrator.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/RequestSender.js":
/*!*****************************************************!*\
  !*** ./node_modules/jssip/lib-es5/RequestSender.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar DigestAuthentication = __webpack_require__(/*! ./DigestAuthentication */ \"./node_modules/jssip/lib-es5/DigestAuthentication.js\");\nvar Transactions = __webpack_require__(/*! ./Transactions */ \"./node_modules/jssip/lib-es5/Transactions.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:RequestSender');\n\n// Default event handlers.\nvar EventHandlers = {\n  onRequestTimeout: function onRequestTimeout() {},\n  onTransportError: function onTransportError() {},\n  onReceiveResponse: function onReceiveResponse() {},\n  onAuthenticated: function onAuthenticated() {}\n};\n\nmodule.exports = function () {\n  function RequestSender(ua, request, eventHandlers) {\n    _classCallCheck(this, RequestSender);\n\n    this._ua = ua;\n    this._eventHandlers = eventHandlers;\n    this._method = request.method;\n    this._request = request;\n    this._auth = null;\n    this._challenged = false;\n    this._staled = false;\n\n    // Define the undefined handlers.\n    for (var handler in EventHandlers) {\n      if (Object.prototype.hasOwnProperty.call(EventHandlers, handler)) {\n        if (!this._eventHandlers[handler]) {\n          this._eventHandlers[handler] = EventHandlers[handler];\n        }\n      }\n    }\n\n    // If ua is in closing process or even closed just allow sending Bye and ACK.\n    if (ua.status === ua.C.STATUS_USER_CLOSED && (this._method !== JsSIP_C.BYE || this._method !== JsSIP_C.ACK)) {\n      this._eventHandlers.onTransportError();\n    }\n  }\n\n  /**\n  * Create the client transaction and send the message.\n  */\n\n  _createClass(RequestSender, [{\n    key: 'send',\n    value: function send() {\n      var _this = this;\n\n      var eventHandlers = {\n        onRequestTimeout: function onRequestTimeout() {\n          _this._eventHandlers.onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          _this._eventHandlers.onTransportError();\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          _this._receiveResponse(response);\n        }\n      };\n\n      switch (this._method) {\n        case 'INVITE':\n          this.clientTransaction = new Transactions.InviteClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n          break;\n        case 'ACK':\n          this.clientTransaction = new Transactions.AckClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n          break;\n        default:\n          this.clientTransaction = new Transactions.NonInviteClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n      }\n\n      this.clientTransaction.send();\n    }\n\n    /**\n    * Called from client transaction when receiving a correct response to the request.\n    * Authenticate request if needed or pass the response back to the applicant.\n    */\n\n  }, {\n    key: '_receiveResponse',\n    value: function _receiveResponse(response) {\n      var challenge = void 0;\n      var authorization_header_name = void 0;\n      var status_code = response.status_code;\n\n      /*\n      * Authentication\n      * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n      */\n      if ((status_code === 401 || status_code === 407) && (this._ua.configuration.password !== null || this._ua.configuration.ha1 !== null)) {\n\n        // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n        if (response.status_code === 401) {\n          challenge = response.parseHeader('www-authenticate');\n          authorization_header_name = 'authorization';\n        } else {\n          challenge = response.parseHeader('proxy-authenticate');\n          authorization_header_name = 'proxy-authorization';\n        }\n\n        // Verify it seems a valid challenge.\n        if (!challenge) {\n          debug(response.status_code + ' with wrong or missing challenge, cannot authenticate');\n          this._eventHandlers.onReceiveResponse(response);\n\n          return;\n        }\n\n        if (!this._challenged || !this._staled && challenge.stale === true) {\n          if (!this._auth) {\n            this._auth = new DigestAuthentication({\n              username: this._ua.configuration.authorization_user,\n              password: this._ua.configuration.password,\n              realm: this._ua.configuration.realm,\n              ha1: this._ua.configuration.ha1\n            });\n          }\n\n          // Verify that the challenge is really valid.\n          if (!this._auth.authenticate(this._request, challenge)) {\n            this._eventHandlers.onReceiveResponse(response);\n\n            return;\n          }\n          this._challenged = true;\n\n          // Update ha1 and realm in the UA.\n          this._ua.set('realm', this._auth.get('realm'));\n          this._ua.set('ha1', this._auth.get('ha1'));\n\n          if (challenge.stale) {\n            this._staled = true;\n          }\n\n          this._request = this._request.clone();\n          this._request.cseq += 1;\n          this._request.setHeader('cseq', this._request.cseq + ' ' + this._method);\n          this._request.setHeader(authorization_header_name, this._auth.toString());\n\n          this._eventHandlers.onAuthenticated(this._request);\n          this.send();\n        } else {\n          this._eventHandlers.onReceiveResponse(response);\n        }\n      } else {\n        this._eventHandlers.onReceiveResponse(response);\n      }\n    }\n  }]);\n\n  return RequestSender;\n}();\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/RequestSender.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/SIPMessage.js":
/*!**************************************************!*\
  !*** ./node_modules/jssip/lib-es5/SIPMessage.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar sdp_transform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nvar JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar NameAddrHeader = __webpack_require__(/*! ./NameAddrHeader */ \"./node_modules/jssip/lib-es5/NameAddrHeader.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib-es5/Grammar.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:SIPMessage');\n\n/**\n * -param {String} method request method\n * -param {String} ruri request uri\n * -param {UA} ua\n * -param {Object} params parameters that will have priority over ua.configuration parameters:\n * <br>\n *  - cseq, call_id, from_tag, from_uri, from_display_name, to_uri, to_tag, route_set\n * -param {Object} [headers] extra headers\n * -param {String} [body]\n */\n\nvar OutgoingRequest = function () {\n  function OutgoingRequest(method, ruri, ua, params, extraHeaders, body) {\n    _classCallCheck(this, OutgoingRequest);\n\n    // Mandatory parameters check.\n    if (!method || !ruri || !ua) {\n      return null;\n    }\n\n    params = params || {};\n\n    this.ua = ua;\n    this.headers = {};\n    this.method = method;\n    this.ruri = ruri;\n    this.body = body;\n    this.extraHeaders = Utils.cloneArray(extraHeaders);\n\n    // Fill the Common SIP Request Headers.\n\n    // Route.\n    if (params.route_set) {\n      this.setHeader('route', params.route_set);\n    } else if (ua.configuration.use_preloaded_route) {\n      this.setHeader('route', '<' + ua.transport.sip_uri + ';lr>');\n    }\n\n    // Via.\n    // Empty Via header. Will be filled by the client transaction.\n    this.setHeader('via', '');\n\n    // Max-Forwards.\n    this.setHeader('max-forwards', JsSIP_C.MAX_FORWARDS);\n\n    // To\n    var to = params.to_display_name || params.to_display_name === 0 ? '\"' + params.to_display_name + '\" ' : '';\n\n    to += '<' + (params.to_uri || ruri) + '>';\n    to += params.to_tag ? ';tag=' + params.to_tag : '';\n    this.to = NameAddrHeader.parse(to);\n    this.setHeader('to', to);\n\n    // From.\n    var from = void 0;\n\n    if (params.from_display_name || params.from_display_name === 0) {\n      from = '\"' + params.from_display_name + '\" ';\n    } else if (ua.configuration.display_name) {\n      from = '\"' + ua.configuration.display_name + '\" ';\n    } else {\n      from = '';\n    }\n    from += '<' + (params.from_uri || ua.configuration.uri) + '>;tag=';\n    from += params.from_tag || Utils.newTag();\n    this.from = NameAddrHeader.parse(from);\n    this.setHeader('from', from);\n\n    // Call-ID.\n    var call_id = params.call_id || ua.configuration.jssip_id + Utils.createRandomToken(15);\n\n    this.call_id = call_id;\n    this.setHeader('call-id', call_id);\n\n    // CSeq.\n    var cseq = params.cseq || Math.floor(Math.random() * 10000);\n\n    this.cseq = cseq;\n    this.setHeader('cseq', cseq + ' ' + method);\n  }\n\n  /**\n   * Replace the the given header by the given value.\n   * -param {String} name header name\n   * -param {String | Array} value header value\n   */\n\n  _createClass(OutgoingRequest, [{\n    key: 'setHeader',\n    value: function setHeader(name, value) {\n      // Remove the header from extraHeaders if present.\n      var regexp = new RegExp('^\\\\s*' + name + '\\\\s*:', 'i');\n\n      for (var idx = 0; idx < this.extraHeaders.length; idx++) {\n        if (regexp.test(this.extraHeaders[idx])) {\n          this.extraHeaders.splice(idx, 1);\n        }\n      }\n\n      this.headers[Utils.headerize(name)] = Array.isArray(value) ? value : [value];\n    }\n\n    /**\n     * Get the value of the given header name at the given position.\n     * -param {String} name header name\n     * -returns {String|undefined} Returns the specified header, null if header doesn't exist.\n     */\n\n  }, {\n    key: 'getHeader',\n    value: function getHeader(name) {\n      var headers = this.headers[Utils.headerize(name)];\n\n      if (headers) {\n        if (headers[0]) {\n          return headers[0];\n        }\n      } else {\n        var regexp = new RegExp('^\\\\s*' + name + '\\\\s*:', 'i');\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.extraHeaders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var header = _step.value;\n\n            if (regexp.test(header)) {\n              return header.substring(header.indexOf(':') + 1).trim();\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return;\n    }\n\n    /**\n     * Get the header/s of the given name.\n     * -param {String} name header name\n     * -returns {Array} Array with all the headers of the specified name.\n     */\n\n  }, {\n    key: 'getHeaders',\n    value: function getHeaders(name) {\n      var headers = this.headers[Utils.headerize(name)];\n      var result = [];\n\n      if (headers) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = headers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var header = _step2.value;\n\n            result.push(header);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return result;\n      } else {\n        var regexp = new RegExp('^\\\\s*' + name + '\\\\s*:', 'i');\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = this.extraHeaders[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _header = _step3.value;\n\n            if (regexp.test(_header)) {\n              result.push(_header.substring(_header.indexOf(':') + 1).trim());\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        return result;\n      }\n    }\n\n    /**\n     * Verify the existence of the given header.\n     * -param {String} name header name\n     * -returns {boolean} true if header with given name exists, false otherwise\n     */\n\n  }, {\n    key: 'hasHeader',\n    value: function hasHeader(name) {\n      if (this.headers[Utils.headerize(name)]) {\n        return true;\n      } else {\n        var regexp = new RegExp('^\\\\s*' + name + '\\\\s*:', 'i');\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = this.extraHeaders[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var header = _step4.value;\n\n            if (regexp.test(header)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Parse the current body as a SDP and store the resulting object\n     * into this.sdp.\n     * -param {Boolean} force: Parse even if this.sdp already exists.\n     *\n     * Returns this.sdp.\n     */\n\n  }, {\n    key: 'parseSDP',\n    value: function parseSDP(force) {\n      if (!force && this.sdp) {\n        return this.sdp;\n      } else {\n        this.sdp = sdp_transform.parse(this.body || '');\n\n        return this.sdp;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var msg = this.method + ' ' + this.ruri + ' SIP/2.0\\r\\n';\n\n      for (var headerName in this.headers) {\n        if (Object.prototype.hasOwnProperty.call(this.headers, headerName)) {\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = this.headers[headerName][Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var headerValue = _step5.value;\n\n              msg += headerName + ': ' + headerValue + '\\r\\n';\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.extraHeaders[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var header = _step6.value;\n\n          msg += header.trim() + '\\r\\n';\n        }\n\n        // Supported.\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var supported = [];\n\n      switch (this.method) {\n        case JsSIP_C.REGISTER:\n          supported.push('path', 'gruu');\n          break;\n        case JsSIP_C.INVITE:\n          if (this.ua.configuration.session_timers) {\n            supported.push('timer');\n          }\n          if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {\n            supported.push('gruu');\n          }\n          supported.push('ice', 'replaces');\n          break;\n        case JsSIP_C.UPDATE:\n          if (this.ua.configuration.session_timers) {\n            supported.push('timer');\n          }\n          supported.push('ice');\n          break;\n      }\n\n      supported.push('outbound');\n\n      var userAgent = this.ua.configuration.user_agent || JsSIP_C.USER_AGENT;\n\n      // Allow.\n      msg += 'Allow: ' + JsSIP_C.ALLOWED_METHODS + '\\r\\n';\n      msg += 'Supported: ' + supported + '\\r\\n';\n      msg += 'User-Agent: ' + userAgent + '\\r\\n';\n\n      if (this.body) {\n        var length = Utils.str_utf8_length(this.body);\n\n        msg += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n        msg += this.body;\n      } else {\n        msg += 'Content-Length: 0\\r\\n\\r\\n';\n      }\n\n      return msg;\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var request = new OutgoingRequest(this.method, this.ruri, this.ua);\n\n      Object.keys(this.headers).forEach(function (name) {\n        request.headers[name] = this.headers[name].slice();\n      }, this);\n\n      request.body = this.body;\n      request.extraHeaders = Utils.cloneArray(this.extraHeaders);\n      request.to = this.to;\n      request.from = this.from;\n      request.call_id = this.call_id;\n      request.cseq = this.cseq;\n\n      return request;\n    }\n  }]);\n\n  return OutgoingRequest;\n}();\n\nvar InitialOutgoingInviteRequest = function (_OutgoingRequest) {\n  _inherits(InitialOutgoingInviteRequest, _OutgoingRequest);\n\n  function InitialOutgoingInviteRequest(ruri, ua, params, extraHeaders, body) {\n    _classCallCheck(this, InitialOutgoingInviteRequest);\n\n    var _this = _possibleConstructorReturn(this, (InitialOutgoingInviteRequest.__proto__ || Object.getPrototypeOf(InitialOutgoingInviteRequest)).call(this, JsSIP_C.INVITE, ruri, ua, params, extraHeaders, body));\n\n    _this.transaction = null;\n    return _this;\n  }\n\n  _createClass(InitialOutgoingInviteRequest, [{\n    key: 'cancel',\n    value: function cancel(reason) {\n      this.transaction.cancel(reason);\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var request = new InitialOutgoingInviteRequest(this.ruri, this.ua);\n\n      Object.keys(this.headers).forEach(function (name) {\n        request.headers[name] = this.headers[name].slice();\n      }, this);\n\n      request.body = this.body;\n      request.extraHeaders = Utils.cloneArray(this.extraHeaders);\n      request.to = this.to;\n      request.from = this.from;\n      request.call_id = this.call_id;\n      request.cseq = this.cseq;\n\n      request.transaction = this.transaction;\n\n      return request;\n    }\n  }]);\n\n  return InitialOutgoingInviteRequest;\n}(OutgoingRequest);\n\nvar IncomingMessage = function () {\n  function IncomingMessage() {\n    _classCallCheck(this, IncomingMessage);\n\n    this.data = null;\n    this.headers = null;\n    this.method = null;\n    this.via = null;\n    this.via_branch = null;\n    this.call_id = null;\n    this.cseq = null;\n    this.from = null;\n    this.from_tag = null;\n    this.to = null;\n    this.to_tag = null;\n    this.body = null;\n    this.sdp = null;\n  }\n\n  /**\n  * Insert a header of the given name and value into the last position of the\n  * header array.\n  */\n\n  _createClass(IncomingMessage, [{\n    key: 'addHeader',\n    value: function addHeader(name, value) {\n      var header = { raw: value };\n\n      name = Utils.headerize(name);\n\n      if (this.headers[name]) {\n        this.headers[name].push(header);\n      } else {\n        this.headers[name] = [header];\n      }\n    }\n\n    /**\n     * Get the value of the given header name at the given position.\n     */\n\n  }, {\n    key: 'getHeader',\n    value: function getHeader(name) {\n      var header = this.headers[Utils.headerize(name)];\n\n      if (header) {\n        if (header[0]) {\n          return header[0].raw;\n        }\n      } else {\n        return;\n      }\n    }\n\n    /**\n     * Get the header/s of the given name.\n     */\n\n  }, {\n    key: 'getHeaders',\n    value: function getHeaders(name) {\n      var headers = this.headers[Utils.headerize(name)];\n      var result = [];\n\n      if (!headers) {\n        return [];\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = headers[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var header = _step7.value;\n\n          result.push(header.raw);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return result;\n    }\n\n    /**\n     * Verify the existence of the given header.\n     */\n\n  }, {\n    key: 'hasHeader',\n    value: function hasHeader(name) {\n      return this.headers[Utils.headerize(name)] ? true : false;\n    }\n\n    /**\n    * Parse the given header on the given index.\n    * -param {String} name header name\n    * -param {Number} [idx=0] header index\n    * -returns {Object|undefined} Parsed header object, undefined if the header\n    *  is not present or in case of a parsing error.\n    */\n\n  }, {\n    key: 'parseHeader',\n    value: function parseHeader(name) {\n      var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      name = Utils.headerize(name);\n\n      if (!this.headers[name]) {\n        debug('header \"' + name + '\" not present');\n\n        return;\n      } else if (idx >= this.headers[name].length) {\n        debug('not so many \"' + name + '\" headers present');\n\n        return;\n      }\n\n      var header = this.headers[name][idx];\n      var value = header.raw;\n\n      if (header.parsed) {\n        return header.parsed;\n      }\n\n      // Substitute '-' by '_' for grammar rule matching.\n      var parsed = Grammar.parse(value, name.replace(/-/g, '_'));\n\n      if (parsed === -1) {\n        this.headers[name].splice(idx, 1); // delete from headers\n        debug('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n\n        return;\n      } else {\n        header.parsed = parsed;\n\n        return parsed;\n      }\n    }\n\n    /**\n     * Message Header attribute selector. Alias of parseHeader.\n     * -param {String} name header name\n     * -param {Number} [idx=0] header index\n     * -returns {Object|undefined} Parsed header object, undefined if the header\n     *  is not present or in case of a parsing error.\n     *\n     * -example\n     * message.s('via',3).port\n     */\n\n  }, {\n    key: 's',\n    value: function s(name, idx) {\n      return this.parseHeader(name, idx);\n    }\n\n    /**\n    * Replace the value of the given header by the value.\n    * -param {String} name header name\n    * -param {String} value header value\n    */\n\n  }, {\n    key: 'setHeader',\n    value: function setHeader(name, value) {\n      var header = { raw: value };\n\n      this.headers[Utils.headerize(name)] = [header];\n    }\n\n    /**\n     * Parse the current body as a SDP and store the resulting object\n     * into this.sdp.\n     * -param {Boolean} force: Parse even if this.sdp already exists.\n     *\n     * Returns this.sdp.\n     */\n\n  }, {\n    key: 'parseSDP',\n    value: function parseSDP(force) {\n      if (!force && this.sdp) {\n        return this.sdp;\n      } else {\n        this.sdp = sdp_transform.parse(this.body || '');\n\n        return this.sdp;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.data;\n    }\n  }]);\n\n  return IncomingMessage;\n}();\n\nvar IncomingRequest = function (_IncomingMessage) {\n  _inherits(IncomingRequest, _IncomingMessage);\n\n  function IncomingRequest(ua) {\n    _classCallCheck(this, IncomingRequest);\n\n    var _this2 = _possibleConstructorReturn(this, (IncomingRequest.__proto__ || Object.getPrototypeOf(IncomingRequest)).call(this));\n\n    _this2.ua = ua;\n    _this2.headers = {};\n    _this2.ruri = null;\n    _this2.transport = null;\n    _this2.server_transaction = null;\n    return _this2;\n  }\n\n  /**\n  * Stateful reply.\n  * -param {Number} code status code\n  * -param {String} reason reason phrase\n  * -param {Object} headers extra headers\n  * -param {String} body body\n  * -param {Function} [onSuccess] onSuccess callback\n  * -param {Function} [onFailure] onFailure callback\n  */\n\n  _createClass(IncomingRequest, [{\n    key: 'reply',\n    value: function reply(code, reason, extraHeaders, body, onSuccess, onFailure) {\n      var supported = [];\n      var to = this.getHeader('To');\n\n      code = code || null;\n      reason = reason || null;\n\n      // Validate code and reason values.\n      if (!code || code < 100 || code > 699) {\n        throw new TypeError('Invalid status_code: ' + code);\n      } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n        throw new TypeError('Invalid reason_phrase: ' + reason);\n      }\n\n      reason = reason || JsSIP_C.REASON_PHRASE[code] || '';\n      extraHeaders = Utils.cloneArray(extraHeaders);\n\n      var response = 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n\n      if (this.method === JsSIP_C.INVITE && code > 100 && code <= 200) {\n        var headers = this.getHeaders('record-route');\n\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = headers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var header = _step8.value;\n\n            response += 'Record-Route: ' + header + '\\r\\n';\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n      }\n\n      var vias = this.getHeaders('via');\n\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = vias[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var via = _step9.value;\n\n          response += 'Via: ' + via + '\\r\\n';\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      if (!this.to_tag && code > 100) {\n        to += ';tag=' + Utils.newTag();\n      } else if (this.to_tag && !this.s('to').hasParam('tag')) {\n        to += ';tag=' + this.to_tag;\n      }\n\n      response += 'To: ' + to + '\\r\\n';\n      response += 'From: ' + this.getHeader('From') + '\\r\\n';\n      response += 'Call-ID: ' + this.call_id + '\\r\\n';\n      response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = extraHeaders[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var _header2 = _step10.value;\n\n          response += _header2.trim() + '\\r\\n';\n        }\n\n        // Supported.\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      switch (this.method) {\n        case JsSIP_C.INVITE:\n          if (this.ua.configuration.session_timers) {\n            supported.push('timer');\n          }\n          if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {\n            supported.push('gruu');\n          }\n          supported.push('ice', 'replaces');\n          break;\n        case JsSIP_C.UPDATE:\n          if (this.ua.configuration.session_timers) {\n            supported.push('timer');\n          }\n          if (body) {\n            supported.push('ice');\n          }\n          supported.push('replaces');\n      }\n\n      supported.push('outbound');\n\n      // Allow and Accept.\n      if (this.method === JsSIP_C.OPTIONS) {\n        response += 'Allow: ' + JsSIP_C.ALLOWED_METHODS + '\\r\\n';\n        response += 'Accept: ' + JsSIP_C.ACCEPTED_BODY_TYPES + '\\r\\n';\n      } else if (code === 405) {\n        response += 'Allow: ' + JsSIP_C.ALLOWED_METHODS + '\\r\\n';\n      } else if (code === 415) {\n        response += 'Accept: ' + JsSIP_C.ACCEPTED_BODY_TYPES + '\\r\\n';\n      }\n\n      response += 'Supported: ' + supported + '\\r\\n';\n\n      if (body) {\n        var length = Utils.str_utf8_length(body);\n\n        response += 'Content-Type: application/sdp\\r\\n';\n        response += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n        response += body;\n      } else {\n        response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n      }\n\n      this.server_transaction.receiveResponse(code, response, onSuccess, onFailure);\n    }\n\n    /**\n    * Stateless reply.\n    * -param {Number} code status code\n    * -param {String} reason reason phrase\n    */\n\n  }, {\n    key: 'reply_sl',\n    value: function reply_sl() {\n      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var vias = this.getHeaders('via');\n\n      // Validate code and reason values.\n      if (!code || code < 100 || code > 699) {\n        throw new TypeError('Invalid status_code: ' + code);\n      } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n        throw new TypeError('Invalid reason_phrase: ' + reason);\n      }\n\n      reason = reason || JsSIP_C.REASON_PHRASE[code] || '';\n\n      var response = 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n\n      var _iteratorNormalCompletion11 = true;\n      var _didIteratorError11 = false;\n      var _iteratorError11 = undefined;\n\n      try {\n        for (var _iterator11 = vias[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n          var via = _step11.value;\n\n          response += 'Via: ' + via + '\\r\\n';\n        }\n      } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion11 && _iterator11.return) {\n            _iterator11.return();\n          }\n        } finally {\n          if (_didIteratorError11) {\n            throw _iteratorError11;\n          }\n        }\n      }\n\n      var to = this.getHeader('To');\n\n      if (!this.to_tag && code > 100) {\n        to += ';tag=' + Utils.newTag();\n      } else if (this.to_tag && !this.s('to').hasParam('tag')) {\n        to += ';tag=' + this.to_tag;\n      }\n\n      response += 'To: ' + to + '\\r\\n';\n      response += 'From: ' + this.getHeader('From') + '\\r\\n';\n      response += 'Call-ID: ' + this.call_id + '\\r\\n';\n      response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n      response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n\n      this.transport.send(response);\n    }\n  }]);\n\n  return IncomingRequest;\n}(IncomingMessage);\n\nvar IncomingResponse = function (_IncomingMessage2) {\n  _inherits(IncomingResponse, _IncomingMessage2);\n\n  function IncomingResponse() {\n    _classCallCheck(this, IncomingResponse);\n\n    var _this3 = _possibleConstructorReturn(this, (IncomingResponse.__proto__ || Object.getPrototypeOf(IncomingResponse)).call(this));\n\n    _this3.headers = {};\n    _this3.status_code = null;\n    _this3.reason_phrase = null;\n    return _this3;\n  }\n\n  return IncomingResponse;\n}(IncomingMessage);\n\nmodule.exports = {\n  OutgoingRequest: OutgoingRequest,\n  InitialOutgoingInviteRequest: InitialOutgoingInviteRequest,\n  IncomingRequest: IncomingRequest,\n  IncomingResponse: IncomingResponse\n};\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/SIPMessage.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Socket.js":
/*!**********************************************!*\
  !*** ./node_modules/jssip/lib-es5/Socket.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib-es5/Grammar.js\");\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:ERROR:Socket');\n\ndebugerror.log = console.warn.bind(console);\n\n/**\n * Interface documentation: http://jssip.net/documentation/$last_version/api/socket/\n *\n * interface Socket {\n *  attribute String via_transport\n *  attribute String url\n *  attribute String sip_uri\n *\n *  method connect();\n *  method disconnect();\n *  method send(data);\n *\n *  attribute EventHandler onconnect\n *  attribute EventHandler ondisconnect\n *  attribute EventHandler ondata\n * }\n *\n */\n\nexports.isSocket = function (socket) {\n  // Ignore if an array is given.\n  if (Array.isArray(socket)) {\n    return false;\n  }\n\n  if (typeof socket === 'undefined') {\n    debugerror('undefined JsSIP.Socket instance');\n\n    return false;\n  }\n\n  // Check Properties.\n  try {\n    if (!Utils.isString(socket.url)) {\n      debugerror('missing or invalid JsSIP.Socket url property');\n      throw new Error();\n    }\n\n    if (!Utils.isString(socket.via_transport)) {\n      debugerror('missing or invalid JsSIP.Socket via_transport property');\n      throw new Error();\n    }\n\n    if (Grammar.parse(socket.sip_uri, 'SIP_URI') === -1) {\n      debugerror('missing or invalid JsSIP.Socket sip_uri property');\n      throw new Error();\n    }\n  } catch (e) {\n    return false;\n  }\n\n  // Check Methods.\n  try {\n    ['connect', 'disconnect', 'send'].forEach(function (method) {\n      if (!Utils.isFunction(socket[method])) {\n        debugerror('missing or invalid JsSIP.Socket method: ' + method);\n        throw new Error();\n      }\n    });\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Socket.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Timers.js":
/*!**********************************************!*\
  !*** ./node_modules/jssip/lib-es5/Timers.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar T1 = 500,\n    T2 = 4000,\n    T4 = 5000;\n\nmodule.exports = {\n  T1: T1,\n  T2: T2,\n  T4: T4,\n  TIMER_B: 64 * T1,\n  TIMER_D: 0 * T1,\n  TIMER_F: 64 * T1,\n  TIMER_H: 64 * T1,\n  TIMER_I: 0 * T1,\n  TIMER_J: 0 * T1,\n  TIMER_K: 0 * T4,\n  TIMER_L: 64 * T1,\n  TIMER_M: 64 * T1,\n  PROVISIONAL_RESPONSE_INTERVAL: 60000 // See RFC 3261 Section 13.3.1.1\n};\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Timers.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Transactions.js":
/*!****************************************************!*\
  !*** ./node_modules/jssip/lib-es5/Transactions.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib-es5/SIPMessage.js\");\nvar Timers = __webpack_require__(/*! ./Timers */ \"./node_modules/jssip/lib-es5/Timers.js\");\nvar debugnict = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:NonInviteClientTransaction');\nvar debugict = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:InviteClientTransaction');\nvar debugact = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:AckClientTransaction');\nvar debugnist = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:NonInviteServerTransaction');\nvar debugist = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:InviteServerTransaction');\n\nvar C = {\n  // Transaction states.\n  STATUS_TRYING: 1,\n  STATUS_PROCEEDING: 2,\n  STATUS_CALLING: 3,\n  STATUS_ACCEPTED: 4,\n  STATUS_COMPLETED: 5,\n  STATUS_TERMINATED: 6,\n  STATUS_CONFIRMED: 7,\n\n  // Transaction types.\n  NON_INVITE_CLIENT: 'nict',\n  NON_INVITE_SERVER: 'nist',\n  INVITE_CLIENT: 'ict',\n  INVITE_SERVER: 'ist'\n};\n\nvar NonInviteClientTransaction = function (_EventEmitter) {\n  _inherits(NonInviteClientTransaction, _EventEmitter);\n\n  function NonInviteClientTransaction(ua, transport, request, eventHandlers) {\n    _classCallCheck(this, NonInviteClientTransaction);\n\n    var _this = _possibleConstructorReturn(this, (NonInviteClientTransaction.__proto__ || Object.getPrototypeOf(NonInviteClientTransaction)).call(this));\n\n    _this.type = C.NON_INVITE_CLIENT;\n    _this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n    _this.ua = ua;\n    _this.transport = transport;\n    _this.request = request;\n    _this.eventHandlers = eventHandlers;\n\n    var via = 'SIP/2.0/' + transport.via_transport;\n\n    via += ' ' + ua.configuration.via_host + ';branch=' + _this.id;\n\n    _this.request.setHeader('via', via);\n\n    _this.ua.newTransaction(_this);\n    return _this;\n  }\n\n  _createClass(NonInviteClientTransaction, [{\n    key: 'stateChanged',\n    value: function stateChanged(state) {\n      this.state = state;\n      this.emit('stateChanged');\n    }\n  }, {\n    key: 'send',\n    value: function send() {\n      var _this2 = this;\n\n      this.stateChanged(C.STATUS_TRYING);\n      this.F = setTimeout(function () {\n        _this2.timer_F();\n      }, Timers.TIMER_F);\n\n      if (!this.transport.send(this.request)) {\n        this.onTransportError();\n      }\n    }\n  }, {\n    key: 'onTransportError',\n    value: function onTransportError() {\n      debugnict('transport error occurred, deleting transaction ' + this.id);\n      clearTimeout(this.F);\n      clearTimeout(this.K);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n      this.eventHandlers.onTransportError();\n    }\n  }, {\n    key: 'timer_F',\n    value: function timer_F() {\n      debugnict('Timer F expired for transaction ' + this.id);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n      this.eventHandlers.onRequestTimeout();\n    }\n  }, {\n    key: 'timer_K',\n    value: function timer_K() {\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }, {\n    key: 'receiveResponse',\n    value: function receiveResponse(response) {\n      var _this3 = this;\n\n      var status_code = response.status_code;\n\n      if (status_code < 200) {\n        switch (this.state) {\n          case C.STATUS_TRYING:\n          case C.STATUS_PROCEEDING:\n            this.stateChanged(C.STATUS_PROCEEDING);\n            this.eventHandlers.onReceiveResponse(response);\n            break;\n        }\n      } else {\n        switch (this.state) {\n          case C.STATUS_TRYING:\n          case C.STATUS_PROCEEDING:\n            this.stateChanged(C.STATUS_COMPLETED);\n            clearTimeout(this.F);\n\n            if (status_code === 408) {\n              this.eventHandlers.onRequestTimeout();\n            } else {\n              this.eventHandlers.onReceiveResponse(response);\n            }\n\n            this.K = setTimeout(function () {\n              _this3.timer_K();\n            }, Timers.TIMER_K);\n            break;\n          case C.STATUS_COMPLETED:\n            break;\n        }\n      }\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  return NonInviteClientTransaction;\n}(EventEmitter);\n\nvar InviteClientTransaction = function (_EventEmitter2) {\n  _inherits(InviteClientTransaction, _EventEmitter2);\n\n  function InviteClientTransaction(ua, transport, request, eventHandlers) {\n    _classCallCheck(this, InviteClientTransaction);\n\n    var _this4 = _possibleConstructorReturn(this, (InviteClientTransaction.__proto__ || Object.getPrototypeOf(InviteClientTransaction)).call(this));\n\n    _this4.type = C.INVITE_CLIENT;\n    _this4.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n    _this4.ua = ua;\n    _this4.transport = transport;\n    _this4.request = request;\n    _this4.eventHandlers = eventHandlers;\n    request.transaction = _this4;\n\n    var via = 'SIP/2.0/' + transport.via_transport;\n\n    via += ' ' + ua.configuration.via_host + ';branch=' + _this4.id;\n\n    _this4.request.setHeader('via', via);\n\n    _this4.ua.newTransaction(_this4);\n    return _this4;\n  }\n\n  _createClass(InviteClientTransaction, [{\n    key: 'stateChanged',\n    value: function stateChanged(state) {\n      this.state = state;\n      this.emit('stateChanged');\n    }\n  }, {\n    key: 'send',\n    value: function send() {\n      var _this5 = this;\n\n      this.stateChanged(C.STATUS_CALLING);\n      this.B = setTimeout(function () {\n        _this5.timer_B();\n      }, Timers.TIMER_B);\n\n      if (!this.transport.send(this.request)) {\n        this.onTransportError();\n      }\n    }\n  }, {\n    key: 'onTransportError',\n    value: function onTransportError() {\n      clearTimeout(this.B);\n      clearTimeout(this.D);\n      clearTimeout(this.M);\n\n      if (this.state !== C.STATUS_ACCEPTED) {\n        debugict('transport error occurred, deleting transaction ' + this.id);\n        this.eventHandlers.onTransportError();\n      }\n\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n\n    // RFC 6026 7.2.\n\n  }, {\n    key: 'timer_M',\n    value: function timer_M() {\n      debugict('Timer M expired for transaction ' + this.id);\n\n      if (this.state === C.STATUS_ACCEPTED) {\n        clearTimeout(this.B);\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n      }\n    }\n\n    // RFC 3261 17.1.1.\n\n  }, {\n    key: 'timer_B',\n    value: function timer_B() {\n      debugict('Timer B expired for transaction ' + this.id);\n      if (this.state === C.STATUS_CALLING) {\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n        this.eventHandlers.onRequestTimeout();\n      }\n    }\n  }, {\n    key: 'timer_D',\n    value: function timer_D() {\n      debugict('Timer D expired for transaction ' + this.id);\n      clearTimeout(this.B);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }, {\n    key: 'sendACK',\n    value: function sendACK(response) {\n      var _this6 = this;\n\n      var ack = new SIPMessage.OutgoingRequest(JsSIP_C.ACK, this.request.ruri, this.ua, {\n        'route_set': this.request.getHeader('route'),\n        'call_id': this.request.getHeader('call-id'),\n        'cseq': this.request.cseq\n      });\n\n      ack.setHeader('from', this.request.getHeader('from'));\n      ack.setHeader('via', this.request.getHeader('via'));\n      ack.setHeader('to', response.getHeader('to'));\n\n      this.D = setTimeout(function () {\n        _this6.timer_D();\n      }, Timers.TIMER_D);\n\n      this.transport.send(ack);\n    }\n  }, {\n    key: 'cancel',\n    value: function cancel(reason) {\n      // Send only if a provisional response (>100) has been received.\n      if (this.state !== C.STATUS_PROCEEDING) {\n        return;\n      }\n\n      var cancel = new SIPMessage.OutgoingRequest(JsSIP_C.CANCEL, this.request.ruri, this.ua, {\n        'route_set': this.request.getHeader('route'),\n        'call_id': this.request.getHeader('call-id'),\n        'cseq': this.request.cseq\n      });\n\n      cancel.setHeader('from', this.request.getHeader('from'));\n      cancel.setHeader('via', this.request.getHeader('via'));\n      cancel.setHeader('to', this.request.getHeader('to'));\n\n      if (reason) {\n        cancel.setHeader('reason', reason);\n      }\n\n      this.transport.send(cancel);\n    }\n  }, {\n    key: 'receiveResponse',\n    value: function receiveResponse(response) {\n      var _this7 = this;\n\n      var status_code = response.status_code;\n\n      if (status_code >= 100 && status_code <= 199) {\n        switch (this.state) {\n          case C.STATUS_CALLING:\n            this.stateChanged(C.STATUS_PROCEEDING);\n            this.eventHandlers.onReceiveResponse(response);\n            break;\n          case C.STATUS_PROCEEDING:\n            this.eventHandlers.onReceiveResponse(response);\n            break;\n        }\n      } else if (status_code >= 200 && status_code <= 299) {\n        switch (this.state) {\n          case C.STATUS_CALLING:\n          case C.STATUS_PROCEEDING:\n            this.stateChanged(C.STATUS_ACCEPTED);\n            this.M = setTimeout(function () {\n              _this7.timer_M();\n            }, Timers.TIMER_M);\n            this.eventHandlers.onReceiveResponse(response);\n            break;\n          case C.STATUS_ACCEPTED:\n            this.eventHandlers.onReceiveResponse(response);\n            break;\n        }\n      } else if (status_code >= 300 && status_code <= 699) {\n        switch (this.state) {\n          case C.STATUS_CALLING:\n          case C.STATUS_PROCEEDING:\n            this.stateChanged(C.STATUS_COMPLETED);\n            this.sendACK(response);\n            this.eventHandlers.onReceiveResponse(response);\n            break;\n          case C.STATUS_COMPLETED:\n            this.sendACK(response);\n            break;\n        }\n      }\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  return InviteClientTransaction;\n}(EventEmitter);\n\nvar AckClientTransaction = function (_EventEmitter3) {\n  _inherits(AckClientTransaction, _EventEmitter3);\n\n  function AckClientTransaction(ua, transport, request, eventHandlers) {\n    _classCallCheck(this, AckClientTransaction);\n\n    var _this8 = _possibleConstructorReturn(this, (AckClientTransaction.__proto__ || Object.getPrototypeOf(AckClientTransaction)).call(this));\n\n    _this8.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n    _this8.transport = transport;\n    _this8.request = request;\n    _this8.eventHandlers = eventHandlers;\n\n    var via = 'SIP/2.0/' + transport.via_transport;\n\n    via += ' ' + ua.configuration.via_host + ';branch=' + _this8.id;\n\n    _this8.request.setHeader('via', via);\n    return _this8;\n  }\n\n  _createClass(AckClientTransaction, [{\n    key: 'send',\n    value: function send() {\n      if (!this.transport.send(this.request)) {\n        this.onTransportError();\n      }\n    }\n  }, {\n    key: 'onTransportError',\n    value: function onTransportError() {\n      debugact('transport error occurred for transaction ' + this.id);\n      this.eventHandlers.onTransportError();\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  return AckClientTransaction;\n}(EventEmitter);\n\nvar NonInviteServerTransaction = function (_EventEmitter4) {\n  _inherits(NonInviteServerTransaction, _EventEmitter4);\n\n  function NonInviteServerTransaction(ua, transport, request) {\n    _classCallCheck(this, NonInviteServerTransaction);\n\n    var _this9 = _possibleConstructorReturn(this, (NonInviteServerTransaction.__proto__ || Object.getPrototypeOf(NonInviteServerTransaction)).call(this));\n\n    _this9.type = C.NON_INVITE_SERVER;\n    _this9.id = request.via_branch;\n    _this9.ua = ua;\n    _this9.transport = transport;\n    _this9.request = request;\n    _this9.last_response = '';\n    request.server_transaction = _this9;\n\n    _this9.state = C.STATUS_TRYING;\n\n    ua.newTransaction(_this9);\n    return _this9;\n  }\n\n  _createClass(NonInviteServerTransaction, [{\n    key: 'stateChanged',\n    value: function stateChanged(state) {\n      this.state = state;\n      this.emit('stateChanged');\n    }\n  }, {\n    key: 'timer_J',\n    value: function timer_J() {\n      debugnist('Timer J expired for transaction ' + this.id);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }, {\n    key: 'onTransportError',\n    value: function onTransportError() {\n      if (!this.transportError) {\n        this.transportError = true;\n\n        debugnist('transport error occurred, deleting transaction ' + this.id);\n\n        clearTimeout(this.J);\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n      }\n    }\n  }, {\n    key: 'receiveResponse',\n    value: function receiveResponse(status_code, response, onSuccess, onFailure) {\n      var _this10 = this;\n\n      if (status_code === 100) {\n        /* RFC 4320 4.1\n         * 'A SIP element MUST NOT\n         * send any provisional response with a\n         * Status-Code other than 100 to a non-INVITE request.'\n         */\n        switch (this.state) {\n          case C.STATUS_TRYING:\n            this.stateChanged(C.STATUS_PROCEEDING);\n            if (!this.transport.send(response)) {\n              this.onTransportError();\n            }\n            break;\n          case C.STATUS_PROCEEDING:\n            this.last_response = response;\n            if (!this.transport.send(response)) {\n              this.onTransportError();\n              if (onFailure) {\n                onFailure();\n              }\n            } else if (onSuccess) {\n              onSuccess();\n            }\n            break;\n        }\n      } else if (status_code >= 200 && status_code <= 699) {\n        switch (this.state) {\n          case C.STATUS_TRYING:\n          case C.STATUS_PROCEEDING:\n            this.stateChanged(C.STATUS_COMPLETED);\n            this.last_response = response;\n            this.J = setTimeout(function () {\n              _this10.timer_J();\n            }, Timers.TIMER_J);\n            if (!this.transport.send(response)) {\n              this.onTransportError();\n              if (onFailure) {\n                onFailure();\n              }\n            } else if (onSuccess) {\n              onSuccess();\n            }\n            break;\n          case C.STATUS_COMPLETED:\n            break;\n        }\n      }\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  return NonInviteServerTransaction;\n}(EventEmitter);\n\nvar InviteServerTransaction = function (_EventEmitter5) {\n  _inherits(InviteServerTransaction, _EventEmitter5);\n\n  function InviteServerTransaction(ua, transport, request) {\n    _classCallCheck(this, InviteServerTransaction);\n\n    var _this11 = _possibleConstructorReturn(this, (InviteServerTransaction.__proto__ || Object.getPrototypeOf(InviteServerTransaction)).call(this));\n\n    _this11.type = C.INVITE_SERVER;\n    _this11.id = request.via_branch;\n    _this11.ua = ua;\n    _this11.transport = transport;\n    _this11.request = request;\n    _this11.last_response = '';\n    request.server_transaction = _this11;\n\n    _this11.state = C.STATUS_PROCEEDING;\n\n    ua.newTransaction(_this11);\n\n    _this11.resendProvisionalTimer = null;\n\n    request.reply(100);\n    return _this11;\n  }\n\n  _createClass(InviteServerTransaction, [{\n    key: 'stateChanged',\n    value: function stateChanged(state) {\n      this.state = state;\n      this.emit('stateChanged');\n    }\n  }, {\n    key: 'timer_H',\n    value: function timer_H() {\n      debugist('Timer H expired for transaction ' + this.id);\n\n      if (this.state === C.STATUS_COMPLETED) {\n        debugist('ACK not received, dialog will be terminated');\n      }\n\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }, {\n    key: 'timer_I',\n    value: function timer_I() {\n      this.stateChanged(C.STATUS_TERMINATED);\n    }\n\n    // RFC 6026 7.1.\n\n  }, {\n    key: 'timer_L',\n    value: function timer_L() {\n      debugist('Timer L expired for transaction ' + this.id);\n\n      if (this.state === C.STATUS_ACCEPTED) {\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n      }\n    }\n  }, {\n    key: 'onTransportError',\n    value: function onTransportError() {\n      if (!this.transportError) {\n        this.transportError = true;\n\n        debugist('transport error occurred, deleting transaction ' + this.id);\n\n        if (this.resendProvisionalTimer !== null) {\n          clearInterval(this.resendProvisionalTimer);\n          this.resendProvisionalTimer = null;\n        }\n\n        clearTimeout(this.L);\n        clearTimeout(this.H);\n        clearTimeout(this.I);\n\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n      }\n    }\n  }, {\n    key: 'resend_provisional',\n    value: function resend_provisional() {\n      if (!this.transport.send(this.last_response)) {\n        this.onTransportError();\n      }\n    }\n\n    // INVITE Server Transaction RFC 3261 17.2.1.\n\n  }, {\n    key: 'receiveResponse',\n    value: function receiveResponse(status_code, response, onSuccess, onFailure) {\n      var _this12 = this;\n\n      if (status_code >= 100 && status_code <= 199) {\n        switch (this.state) {\n          case C.STATUS_PROCEEDING:\n            if (!this.transport.send(response)) {\n              this.onTransportError();\n            }\n            this.last_response = response;\n            break;\n        }\n      }\n\n      if (status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {\n        // Trigger the resendProvisionalTimer only for the first non 100 provisional response.\n        if (this.resendProvisionalTimer === null) {\n          this.resendProvisionalTimer = setInterval(function () {\n            _this12.resend_provisional();\n          }, Timers.PROVISIONAL_RESPONSE_INTERVAL);\n        }\n      } else if (status_code >= 200 && status_code <= 299) {\n        switch (this.state) {\n          case C.STATUS_PROCEEDING:\n            this.stateChanged(C.STATUS_ACCEPTED);\n            this.last_response = response;\n            this.L = setTimeout(function () {\n              _this12.timer_L();\n            }, Timers.TIMER_L);\n\n            if (this.resendProvisionalTimer !== null) {\n              clearInterval(this.resendProvisionalTimer);\n              this.resendProvisionalTimer = null;\n            }\n\n          /* falls through */\n          case C.STATUS_ACCEPTED:\n            // Note that this point will be reached for proceeding this.state also.\n            if (!this.transport.send(response)) {\n              this.onTransportError();\n              if (onFailure) {\n                onFailure();\n              }\n            } else if (onSuccess) {\n              onSuccess();\n            }\n            break;\n        }\n      } else if (status_code >= 300 && status_code <= 699) {\n        switch (this.state) {\n          case C.STATUS_PROCEEDING:\n            if (this.resendProvisionalTimer !== null) {\n              clearInterval(this.resendProvisionalTimer);\n              this.resendProvisionalTimer = null;\n            }\n\n            if (!this.transport.send(response)) {\n              this.onTransportError();\n              if (onFailure) {\n                onFailure();\n              }\n            } else {\n              this.stateChanged(C.STATUS_COMPLETED);\n              this.H = setTimeout(function () {\n                _this12.timer_H();\n              }, Timers.TIMER_H);\n              if (onSuccess) {\n                onSuccess();\n              }\n            }\n            break;\n        }\n      }\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  return InviteServerTransaction;\n}(EventEmitter);\n\n/**\n * INVITE:\n *  _true_ if retransmission\n *  _false_ new request\n *\n * ACK:\n *  _true_  ACK to non2xx response\n *  _false_ ACK must be passed to TU (accepted state)\n *          ACK to 2xx response\n *\n * CANCEL:\n *  _true_  no matching invite transaction\n *  _false_ matching invite transaction and no final response sent\n *\n * OTHER:\n *  _true_  retransmission\n *  _false_ new request\n */\n\nfunction checkTransaction(_ref, request) {\n  var _transactions = _ref._transactions;\n\n  var tr = void 0;\n\n  switch (request.method) {\n    case JsSIP_C.INVITE:\n      tr = _transactions.ist[request.via_branch];\n      if (tr) {\n        switch (tr.state) {\n          case C.STATUS_PROCEEDING:\n            tr.transport.send(tr.last_response);\n            break;\n\n          // RFC 6026 7.1 Invite retransmission.\n          // Received while in C.STATUS_ACCEPTED state. Absorb it.\n          case C.STATUS_ACCEPTED:\n            break;\n        }\n\n        return true;\n      }\n      break;\n    case JsSIP_C.ACK:\n      tr = _transactions.ist[request.via_branch];\n\n      // RFC 6026 7.1.\n      if (tr) {\n        if (tr.state === C.STATUS_ACCEPTED) {\n          return false;\n        } else if (tr.state === C.STATUS_COMPLETED) {\n          tr.state = C.STATUS_CONFIRMED;\n          tr.I = setTimeout(function () {\n            tr.timer_I();\n          }, Timers.TIMER_I);\n\n          return true;\n        }\n      }\n      // ACK to 2XX Response.\n      else {\n          return false;\n        }\n      break;\n    case JsSIP_C.CANCEL:\n      tr = _transactions.ist[request.via_branch];\n      if (tr) {\n        request.reply_sl(200);\n        if (tr.state === C.STATUS_PROCEEDING) {\n          return false;\n        } else {\n          return true;\n        }\n      } else {\n        request.reply_sl(481);\n\n        return true;\n      }\n    default:\n\n      // Non-INVITE Server Transaction RFC 3261 17.2.2.\n      tr = _transactions.nist[request.via_branch];\n      if (tr) {\n        switch (tr.state) {\n          case C.STATUS_TRYING:\n            break;\n          case C.STATUS_PROCEEDING:\n          case C.STATUS_COMPLETED:\n            tr.transport.send(tr.last_response);\n            break;\n        }\n\n        return true;\n      }\n      break;\n  }\n}\n\nmodule.exports = {\n  C: C,\n  NonInviteClientTransaction: NonInviteClientTransaction,\n  InviteClientTransaction: InviteClientTransaction,\n  AckClientTransaction: AckClientTransaction,\n  NonInviteServerTransaction: NonInviteServerTransaction,\n  InviteServerTransaction: InviteServerTransaction,\n  checkTransaction: checkTransaction\n};\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Transactions.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Transport.js":
/*!*************************************************!*\
  !*** ./node_modules/jssip/lib-es5/Transport.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Socket = __webpack_require__(/*! ./Socket */ \"./node_modules/jssip/lib-es5/Socket.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:Transport');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:ERROR:Transport');\n\ndebugerror.log = console.warn.bind(console);\n\n/**\n * Constants\n */\nvar C = {\n  // Transport status.\n  STATUS_CONNECTED: 0,\n  STATUS_CONNECTING: 1,\n  STATUS_DISCONNECTED: 2,\n\n  // Socket status.\n  SOCKET_STATUS_READY: 0,\n  SOCKET_STATUS_ERROR: 1,\n\n  // Recovery options.\n  recovery_options: {\n    min_interval: 2, // minimum interval in seconds between recover attempts\n    max_interval: 30 // maximum interval in seconds between recover attempts\n  }\n};\n\n/*\n * Manages one or multiple JsSIP.Socket instances.\n * Is reponsible for transport recovery logic among all socket instances.\n *\n * @socket JsSIP::Socket instance\n */\nmodule.exports = function () {\n  function Transport(sockets) {\n    var recovery_options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : C.recovery_options;\n\n    _classCallCheck(this, Transport);\n\n    debug('new()');\n\n    this.status = C.STATUS_DISCONNECTED;\n\n    // Current socket.\n    this.socket = null;\n\n    // Socket collection.\n    this.sockets = [];\n\n    this.recovery_options = recovery_options;\n    this.recover_attempts = 0;\n    this.recovery_timer = null;\n\n    this.close_requested = false;\n\n    if (typeof sockets === 'undefined') {\n      throw new TypeError('Invalid argument.' + ' undefined \\'sockets\\' argument');\n    }\n\n    if (!(sockets instanceof Array)) {\n      sockets = [sockets];\n    }\n\n    sockets.forEach(function (socket) {\n      if (!Socket.isSocket(socket.socket)) {\n        throw new TypeError('Invalid argument.' + ' invalid \\'JsSIP.Socket\\' instance');\n      }\n\n      if (socket.weight && !Number(socket.weight)) {\n        throw new TypeError('Invalid argument.' + ' \\'weight\\' attribute is not a number');\n      }\n\n      this.sockets.push({\n        socket: socket.socket,\n        weight: socket.weight || 0,\n        status: C.SOCKET_STATUS_READY\n      });\n    }, this);\n\n    // Get the socket with higher weight.\n    this._getSocket();\n  }\n\n  /**\n   * Instance Methods\n   */\n\n  _createClass(Transport, [{\n    key: 'connect',\n    value: function connect() {\n      debug('connect()');\n\n      if (this.isConnected()) {\n        debug('Transport is already connected');\n\n        return;\n      } else if (this.isConnecting()) {\n        debug('Transport is connecting');\n\n        return;\n      }\n\n      this.close_requested = false;\n      this.status = C.STATUS_CONNECTING;\n      this.onconnecting({ socket: this.socket, attempts: this.recover_attempts });\n\n      if (!this.close_requested) {\n        // Bind socket event callbacks.\n        this.socket.onconnect = this._onConnect.bind(this);\n        this.socket.ondisconnect = this._onDisconnect.bind(this);\n        this.socket.ondata = this._onData.bind(this);\n\n        this.socket.connect();\n      }\n\n      return;\n    }\n  }, {\n    key: 'disconnect',\n    value: function disconnect() {\n      debug('close()');\n\n      this.close_requested = true;\n      this.recover_attempts = 0;\n      this.status = C.STATUS_DISCONNECTED;\n\n      // Clear recovery_timer.\n      if (this.recovery_timer !== null) {\n        clearTimeout(this.recovery_timer);\n        this.recovery_timer = null;\n      }\n\n      // Unbind socket event callbacks.\n      this.socket.onconnect = function () {};\n      this.socket.ondisconnect = function () {};\n      this.socket.ondata = function () {};\n\n      this.socket.disconnect();\n      this.ondisconnect({\n        socket: this.socket,\n        error: false\n      });\n    }\n  }, {\n    key: 'send',\n    value: function send(data) {\n      debug('send()');\n\n      if (!this.isConnected()) {\n        debugerror('unable to send message, transport is not connected');\n\n        return false;\n      }\n\n      var message = data.toString();\n\n      debug('sending message:\\n\\n' + message + '\\n');\n\n      return this.socket.send(message);\n    }\n  }, {\n    key: 'isConnected',\n    value: function isConnected() {\n      return this.status === C.STATUS_CONNECTED;\n    }\n  }, {\n    key: 'isConnecting',\n    value: function isConnecting() {\n      return this.status === C.STATUS_CONNECTING;\n    }\n\n    /**\n     * Private API.\n     */\n\n  }, {\n    key: '_reconnect',\n    value: function _reconnect() {\n      var _this = this;\n\n      this.recover_attempts += 1;\n\n      var k = Math.floor(Math.random() * Math.pow(2, this.recover_attempts) + 1);\n\n      if (k < this.recovery_options.min_interval) {\n        k = this.recovery_options.min_interval;\n      } else if (k > this.recovery_options.max_interval) {\n        k = this.recovery_options.max_interval;\n      }\n\n      debug('reconnection attempt: ' + this.recover_attempts + '. next connection attempt in ' + k + ' seconds');\n\n      this.recovery_timer = setTimeout(function () {\n        if (!_this.close_requested && !(_this.isConnected() || _this.isConnecting())) {\n          // Get the next available socket with higher weight.\n          _this._getSocket();\n\n          // Connect the socket.\n          _this.connect();\n        }\n      }, k * 1000);\n    }\n\n    /**\n     * get the next available socket with higher weight\n     */\n\n  }, {\n    key: '_getSocket',\n    value: function _getSocket() {\n\n      var candidates = [];\n\n      this.sockets.forEach(function (socket) {\n        if (socket.status === C.SOCKET_STATUS_ERROR) {\n          return; // continue the array iteration\n        } else if (candidates.length === 0) {\n          candidates.push(socket);\n        } else if (socket.weight > candidates[0].weight) {\n          candidates = [socket];\n        } else if (socket.weight === candidates[0].weight) {\n          candidates.push(socket);\n        }\n      });\n\n      if (candidates.length === 0) {\n        // All sockets have failed. reset sockets status.\n        this.sockets.forEach(function (socket) {\n          socket.status = C.SOCKET_STATUS_READY;\n        });\n\n        // Get next available socket.\n        this._getSocket();\n\n        return;\n      }\n\n      var idx = Math.floor(Math.random() * candidates.length);\n\n      this.socket = candidates[idx].socket;\n    }\n\n    /**\n     * Socket Event Handlers\n     */\n\n  }, {\n    key: '_onConnect',\n    value: function _onConnect() {\n      this.recover_attempts = 0;\n      this.status = C.STATUS_CONNECTED;\n\n      // Clear recovery_timer.\n      if (this.recovery_timer !== null) {\n        clearTimeout(this.recovery_timer);\n        this.recovery_timer = null;\n      }\n\n      this.onconnect({ socket: this });\n    }\n  }, {\n    key: '_onDisconnect',\n    value: function _onDisconnect(error, code, reason) {\n      this.status = C.STATUS_DISCONNECTED;\n      this.ondisconnect({\n        socket: this.socket,\n        error: error,\n        code: code,\n        reason: reason\n      });\n\n      if (this.close_requested) {\n        return;\n      }\n\n      // Update socket status.\n      else {\n          this.sockets.forEach(function (socket) {\n            if (this.socket === socket.socket) {\n              socket.status = C.SOCKET_STATUS_ERROR;\n            }\n          }, this);\n        }\n\n      this._reconnect(error);\n    }\n  }, {\n    key: '_onData',\n    value: function _onData(data) {\n      // CRLF Keep Alive response from server. Ignore it.\n      if (data === '\\r\\n') {\n        debug('received message with CRLF Keep Alive response');\n\n        return;\n      }\n\n      // Binary message.\n      else if (typeof data !== 'string') {\n          try {\n            data = String.fromCharCode.apply(null, new Uint8Array(data));\n          } catch (evt) {\n            debug('received binary message failed to be converted into string,' + ' message discarded');\n\n            return;\n          }\n\n          debug('received binary message:\\n\\n' + data + '\\n');\n        }\n\n        // Text message.\n        else {\n            debug('received text message:\\n\\n' + data + '\\n');\n          }\n\n      this.ondata({ transport: this, message: data });\n    }\n  }, {\n    key: 'via_transport',\n    get: function get() {\n      return this.socket.via_transport;\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      return this.socket.url;\n    }\n  }, {\n    key: 'sip_uri',\n    get: function get() {\n      return this.socket.sip_uri;\n    }\n  }]);\n\n  return Transport;\n}();\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Transport.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/UA.js":
/*!******************************************!*\
  !*** ./node_modules/jssip/lib-es5/UA.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar Registrator = __webpack_require__(/*! ./Registrator */ \"./node_modules/jssip/lib-es5/Registrator.js\");\nvar RTCSession = __webpack_require__(/*! ./RTCSession */ \"./node_modules/jssip/lib-es5/RTCSession.js\");\nvar Message = __webpack_require__(/*! ./Message */ \"./node_modules/jssip/lib-es5/Message.js\");\nvar Transactions = __webpack_require__(/*! ./Transactions */ \"./node_modules/jssip/lib-es5/Transactions.js\");\nvar Transport = __webpack_require__(/*! ./Transport */ \"./node_modules/jssip/lib-es5/Transport.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar Exceptions = __webpack_require__(/*! ./Exceptions */ \"./node_modules/jssip/lib-es5/Exceptions.js\");\nvar URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib-es5/URI.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib-es5/Grammar.js\");\nvar Parser = __webpack_require__(/*! ./Parser */ \"./node_modules/jssip/lib-es5/Parser.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib-es5/SIPMessage.js\");\nvar sanityCheck = __webpack_require__(/*! ./sanityCheck */ \"./node_modules/jssip/lib-es5/sanityCheck.js\");\nvar config = __webpack_require__(/*! ./Config */ \"./node_modules/jssip/lib-es5/Config.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:UA');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:ERROR:UA');\n\ndebugerror.log = console.warn.bind(console);\n\nvar C = {\n  // UA status codes.\n  STATUS_INIT: 0,\n  STATUS_READY: 1,\n  STATUS_USER_CLOSED: 2,\n  STATUS_NOT_READY: 3,\n\n  // UA error codes.\n  CONFIGURATION_ERROR: 1,\n  NETWORK_ERROR: 2\n};\n\n/**\n * The User-Agent class.\n * @class JsSIP.UA\n * @param {Object} configuration Configuration parameters.\n * @throws {JsSIP.Exceptions.ConfigurationError} If a configuration parameter is invalid.\n * @throws {TypeError} If no configuration is given.\n */\nmodule.exports = function (_EventEmitter) {\n  _inherits(UA, _EventEmitter);\n\n  _createClass(UA, null, [{\n    key: 'C',\n\n    // Expose C object.\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  function UA(configuration) {\n    _classCallCheck(this, UA);\n\n    debug('new() [configuration:%o]', configuration);\n\n    var _this = _possibleConstructorReturn(this, (UA.__proto__ || Object.getPrototypeOf(UA)).call(this));\n\n    _this._cache = {\n      credentials: {}\n    };\n\n    _this._configuration = Object.assign({}, config.settings);\n    _this._dynConfiguration = {};\n    _this._dialogs = {};\n\n    // User actions outside any session/dialog (MESSAGE).\n    _this._applicants = {};\n\n    _this._sessions = {};\n    _this._transport = null;\n    _this._contact = null;\n    _this._status = C.STATUS_INIT;\n    _this._error = null;\n    _this._transactions = {\n      nist: {},\n      nict: {},\n      ist: {},\n      ict: {}\n    };\n\n    // Custom UA empty object for high level use.\n    _this._data = {};\n\n    _this._closeTimer = null;\n\n    // Check configuration argument.\n    if (configuration === undefined) {\n      throw new TypeError('Not enough arguments');\n    }\n\n    // Load configuration.\n    try {\n      _this._loadConfig(configuration);\n    } catch (e) {\n      _this._status = C.STATUS_NOT_READY;\n      _this._error = C.CONFIGURATION_ERROR;\n      throw e;\n    }\n\n    // Initialize registrator.\n    _this._registrator = new Registrator(_this);\n    return _this;\n  }\n\n  _createClass(UA, [{\n    key: 'start',\n\n    // =================\n    //  High Level API\n    // =================\n\n    /**\n     * Connect to the server if status = STATUS_INIT.\n     * Resume UA after being closed.\n     */\n    value: function start() {\n      debug('start()');\n\n      if (this._status === C.STATUS_INIT) {\n        this._transport.connect();\n      } else if (this._status === C.STATUS_USER_CLOSED) {\n        debug('restarting UA');\n\n        // Disconnect.\n        if (this._closeTimer !== null) {\n          clearTimeout(this._closeTimer);\n          this._closeTimer = null;\n          this._transport.disconnect();\n        }\n\n        // Reconnect.\n        this._status = C.STATUS_INIT;\n        this._transport.connect();\n      } else if (this._status === C.STATUS_READY) {\n        debug('UA is in READY status, not restarted');\n      } else {\n        debug('ERROR: connection is down, Auto-Recovery system is trying to reconnect');\n      }\n\n      // Set dynamic configuration.\n      this._dynConfiguration.register = this._configuration.register;\n    }\n\n    /**\n     * Register.\n     */\n\n  }, {\n    key: 'register',\n    value: function register() {\n      debug('register()');\n\n      this._dynConfiguration.register = true;\n      this._registrator.register();\n    }\n\n    /**\n     * Unregister.\n     */\n\n  }, {\n    key: 'unregister',\n    value: function unregister(options) {\n      debug('unregister()');\n\n      this._dynConfiguration.register = false;\n      this._registrator.unregister(options);\n    }\n\n    /**\n     * Get the Registrator instance.\n     */\n\n  }, {\n    key: 'registrator',\n    value: function registrator() {\n      return this._registrator;\n    }\n\n    /**\n     * Registration state.\n     */\n\n  }, {\n    key: 'isRegistered',\n    value: function isRegistered() {\n      return this._registrator.registered;\n    }\n\n    /**\n     * Connection state.\n     */\n\n  }, {\n    key: 'isConnected',\n    value: function isConnected() {\n      return this._transport.isConnected();\n    }\n\n    /**\n     * Make an outgoing call.\n     *\n     * -param {String} target\n     * -param {Object} [options]\n     *\n     * -throws {TypeError}\n     *\n     */\n\n  }, {\n    key: 'call',\n    value: function call(target, options) {\n      debug('call()');\n\n      var session = new RTCSession(this);\n\n      session.connect(target, options);\n\n      return session;\n    }\n\n    /**\n     * Send a message.\n     *\n     * -param {String} target\n     * -param {String} body\n     * -param {Object} [options]\n     *\n     * -throws {TypeError}\n     *\n     */\n\n  }, {\n    key: 'sendMessage',\n    value: function sendMessage(target, body, options) {\n      debug('sendMessage()');\n\n      var message = new Message(this);\n\n      message.send(target, body, options);\n\n      return message;\n    }\n\n    /**\n     * Terminate ongoing sessions.\n     */\n\n  }, {\n    key: 'terminateSessions',\n    value: function terminateSessions(options) {\n      debug('terminateSessions()');\n\n      for (var idx in this._sessions) {\n        if (!this._sessions[idx].isEnded()) {\n          this._sessions[idx].terminate(options);\n        }\n      }\n    }\n\n    /**\n     * Gracefully close.\n     *\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      var _this2 = this;\n\n      debug('stop()');\n\n      // Remove dynamic settings.\n      this._dynConfiguration = {};\n\n      if (this._status === C.STATUS_USER_CLOSED) {\n        debug('UA already closed');\n\n        return;\n      }\n\n      // Close registrator.\n      this._registrator.close();\n\n      // If there are session wait a bit so CANCEL/BYE can be sent and their responses received.\n      var num_sessions = Object.keys(this._sessions).length;\n\n      // Run  _terminate_ on every Session.\n      for (var session in this._sessions) {\n        if (Object.prototype.hasOwnProperty.call(this._sessions, session)) {\n          debug('closing session ' + session);\n          try {\n            this._sessions[session].terminate();\n          } catch (error) {}\n        }\n      }\n\n      // Run  _close_ on every applicant.\n      for (var applicant in this._applicants) {\n        if (Object.prototype.hasOwnProperty.call(this._applicants, applicant)) try {\n          this._applicants[applicant].close();\n        } catch (error) {}\n      }\n\n      this._status = C.STATUS_USER_CLOSED;\n\n      var num_transactions = Object.keys(this._transactions.nict).length + Object.keys(this._transactions.nist).length + Object.keys(this._transactions.ict).length + Object.keys(this._transactions.ist).length;\n\n      if (num_transactions === 0 && num_sessions === 0) {\n        this._transport.disconnect();\n      } else {\n        this._closeTimer = setTimeout(function () {\n          _this2._closeTimer = null;\n          _this2._transport.disconnect();\n        }, 2000);\n      }\n    }\n\n    /**\n     * Normalice a string into a valid SIP request URI\n     * -param {String} target\n     * -returns {JsSIP.URI|undefined}\n     */\n\n  }, {\n    key: 'normalizeTarget',\n    value: function normalizeTarget(target) {\n      return Utils.normalizeTarget(target, this._configuration.hostport_params);\n    }\n\n    /**\n     * Allow retrieving configuration and autogenerated fields in runtime.\n     */\n\n  }, {\n    key: 'get',\n    value: function get(parameter) {\n      switch (parameter) {\n        case 'realm':\n          return this._configuration.realm;\n\n        case 'ha1':\n          return this._configuration.ha1;\n\n        default:\n          debugerror('get() | cannot get \"%s\" parameter in runtime', parameter);\n\n          return undefined;\n      }\n    }\n\n    /**\n     * Allow configuration changes in runtime.\n     * Returns true if the parameter could be set.\n     */\n\n  }, {\n    key: 'set',\n    value: function set(parameter, value) {\n      switch (parameter) {\n        case 'password':\n          {\n            this._configuration.password = String(value);\n            break;\n          }\n\n        case 'realm':\n          {\n            this._configuration.realm = String(value);\n            break;\n          }\n\n        case 'ha1':\n          {\n            this._configuration.ha1 = String(value);\n            // Delete the plain SIP password.\n            this._configuration.password = null;\n            break;\n          }\n\n        case 'display_name':\n          {\n            if (Grammar.parse('\"' + value + '\"', 'display_name') === -1) {\n              debugerror('set() | wrong \"display_name\"');\n\n              return false;\n            }\n            this._configuration.display_name = value;\n            break;\n          }\n\n        default:\n          debugerror('set() | cannot set \"%s\" parameter in runtime', parameter);\n\n          return false;\n      }\n\n      return true;\n    }\n\n    // ==========================\n    // Event Handlers.\n    // ==========================\n\n    /**\n     * new Transaction\n     */\n\n  }, {\n    key: 'newTransaction',\n    value: function newTransaction(transaction) {\n      this._transactions[transaction.type][transaction.id] = transaction;\n      this.emit('newTransaction', {\n        transaction: transaction\n      });\n    }\n\n    /**\n     * Transaction destroyed.\n     */\n\n  }, {\n    key: 'destroyTransaction',\n    value: function destroyTransaction(transaction) {\n      delete this._transactions[transaction.type][transaction.id];\n      this.emit('transactionDestroyed', {\n        transaction: transaction\n      });\n    }\n\n    /**\n     * new Dialog\n     */\n\n  }, {\n    key: 'newDialog',\n    value: function newDialog(dialog) {\n      this._dialogs[dialog.id] = dialog;\n    }\n\n    /**\n     * Dialog destroyed.\n     */\n\n  }, {\n    key: 'destroyDialog',\n    value: function destroyDialog(dialog) {\n      delete this._dialogs[dialog.id];\n    }\n\n    /**\n     *  new Message\n     */\n\n  }, {\n    key: 'newMessage',\n    value: function newMessage(message, data) {\n      this._applicants[message] = message;\n      this.emit('newMessage', data);\n    }\n\n    /**\n     *  Message destroyed.\n     */\n\n  }, {\n    key: 'destroyMessage',\n    value: function destroyMessage(message) {\n      delete this._applicants[message];\n    }\n\n    /**\n     * new RTCSession\n     */\n\n  }, {\n    key: 'newRTCSession',\n    value: function newRTCSession(session, data) {\n      this._sessions[session.id] = session;\n      this.emit('newRTCSession', data);\n    }\n\n    /**\n     * RTCSession destroyed.\n     */\n\n  }, {\n    key: 'destroyRTCSession',\n    value: function destroyRTCSession(session) {\n      delete this._sessions[session.id];\n    }\n\n    /**\n     * Registered\n     */\n\n  }, {\n    key: 'registered',\n    value: function registered(data) {\n      this.emit('registered', data);\n    }\n\n    /**\n     * Unregistered\n     */\n\n  }, {\n    key: 'unregistered',\n    value: function unregistered(data) {\n      this.emit('unregistered', data);\n    }\n\n    /**\n     * Registration Failed\n     */\n\n  }, {\n    key: 'registrationFailed',\n    value: function registrationFailed(data) {\n      this.emit('registrationFailed', data);\n    }\n\n    // =========================\n    // ReceiveRequest.\n    // =========================\n\n    /**\n     * Request reception\n     */\n\n  }, {\n    key: 'receiveRequest',\n    value: function receiveRequest(request) {\n      var method = request.method;\n\n      // Check that request URI points to us.\n      if (request.ruri.user !== this._configuration.uri.user && request.ruri.user !== this._contact.uri.user) {\n        debug('Request-URI does not point to us');\n        if (request.method !== JsSIP_C.ACK) {\n          request.reply_sl(404);\n        }\n\n        return;\n      }\n\n      // Check request URI scheme.\n      if (request.ruri.scheme === JsSIP_C.SIPS) {\n        request.reply_sl(416);\n\n        return;\n      }\n\n      // Check transaction.\n      if (Transactions.checkTransaction(this, request)) {\n        return;\n      }\n\n      // Create the server transaction.\n      if (method === JsSIP_C.INVITE) {\n        /* eslint-disable no-new */\n        new Transactions.InviteServerTransaction(this, this._transport, request);\n        /* eslint-enable no-new */\n      } else if (method !== JsSIP_C.ACK && method !== JsSIP_C.CANCEL) {\n        /* eslint-disable no-new */\n        new Transactions.NonInviteServerTransaction(this, this._transport, request);\n        /* eslint-enable no-new */\n      }\n\n      /* RFC3261 12.2.2\n       * Requests that do not change in any way the state of a dialog may be\n       * received within a dialog (for example, an OPTIONS request).\n       * They are processed as if they had been received outside the dialog.\n       */\n      if (method === JsSIP_C.OPTIONS) {\n        request.reply(200);\n      } else if (method === JsSIP_C.MESSAGE) {\n        if (this.listeners('newMessage').length === 0) {\n          request.reply(405);\n\n          return;\n        }\n        var message = new Message(this);\n\n        message.init_incoming(request);\n      } else if (method === JsSIP_C.INVITE) {\n        // Initial INVITE.\n        if (!request.to_tag && this.listeners('newRTCSession').length === 0) {\n          request.reply(405);\n\n          return;\n        }\n      }\n\n      var dialog = void 0;\n      var session = void 0;\n\n      // Initial Request.\n      if (!request.to_tag) {\n        switch (method) {\n          case JsSIP_C.INVITE:\n            if (window.RTCPeerConnection) {\n              // TODO\n              if (request.hasHeader('replaces')) {\n                var replaces = request.replaces;\n\n                dialog = this._findDialog(replaces.call_id, replaces.from_tag, replaces.to_tag);\n                if (dialog) {\n                  session = dialog.owner;\n                  if (!session.isEnded()) {\n                    session.receiveRequest(request);\n                  } else {\n                    request.reply(603);\n                  }\n                } else {\n                  request.reply(481);\n                }\n              } else {\n                session = new RTCSession(this);\n                session.init_incoming(request);\n              }\n            } else {\n              debugerror('INVITE received but WebRTC is not supported');\n              request.reply(488);\n            }\n            break;\n          case JsSIP_C.BYE:\n            // Out of dialog BYE received.\n            request.reply(481);\n            break;\n          case JsSIP_C.CANCEL:\n            session = this._findSession(request);\n            if (session) {\n              session.receiveRequest(request);\n            } else {\n              debug('received CANCEL request for a non existent session');\n            }\n            break;\n          case JsSIP_C.ACK:\n            /* Absorb it.\n             * ACK request without a corresponding Invite Transaction\n             * and without To tag.\n             */\n            break;\n          default:\n            request.reply(405);\n            break;\n        }\n      }\n      // In-dialog request.\n      else {\n          dialog = this._findDialog(request.call_id, request.from_tag, request.to_tag);\n\n          if (dialog) {\n            dialog.receiveRequest(request);\n          } else if (method === JsSIP_C.NOTIFY) {\n            session = this._findSession(request);\n            if (session) {\n              session.receiveRequest(request);\n            } else {\n              debug('received NOTIFY request for a non existent subscription');\n              request.reply(481, 'Subscription does not exist');\n            }\n          }\n\n          /* RFC3261 12.2.2\n           * Request with to tag, but no matching dialog found.\n           * Exception: ACK for an Invite request for which a dialog has not\n           * been created.\n           */\n          else if (method !== JsSIP_C.ACK) {\n              request.reply(481);\n            }\n        }\n    }\n\n    // =================\n    // Utils.\n    // =================\n\n    /**\n     * Get the session to which the request belongs to, if any.\n     */\n\n  }, {\n    key: '_findSession',\n    value: function _findSession(_ref) {\n      var call_id = _ref.call_id,\n          from_tag = _ref.from_tag,\n          to_tag = _ref.to_tag;\n\n      var sessionIDa = call_id + from_tag;\n      var sessionA = this._sessions[sessionIDa];\n      var sessionIDb = call_id + to_tag;\n      var sessionB = this._sessions[sessionIDb];\n\n      if (sessionA) {\n        return sessionA;\n      } else if (sessionB) {\n        return sessionB;\n      } else {\n        return null;\n      }\n    }\n\n    /**\n     * Get the dialog to which the request belongs to, if any.\n     */\n\n  }, {\n    key: '_findDialog',\n    value: function _findDialog(call_id, from_tag, to_tag) {\n      var id = call_id + from_tag + to_tag;\n      var dialog = this._dialogs[id];\n\n      if (dialog) {\n        return dialog;\n      } else {\n        id = call_id + to_tag + from_tag;\n        dialog = this._dialogs[id];\n        if (dialog) {\n          return dialog;\n        } else {\n          return null;\n        }\n      }\n    }\n  }, {\n    key: '_loadConfig',\n    value: function _loadConfig(configuration) {\n      // Check and load the given configuration.\n      try {\n        config.load(this._configuration, configuration);\n      } catch (e) {\n        throw e;\n      }\n\n      // Post Configuration Process.\n\n      // Allow passing 0 number as display_name.\n      if (this._configuration.display_name === 0) {\n        this._configuration.display_name = '0';\n      }\n\n      // Instance-id for GRUU.\n      if (!this._configuration.instance_id) {\n        this._configuration.instance_id = Utils.newUUID();\n      }\n\n      // Jssip_id instance parameter. Static random tag of length 5.\n      this._configuration.jssip_id = Utils.createRandomToken(5);\n\n      // String containing this._configuration.uri without scheme and user.\n      var hostport_params = this._configuration.uri.clone();\n\n      hostport_params.user = null;\n      this._configuration.hostport_params = hostport_params.toString().replace(/^sip:/i, '');\n\n      // Transport.\n      try {\n        this._transport = new Transport(this._configuration.sockets, {\n          // Recovery options.\n          max_interval: this._configuration.connection_recovery_max_interval,\n          min_interval: this._configuration.connection_recovery_min_interval\n        });\n\n        // Transport event callbacks.\n        this._transport.onconnecting = onTransportConnecting.bind(this);\n        this._transport.onconnect = onTransportConnect.bind(this);\n        this._transport.ondisconnect = onTransportDisconnect.bind(this);\n        this._transport.ondata = onTransportData.bind(this);\n      } catch (e) {\n        debugerror(e);\n        throw new Exceptions.ConfigurationError('sockets', this._configuration.sockets);\n      }\n\n      // Remove sockets instance from configuration object.\n      delete this._configuration.sockets;\n\n      // Check whether authorization_user is explicitly defined.\n      // Take 'this._configuration.uri.user' value if not.\n      if (!this._configuration.authorization_user) {\n        this._configuration.authorization_user = this._configuration.uri.user;\n      }\n\n      // If no 'registrar_server' is set use the 'uri' value without user portion and\n      // without URI params/headers.\n      if (!this._configuration.registrar_server) {\n        var registrar_server = this._configuration.uri.clone();\n\n        registrar_server.user = null;\n        registrar_server.clearParams();\n        registrar_server.clearHeaders();\n        this._configuration.registrar_server = registrar_server;\n      }\n\n      // User no_answer_timeout.\n      this._configuration.no_answer_timeout *= 1000;\n\n      // Via Host.\n      if (this._configuration.contact_uri) {\n        this._configuration.via_host = this._configuration.contact_uri.host;\n      }\n\n      // Contact URI.\n      else {\n          this._configuration.contact_uri = new URI('sip', Utils.createRandomToken(8), this._configuration.via_host, null, { transport: 'ws' });\n        }\n\n      this._contact = {\n        pub_gruu: null,\n        temp_gruu: null,\n        uri: this._configuration.contact_uri,\n        toString: function toString() {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          var anonymous = options.anonymous || null;\n          var outbound = options.outbound || null;\n          var contact = '<';\n\n          if (anonymous) {\n            contact += this.temp_gruu || 'sip:anonymous@anonymous.invalid;transport=ws';\n          } else {\n            contact += this.pub_gruu || this.uri.toString();\n          }\n\n          if (outbound && (anonymous ? !this.temp_gruu : !this.pub_gruu)) {\n            contact += ';ob';\n          }\n\n          contact += '>';\n\n          return contact;\n        }\n      };\n\n      // Seal the configuration.\n      var writable_parameters = ['password', 'realm', 'ha1', 'display_name', 'register'];\n\n      for (var parameter in this._configuration) {\n        if (Object.prototype.hasOwnProperty.call(this._configuration, parameter)) {\n          if (writable_parameters.indexOf(parameter) !== -1) {\n            Object.defineProperty(this._configuration, parameter, {\n              writable: true,\n              configurable: false\n            });\n          } else {\n            Object.defineProperty(this._configuration, parameter, {\n              writable: false,\n              configurable: false\n            });\n          }\n        }\n      }\n\n      debug('configuration parameters after validation:');\n      for (var _parameter in this._configuration) {\n        // Only show the user user configurable parameters.\n        if (Object.prototype.hasOwnProperty.call(config.settings, _parameter)) {\n          switch (_parameter) {\n            case 'uri':\n            case 'registrar_server':\n              debug('- ' + _parameter + ': ' + this._configuration[_parameter]);\n              break;\n            case 'password':\n            case 'ha1':\n              debug('- ' + _parameter + ': NOT SHOWN');\n              break;\n            default:\n              debug('- ' + _parameter + ': ' + JSON.stringify(this._configuration[_parameter]));\n          }\n        }\n      }\n\n      return;\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n  }, {\n    key: 'status',\n    get: function get() {\n      return this._status;\n    }\n  }, {\n    key: 'contact',\n    get: function get() {\n      return this._contact;\n    }\n  }, {\n    key: 'configuration',\n    get: function get() {\n      return this._configuration;\n    }\n  }, {\n    key: 'transport',\n    get: function get() {\n      return this._transport;\n    }\n  }]);\n\n  return UA;\n}(EventEmitter);\n\n/**\n * Transport event handlers\n */\n\n// Transport connecting event.\nfunction onTransportConnecting(data) {\n  this.emit('connecting', data);\n}\n\n// Transport connected event.\nfunction onTransportConnect(data) {\n  if (this._status === C.STATUS_USER_CLOSED) {\n    return;\n  }\n\n  this._status = C.STATUS_READY;\n  this._error = null;\n\n  this.emit('connected', data);\n\n  if (this._dynConfiguration.register) {\n    this._registrator.register();\n  }\n}\n\n// Transport disconnected event.\nfunction onTransportDisconnect(data) {\n  // Run _onTransportError_ callback on every client transaction using _transport_.\n  var client_transactions = ['nict', 'ict', 'nist', 'ist'];\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = client_transactions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var type = _step.value;\n\n      for (var id in this._transactions[type]) {\n        if (Object.prototype.hasOwnProperty.call(this._transactions[type], id)) {\n          this._transactions[type][id].onTransportError();\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  this.emit('disconnected', data);\n\n  // Call registrator _onTransportClosed_.\n  this._registrator.onTransportClosed();\n\n  if (this._status !== C.STATUS_USER_CLOSED) {\n    this._status = C.STATUS_NOT_READY;\n    this._error = C.NETWORK_ERROR;\n  }\n}\n\n// Transport data event.\nfunction onTransportData(data) {\n  var transport = data.transport;\n  var message = data.message;\n\n  message = Parser.parseMessage(message, this);\n\n  if (!message) {\n    return;\n  }\n\n  if (this._status === C.STATUS_USER_CLOSED && message instanceof SIPMessage.IncomingRequest) {\n    return;\n  }\n\n  // Do some sanity check.\n  if (!sanityCheck(message, this, transport)) {\n    return;\n  }\n\n  if (message instanceof SIPMessage.IncomingRequest) {\n    message.transport = transport;\n    this.receiveRequest(message);\n  } else if (message instanceof SIPMessage.IncomingResponse) {\n    /* Unike stated in 18.1.2, if a response does not match\n    * any transaction, it is discarded here and no passed to the core\n    * in order to be discarded there.\n    */\n\n    var transaction = void 0;\n\n    switch (message.method) {\n      case JsSIP_C.INVITE:\n        transaction = this._transactions.ict[message.via_branch];\n        if (transaction) {\n          transaction.receiveResponse(message);\n        }\n        break;\n      case JsSIP_C.ACK:\n        // Just in case ;-).\n        break;\n      default:\n        transaction = this._transactions.nict[message.via_branch];\n        if (transaction) {\n          transaction.receiveResponse(message);\n        }\n        break;\n    }\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/UA.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/URI.js":
/*!*******************************************!*\
  !*** ./node_modules/jssip/lib-es5/URI.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib-es5/Grammar.js\");\n\n/**\n * -param {String} [scheme]\n * -param {String} [user]\n * -param {String} host\n * -param {String} [port]\n * -param {Object} [parameters]\n * -param {Object} [headers]\n *\n */\nmodule.exports = function () {\n  _createClass(URI, null, [{\n    key: 'parse',\n\n    /**\n      * Parse the given string and returns a JsSIP.URI instance or undefined if\n      * it is an invalid URI.\n      */\n    value: function parse(uri) {\n      uri = Grammar.parse(uri, 'SIP_URI');\n\n      if (uri !== -1) {\n        return uri;\n      } else {\n        return undefined;\n      }\n    }\n  }]);\n\n  function URI(scheme, user, host, port) {\n    var parameters = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var headers = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n    _classCallCheck(this, URI);\n\n    // Checks.\n    if (!host) {\n      throw new TypeError('missing or invalid \"host\" parameter');\n    }\n\n    // Initialize parameters.\n    this._parameters = {};\n    this._headers = {};\n\n    this._scheme = scheme || JsSIP_C.SIP;\n    this._user = user;\n    this._host = host;\n    this._port = port;\n\n    for (var param in parameters) {\n      if (Object.prototype.hasOwnProperty.call(parameters, param)) {\n        this.setParam(param, parameters[param]);\n      }\n    }\n\n    for (var header in headers) {\n      if (Object.prototype.hasOwnProperty.call(headers, header)) {\n        this.setHeader(header, headers[header]);\n      }\n    }\n  }\n\n  _createClass(URI, [{\n    key: 'setParam',\n    value: function setParam(key, value) {\n      if (key) {\n        this._parameters[key.toLowerCase()] = typeof value === 'undefined' || value === null ? null : value.toString();\n      }\n    }\n  }, {\n    key: 'getParam',\n    value: function getParam(key) {\n      if (key) {\n        return this._parameters[key.toLowerCase()];\n      }\n    }\n  }, {\n    key: 'hasParam',\n    value: function hasParam(key) {\n      if (key) {\n        return this._parameters.hasOwnProperty(key.toLowerCase()) && true || false;\n      }\n    }\n  }, {\n    key: 'deleteParam',\n    value: function deleteParam(parameter) {\n      parameter = parameter.toLowerCase();\n      if (this._parameters.hasOwnProperty(parameter)) {\n        var value = this._parameters[parameter];\n\n        delete this._parameters[parameter];\n\n        return value;\n      }\n    }\n  }, {\n    key: 'clearParams',\n    value: function clearParams() {\n      this._parameters = {};\n    }\n  }, {\n    key: 'setHeader',\n    value: function setHeader(name, value) {\n      this._headers[Utils.headerize(name)] = Array.isArray(value) ? value : [value];\n    }\n  }, {\n    key: 'getHeader',\n    value: function getHeader(name) {\n      if (name) {\n        return this._headers[Utils.headerize(name)];\n      }\n    }\n  }, {\n    key: 'hasHeader',\n    value: function hasHeader(name) {\n      if (name) {\n        return this._headers.hasOwnProperty(Utils.headerize(name)) && true || false;\n      }\n    }\n  }, {\n    key: 'deleteHeader',\n    value: function deleteHeader(header) {\n      header = Utils.headerize(header);\n      if (this._headers.hasOwnProperty(header)) {\n        var value = this._headers[header];\n\n        delete this._headers[header];\n\n        return value;\n      }\n    }\n  }, {\n    key: 'clearHeaders',\n    value: function clearHeaders() {\n      this._headers = {};\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      return new URI(this._scheme, this._user, this._host, this._port, JSON.parse(JSON.stringify(this._parameters)), JSON.parse(JSON.stringify(this._headers)));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var headers = [];\n\n      var uri = this._scheme + ':';\n\n      if (this._user) {\n        uri += Utils.escapeUser(this._user) + '@';\n      }\n      uri += this._host;\n      if (this._port || this._port === 0) {\n        uri += ':' + this._port;\n      }\n\n      for (var parameter in this._parameters) {\n        if (Object.prototype.hasOwnProperty.call(this._parameters, parameter)) {\n          uri += ';' + parameter;\n\n          if (this._parameters[parameter] !== null) {\n            uri += '=' + this._parameters[parameter];\n          }\n        }\n      }\n\n      for (var header in this._headers) {\n        if (Object.prototype.hasOwnProperty.call(this._headers, header)) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = this._headers[header][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var item = _step.value;\n\n              headers.push(header + '=' + item);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      }\n\n      if (headers.length > 0) {\n        uri += '?' + headers.join('&');\n      }\n\n      return uri;\n    }\n  }, {\n    key: 'toAor',\n    value: function toAor(show_port) {\n      var aor = this._scheme + ':';\n\n      if (this._user) {\n        aor += Utils.escapeUser(this._user) + '@';\n      }\n      aor += this._host;\n      if (show_port && (this._port || this._port === 0)) {\n        aor += ':' + this._port;\n      }\n\n      return aor;\n    }\n  }, {\n    key: 'scheme',\n    get: function get() {\n      return this._scheme;\n    },\n    set: function set(value) {\n      this._scheme = value.toLowerCase();\n    }\n  }, {\n    key: 'user',\n    get: function get() {\n      return this._user;\n    },\n    set: function set(value) {\n      this._user = value;\n    }\n  }, {\n    key: 'host',\n    get: function get() {\n      return this._host;\n    },\n    set: function set(value) {\n      this._host = value.toLowerCase();\n    }\n  }, {\n    key: 'port',\n    get: function get() {\n      return this._port;\n    },\n    set: function set(value) {\n      this._port = value === 0 ? value : parseInt(value, 10) || null;\n    }\n  }]);\n\n  return URI;\n}();\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/URI.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/Utils.js":
/*!*********************************************!*\
  !*** ./node_modules/jssip/lib-es5/Utils.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar URI = __webpack_require__(/*! ./URI */ \"./node_modules/jssip/lib-es5/URI.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib-es5/Grammar.js\");\n\nexports.str_utf8_length = function (string) {\n  return unescape(encodeURIComponent(string)).length;\n};\n\n// Used by 'hasMethods'.\nvar isFunction = exports.isFunction = function (fn) {\n  if (fn !== undefined) {\n    return Object.prototype.toString.call(fn) === '[object Function]' ? true : false;\n  } else {\n    return false;\n  }\n};\n\nexports.isString = function (str) {\n  if (str !== undefined) {\n    return Object.prototype.toString.call(str) === '[object String]' ? true : false;\n  } else {\n    return false;\n  }\n};\n\nexports.isDecimal = function (num) {\n  return !isNaN(num) && parseFloat(num) === parseInt(num, 10);\n};\n\nexports.isEmpty = function (value) {\n  return value === null || value === '' || value === undefined || Array.isArray(value) && value.length === 0 || typeof value === 'number' && isNaN(value);\n};\n\nexports.hasMethods = function (obj) {\n  for (var _len = arguments.length, methodNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    methodNames[_key - 1] = arguments[_key];\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = methodNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var methodName = _step.value;\n\n      if (isFunction(obj[methodName])) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return true;\n};\n\n// Used by 'newTag'.\nvar createRandomToken = exports.createRandomToken = function (size) {\n  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n\n  var i = void 0,\n      r = void 0,\n      token = '';\n\n  for (i = 0; i < size; i++) {\n    r = Math.random() * base | 0;\n    token += r.toString(base);\n  }\n\n  return token;\n};\n\nexports.newTag = function () {\n  return createRandomToken(10);\n};\n\n// http://stackoverflow.com/users/109538/broofa.\nexports.newUUID = function () {\n  var UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n\n    return v.toString(16);\n  });\n\n  return UUID;\n};\n\nexports.hostType = function (host) {\n  if (!host) {\n    return;\n  } else {\n    host = Grammar.parse(host, 'host');\n    if (host !== -1) {\n      return host.host_type;\n    }\n  }\n};\n\n/**\n* Hex-escape a SIP URI user.\n* Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n*\n* Used by 'normalizeTarget'.\n*/\nvar escapeUser = exports.escapeUser = function (user) {\n  return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');\n};\n\n/**\n* Normalize SIP URI.\n* NOTE: It does not allow a SIP URI without username.\n* Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.\n* Detects the domain part (if given) and properly hex-escapes the user portion.\n* If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.\n*/\nexports.normalizeTarget = function (target, domain) {\n  // If no target is given then raise an error.\n  if (!target) {\n    return;\n    // If a URI instance is given then return it.\n  } else if (target instanceof URI) {\n    return target;\n\n    // If a string is given split it by '@':\n    // - Last fragment is the desired domain.\n    // - Otherwise append the given domain argument.\n  } else if (typeof target === 'string') {\n    var target_array = target.split('@');\n    var target_user = void 0;\n    var target_domain = void 0;\n\n    switch (target_array.length) {\n      case 1:\n        if (!domain) {\n          return;\n        }\n        target_user = target;\n        target_domain = domain;\n        break;\n      case 2:\n        target_user = target_array[0];\n        target_domain = target_array[1];\n        break;\n      default:\n        target_user = target_array.slice(0, target_array.length - 1).join('@');\n        target_domain = target_array[target_array.length - 1];\n    }\n\n    // Remove the URI scheme (if present).\n    target_user = target_user.replace(/^(sips?|tel):/i, '');\n\n    // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.\n    if (/^[-.()]*\\+?[0-9\\-.()]+$/.test(target_user)) {\n      target_user = target_user.replace(/[-.()]/g, '');\n    }\n\n    // Build the complete SIP URI.\n    target = JsSIP_C.SIP + ':' + escapeUser(target_user) + '@' + target_domain;\n\n    // Finally parse the resulting URI.\n    var uri = void 0;\n\n    if (uri = URI.parse(target)) {\n      return uri;\n    } else {\n      return;\n    }\n  } else {\n    return;\n  }\n};\n\nexports.headerize = function (string) {\n  var exceptions = {\n    'Call-Id': 'Call-ID',\n    'Cseq': 'CSeq',\n    'Www-Authenticate': 'WWW-Authenticate'\n  };\n\n  var name = string.toLowerCase().replace(/_/g, '-').split('-');\n  var hname = '';\n  var parts = name.length;\n  var part = void 0;\n\n  for (part = 0; part < parts; part++) {\n    if (part !== 0) {\n      hname += '-';\n    }\n    hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);\n  }\n  if (exceptions[hname]) {\n    hname = exceptions[hname];\n  }\n\n  return hname;\n};\n\nexports.sipErrorCause = function (status_code) {\n  for (var cause in JsSIP_C.SIP_ERROR_CAUSES) {\n    if (JsSIP_C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {\n      return JsSIP_C.causes[cause];\n    }\n  }\n\n  return JsSIP_C.causes.SIP_FAILURE_CODE;\n};\n\n/**\n* Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n*/\nexports.getRandomTestNetIP = function () {\n  function getOctet(from, to) {\n    return Math.floor(Math.random() * (to - from + 1) + from);\n  }\n\n  return '192.0.2.' + getOctet(1, 254);\n};\n\n// MD5 (Message-Digest Algorithm) http://www.webtoolkit.info.\nexports.calculateMD5 = function (string) {\n  function rotateLeft(lValue, iShiftBits) {\n    return lValue << iShiftBits | lValue >>> 32 - iShiftBits;\n  }\n\n  function addUnsigned(lX, lY) {\n    var lX8 = lX & 0x80000000;\n    var lY8 = lY & 0x80000000;\n    var lX4 = lX & 0x40000000;\n    var lY4 = lY & 0x40000000;\n    var lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);\n\n    if (lX4 & lY4) {\n      return lResult ^ 0x80000000 ^ lX8 ^ lY8;\n    }\n    if (lX4 | lY4) {\n      if (lResult & 0x40000000) {\n        return lResult ^ 0xC0000000 ^ lX8 ^ lY8;\n      } else {\n        return lResult ^ 0x40000000 ^ lX8 ^ lY8;\n      }\n    } else {\n      return lResult ^ lX8 ^ lY8;\n    }\n  }\n\n  function doF(x, y, z) {\n    return x & y | ~x & z;\n  }\n\n  function doG(x, y, z) {\n    return x & z | y & ~z;\n  }\n\n  function doH(x, y, z) {\n    return x ^ y ^ z;\n  }\n\n  function doI(x, y, z) {\n    return y ^ (x | ~z);\n  }\n\n  function doFF(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doF(b, c, d), x), ac));\n\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function doGG(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doG(b, c, d), x), ac));\n\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function doHH(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doH(b, c, d), x), ac));\n\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function doII(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doI(b, c, d), x), ac));\n\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function convertToWordArray(str) {\n    var lWordCount = void 0;\n    var lMessageLength = str.length;\n    var lNumberOfWords_temp1 = lMessageLength + 8;\n    var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64;\n    var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;\n    var lWordArray = new Array(lNumberOfWords - 1);\n    var lBytePosition = 0;\n    var lByteCount = 0;\n\n    while (lByteCount < lMessageLength) {\n      lWordCount = (lByteCount - lByteCount % 4) / 4;\n      lBytePosition = lByteCount % 4 * 8;\n      lWordArray[lWordCount] = lWordArray[lWordCount] | str.charCodeAt(lByteCount) << lBytePosition;\n      lByteCount++;\n    }\n    lWordCount = (lByteCount - lByteCount % 4) / 4;\n    lBytePosition = lByteCount % 4 * 8;\n    lWordArray[lWordCount] = lWordArray[lWordCount] | 0x80 << lBytePosition;\n    lWordArray[lNumberOfWords - 2] = lMessageLength << 3;\n    lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;\n\n    return lWordArray;\n  }\n\n  function wordToHex(lValue) {\n    var wordToHexValue = '',\n        wordToHexValue_temp = '',\n        lByte = void 0,\n        lCount = void 0;\n\n    for (lCount = 0; lCount <= 3; lCount++) {\n      lByte = lValue >>> lCount * 8 & 255;\n      wordToHexValue_temp = '0' + lByte.toString(16);\n      wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);\n    }\n\n    return wordToHexValue;\n  }\n\n  function utf8Encode(str) {\n    str = str.replace(/\\r\\n/g, '\\n');\n    var utftext = '';\n\n    for (var n = 0; n < str.length; n++) {\n      var _c = str.charCodeAt(n);\n\n      if (_c < 128) {\n        utftext += String.fromCharCode(_c);\n      } else if (_c > 127 && _c < 2048) {\n        utftext += String.fromCharCode(_c >> 6 | 192);\n        utftext += String.fromCharCode(_c & 63 | 128);\n      } else {\n        utftext += String.fromCharCode(_c >> 12 | 224);\n        utftext += String.fromCharCode(_c >> 6 & 63 | 128);\n        utftext += String.fromCharCode(_c & 63 | 128);\n      }\n    }\n\n    return utftext;\n  }\n\n  var x = [];\n  var k = void 0,\n      AA = void 0,\n      BB = void 0,\n      CC = void 0,\n      DD = void 0,\n      a = void 0,\n      b = void 0,\n      c = void 0,\n      d = void 0;\n  var S11 = 7,\n      S12 = 12,\n      S13 = 17,\n      S14 = 22;\n  var S21 = 5,\n      S22 = 9,\n      S23 = 14,\n      S24 = 20;\n  var S31 = 4,\n      S32 = 11,\n      S33 = 16,\n      S34 = 23;\n  var S41 = 6,\n      S42 = 10,\n      S43 = 15,\n      S44 = 21;\n\n  string = utf8Encode(string);\n\n  x = convertToWordArray(string);\n\n  a = 0x67452301;b = 0xEFCDAB89;c = 0x98BADCFE;d = 0x10325476;\n\n  for (k = 0; k < x.length; k += 16) {\n    AA = a;BB = b;CC = c;DD = d;\n    a = doFF(a, b, c, d, x[k + 0], S11, 0xD76AA478);\n    d = doFF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);\n    c = doFF(c, d, a, b, x[k + 2], S13, 0x242070DB);\n    b = doFF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);\n    a = doFF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);\n    d = doFF(d, a, b, c, x[k + 5], S12, 0x4787C62A);\n    c = doFF(c, d, a, b, x[k + 6], S13, 0xA8304613);\n    b = doFF(b, c, d, a, x[k + 7], S14, 0xFD469501);\n    a = doFF(a, b, c, d, x[k + 8], S11, 0x698098D8);\n    d = doFF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);\n    c = doFF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);\n    b = doFF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);\n    a = doFF(a, b, c, d, x[k + 12], S11, 0x6B901122);\n    d = doFF(d, a, b, c, x[k + 13], S12, 0xFD987193);\n    c = doFF(c, d, a, b, x[k + 14], S13, 0xA679438E);\n    b = doFF(b, c, d, a, x[k + 15], S14, 0x49B40821);\n    a = doGG(a, b, c, d, x[k + 1], S21, 0xF61E2562);\n    d = doGG(d, a, b, c, x[k + 6], S22, 0xC040B340);\n    c = doGG(c, d, a, b, x[k + 11], S23, 0x265E5A51);\n    b = doGG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);\n    a = doGG(a, b, c, d, x[k + 5], S21, 0xD62F105D);\n    d = doGG(d, a, b, c, x[k + 10], S22, 0x2441453);\n    c = doGG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);\n    b = doGG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);\n    a = doGG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);\n    d = doGG(d, a, b, c, x[k + 14], S22, 0xC33707D6);\n    c = doGG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);\n    b = doGG(b, c, d, a, x[k + 8], S24, 0x455A14ED);\n    a = doGG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);\n    d = doGG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);\n    c = doGG(c, d, a, b, x[k + 7], S23, 0x676F02D9);\n    b = doGG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);\n    a = doHH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);\n    d = doHH(d, a, b, c, x[k + 8], S32, 0x8771F681);\n    c = doHH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);\n    b = doHH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);\n    a = doHH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);\n    d = doHH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);\n    c = doHH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);\n    b = doHH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);\n    a = doHH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);\n    d = doHH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);\n    c = doHH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);\n    b = doHH(b, c, d, a, x[k + 6], S34, 0x4881D05);\n    a = doHH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);\n    d = doHH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);\n    c = doHH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);\n    b = doHH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);\n    a = doII(a, b, c, d, x[k + 0], S41, 0xF4292244);\n    d = doII(d, a, b, c, x[k + 7], S42, 0x432AFF97);\n    c = doII(c, d, a, b, x[k + 14], S43, 0xAB9423A7);\n    b = doII(b, c, d, a, x[k + 5], S44, 0xFC93A039);\n    a = doII(a, b, c, d, x[k + 12], S41, 0x655B59C3);\n    d = doII(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);\n    c = doII(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);\n    b = doII(b, c, d, a, x[k + 1], S44, 0x85845DD1);\n    a = doII(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);\n    d = doII(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);\n    c = doII(c, d, a, b, x[k + 6], S43, 0xA3014314);\n    b = doII(b, c, d, a, x[k + 13], S44, 0x4E0811A1);\n    a = doII(a, b, c, d, x[k + 4], S41, 0xF7537E82);\n    d = doII(d, a, b, c, x[k + 11], S42, 0xBD3AF235);\n    c = doII(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);\n    b = doII(b, c, d, a, x[k + 9], S44, 0xEB86D391);\n    a = addUnsigned(a, AA);\n    b = addUnsigned(b, BB);\n    c = addUnsigned(c, CC);\n    d = addUnsigned(d, DD);\n  }\n\n  var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);\n\n  return temp.toLowerCase();\n};\n\nexports.closeMediaStream = function (stream) {\n  if (!stream) {\n    return;\n  }\n\n  // Latest spec states that MediaStream has no stop() method and instead must\n  // call stop() on every MediaStreamTrack.\n  try {\n    var tracks = void 0;\n\n    if (stream.getTracks) {\n      tracks = stream.getTracks();\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = tracks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var track = _step2.value;\n\n          track.stop();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    } else {\n      tracks = stream.getAudioTracks();\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = tracks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _track = _step3.value;\n\n          _track.stop();\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      tracks = stream.getVideoTracks();\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = tracks[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _track2 = _step4.value;\n\n          _track2.stop();\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n  } catch (error) {\n    // Deprecated by the spec, but still in use.\n    // NOTE: In Temasys IE plugin stream.stop is a callable 'object'.\n    if (typeof stream.stop === 'function' || _typeof(stream.stop) === 'object') {\n      stream.stop();\n    }\n  }\n};\n\nexports.cloneArray = function (array) {\n  return array && array.slice() || [];\n};\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/Utils.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/WebSocketInterface.js":
/*!**********************************************************!*\
  !*** ./node_modules/jssip/lib-es5/WebSocketInterface.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./node_modules/jssip/lib-es5/Grammar.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:WebSocketInterface');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:ERROR:WebSocketInterface');\n\ndebugerror.log = console.warn.bind(console);\n\nmodule.exports = function () {\n  function WebSocketInterface(url) {\n    _classCallCheck(this, WebSocketInterface);\n\n    debug('new() [url:\"%s\"]', url);\n\n    this._url = url;\n    this._sip_uri = null;\n    this._via_transport = null;\n    this._ws = null;\n\n    var parsed_url = Grammar.parse(url, 'absoluteURI');\n\n    if (parsed_url === -1) {\n      debugerror('invalid WebSocket URI: ' + url);\n      throw new TypeError('Invalid argument: ' + url);\n    } else if (parsed_url.scheme !== 'wss' && parsed_url.scheme !== 'ws') {\n      debugerror('invalid WebSocket URI scheme: ' + parsed_url.scheme);\n      throw new TypeError('Invalid argument: ' + url);\n    } else {\n      this._sip_uri = 'sip:' + parsed_url.host + (parsed_url.port ? ':' + parsed_url.port : '') + ';transport=ws';\n      this._via_transport = parsed_url.scheme.toUpperCase();\n    }\n  }\n\n  _createClass(WebSocketInterface, [{\n    key: 'connect',\n    value: function connect() {\n      debug('connect()');\n\n      if (this.isConnected()) {\n        debug('WebSocket ' + this._url + ' is already connected');\n\n        return;\n      } else if (this.isConnecting()) {\n        debug('WebSocket ' + this._url + ' is connecting');\n\n        return;\n      }\n\n      if (this._ws) {\n        this.disconnect();\n      }\n\n      debug('connecting to WebSocket ' + this._url);\n\n      try {\n        this._ws = new WebSocket(this._url, 'sip');\n\n        this._ws.binaryType = 'arraybuffer';\n\n        this._ws.onopen = this._onOpen.bind(this);\n        this._ws.onclose = this._onClose.bind(this);\n        this._ws.onmessage = this._onMessage.bind(this);\n        this._ws.onerror = this._onError.bind(this);\n      } catch (e) {\n        this._onError(e);\n      }\n    }\n  }, {\n    key: 'disconnect',\n    value: function disconnect() {\n      debug('disconnect()');\n\n      if (this._ws) {\n        // Unbind websocket event callbacks.\n        this._ws.onopen = function () {};\n        this._ws.onclose = function () {};\n        this._ws.onmessage = function () {};\n        this._ws.onerror = function () {};\n\n        this._ws.close();\n        this._ws = null;\n      }\n    }\n  }, {\n    key: 'send',\n    value: function send(message) {\n      debug('send()');\n\n      if (this.isConnected()) {\n        this._ws.send(message);\n\n        return true;\n      } else {\n        debugerror('unable to send message, WebSocket is not open');\n\n        return false;\n      }\n    }\n  }, {\n    key: 'isConnected',\n    value: function isConnected() {\n      return this._ws && this._ws.readyState === this._ws.OPEN;\n    }\n  }, {\n    key: 'isConnecting',\n    value: function isConnecting() {\n      return this._ws && this._ws.readyState === this._ws.CONNECTING;\n    }\n\n    /**\n     * WebSocket Event Handlers\n     */\n\n  }, {\n    key: '_onOpen',\n    value: function _onOpen() {\n      debug('WebSocket ' + this._url + ' connected');\n\n      this.onconnect();\n    }\n  }, {\n    key: '_onClose',\n    value: function _onClose(_ref) {\n      var wasClean = _ref.wasClean,\n          code = _ref.code,\n          reason = _ref.reason;\n\n      debug('WebSocket ' + this._url + ' closed');\n\n      if (wasClean === false) {\n        debug('WebSocket abrupt disconnection');\n      }\n\n      var data = {\n        socket: this,\n        error: !wasClean,\n        code: code,\n        reason: reason\n      };\n\n      this.ondisconnect(data);\n    }\n  }, {\n    key: '_onMessage',\n    value: function _onMessage(_ref2) {\n      var data = _ref2.data;\n\n      debug('received WebSocket message');\n\n      this.ondata(data);\n    }\n  }, {\n    key: '_onError',\n    value: function _onError(e) {\n      debugerror('WebSocket ' + this._url + ' error: ' + e);\n    }\n  }, {\n    key: 'via_transport',\n    get: function get() {\n      return this._via_transport;\n    },\n    set: function set(value) {\n      this._via_transport = value.toUpperCase();\n    }\n  }, {\n    key: 'sip_uri',\n    get: function get() {\n      return this._sip_uri;\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      return this._url;\n    }\n  }]);\n\n  return WebSocketInterface;\n}();\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/WebSocketInterface.js?");

/***/ }),

/***/ "./node_modules/jssip/lib-es5/sanityCheck.js":
/*!***************************************************!*\
  !*** ./node_modules/jssip/lib-es5/sanityCheck.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar JsSIP_C = __webpack_require__(/*! ./Constants */ \"./node_modules/jssip/lib-es5/Constants.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./node_modules/jssip/lib-es5/SIPMessage.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/jssip/lib-es5/Utils.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/jssip/node_modules/debug/src/browser.js\")('JsSIP:sanityCheck');\n\n// Checks for requests and responses.\nvar all = [minimumHeaders];\n\n// Checks for requests.\nvar requests = [rfc3261_8_2_2_1, rfc3261_16_3_4, rfc3261_18_3_request, rfc3261_8_2_2_2];\n\n// Checks for responses.\nvar responses = [rfc3261_8_1_3_3, rfc3261_18_3_response];\n\n// local variables.\nvar message = void 0;\nvar ua = void 0;\nvar transport = void 0;\n\nmodule.exports = function (m, u, t) {\n  message = m;\n  ua = u;\n  transport = t;\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = all[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var check = _step.value;\n\n      if (check() === false) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (message instanceof SIPMessage.IncomingRequest) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = requests[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _check = _step2.value;\n\n        if (_check() === false) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  } else if (message instanceof SIPMessage.IncomingResponse) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = responses[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _check2 = _step3.value;\n\n        if (_check2() === false) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  }\n\n  // Everything is OK.\n  return true;\n};\n\n/*\n * Sanity Check for incoming Messages\n *\n * Requests:\n *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme\n *  - _rfc3261_16_3_4_ Receive a Request already sent by us\n *   Does not look at via sent-by but at jssip_id, which is inserted as\n *   a prefix in all initial requests generated by the ua\n *  - _rfc3261_18_3_request_ Body Content-Length\n *  - _rfc3261_8_2_2_2_ Merged Requests\n *\n * Responses:\n *  - _rfc3261_8_1_3_3_ Multiple Via headers\n *  - _rfc3261_18_3_response_ Body Content-Length\n *\n * All:\n *  - Minimum headers in a SIP message\n */\n\n// Sanity Check functions for requests.\nfunction rfc3261_8_2_2_1() {\n  if (message.s('to').uri.scheme !== 'sip') {\n    reply(416);\n\n    return false;\n  }\n}\n\nfunction rfc3261_16_3_4() {\n  if (!message.to_tag) {\n    if (message.call_id.substr(0, 5) === ua.configuration.jssip_id) {\n      reply(482);\n\n      return false;\n    }\n  }\n}\n\nfunction rfc3261_18_3_request() {\n  var len = Utils.str_utf8_length(message.body);\n  var contentLength = message.getHeader('content-length');\n\n  if (len < contentLength) {\n    reply(400);\n\n    return false;\n  }\n}\n\nfunction rfc3261_8_2_2_2() {\n  var fromTag = message.from_tag;\n  var call_id = message.call_id;\n  var cseq = message.cseq;\n  var tr = void 0;\n\n  // Accept any in-dialog request.\n  if (message.to_tag) {\n    return;\n  }\n\n  // INVITE request.\n  if (message.method === JsSIP_C.INVITE) {\n    // If the branch matches the key of any IST then assume it is a retransmission\n    // and ignore the INVITE.\n    // TODO: we should reply the last response.\n    if (ua._transactions.ist[message.via_branch]) {\n      return false;\n    }\n    // Otherwise check whether it is a merged request.\n    else {\n        for (var transaction in ua._transactions.ist) {\n          if (Object.prototype.hasOwnProperty.call(ua._transactions.ist, transaction)) {\n            tr = ua._transactions.ist[transaction];\n            if (tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n              reply(482);\n\n              return false;\n            }\n          }\n        }\n      }\n  }\n\n  // Non INVITE request.\n\n  // If the branch matches the key of any NIST then assume it is a retransmission\n  // and ignore the request.\n  // TODO: we should reply the last response.\n  else if (ua._transactions.nist[message.via_branch]) {\n      return false;\n    }\n\n    // Otherwise check whether it is a merged request.\n    else {\n        for (var _transaction in ua._transactions.nist) {\n          if (Object.prototype.hasOwnProperty.call(ua._transactions.nist, _transaction)) {\n            tr = ua._transactions.nist[_transaction];\n            if (tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n              reply(482);\n\n              return false;\n            }\n          }\n        }\n      }\n}\n\n// Sanity Check functions for responses.\nfunction rfc3261_8_1_3_3() {\n  if (message.getHeaders('via').length > 1) {\n    debug('more than one Via header field present in the response, dropping the response');\n\n    return false;\n  }\n}\n\nfunction rfc3261_18_3_response() {\n  var len = Utils.str_utf8_length(message.body),\n      contentLength = message.getHeader('content-length');\n\n  if (len < contentLength) {\n    debug('message body length is lower than the value in Content-Length header field, dropping the response');\n\n    return false;\n  }\n}\n\n// Sanity Check functions for requests and responses.\nfunction minimumHeaders() {\n  var mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'];\n\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = mandatoryHeaders[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var header = _step4.value;\n\n      if (!message.hasHeader(header)) {\n        debug('missing mandatory header field : ' + header + ', dropping the response');\n\n        return false;\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\n// Reply.\nfunction reply(status_code) {\n  var vias = message.getHeaders('via');\n\n  var to = void 0;\n  var response = 'SIP/2.0 ' + status_code + ' ' + JsSIP_C.REASON_PHRASE[status_code] + '\\r\\n';\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = vias[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var via = _step5.value;\n\n      response += 'Via: ' + via + '\\r\\n';\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  to = message.getHeader('To');\n\n  if (!message.to_tag) {\n    to += ';tag=' + Utils.newTag();\n  }\n\n  response += 'To: ' + to + '\\r\\n';\n  response += 'From: ' + message.getHeader('From') + '\\r\\n';\n  response += 'Call-ID: ' + message.call_id + '\\r\\n';\n  response += 'CSeq: ' + message.cseq + ' ' + message.method + '\\r\\n';\n  response += '\\r\\n';\n\n  transport.send(response);\n}\n\n//# sourceURL=webpack:///./node_modules/jssip/lib-es5/sanityCheck.js?");

/***/ }),

/***/ "./node_modules/jssip/node_modules/debug/src/browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/jssip/node_modules/debug/src/browser.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/jssip/node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||\n  // is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||\n  // is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||\n  // double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit');\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch (e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch (e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/jssip/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/jssip/node_modules/debug/src/debug.js":
/*!************************************************************!*\
  !*** ./node_modules/jssip/node_modules/debug/src/debug.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0,\n      i;\n\n  for (i in namespace) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy() {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n//# sourceURL=webpack:///./node_modules/jssip/node_modules/debug/src/debug.js?");

/***/ }),

/***/ "./node_modules/jssip/package.json":
/*!*****************************************!*\
  !*** ./node_modules/jssip/package.json ***!
  \*****************************************/
/*! exports provided: name, title, description, version, homepage, author, contributors, main, keywords, license, repository, bugs, dependencies, devDependencies, scripts, default */
/***/ (function(module) {

eval("module.exports = {\"name\":\"jssip\",\"title\":\"JsSIP\",\"description\":\"the Javascript SIP library\",\"version\":\"3.2.11\",\"homepage\":\"http://jssip.net\",\"author\":\"José Luis Millán <jmillan@aliax.net> (https://github.com/jmillan)\",\"contributors\":[\"Iñaki Baz Castillo <ibc@aliax.net> (https://github.com/ibc)\",\"Saúl Ibarra Corretgé <saghul@gmail.com> (https://github.com/saghul)\"],\"main\":\"lib-es5/JsSIP.js\",\"keywords\":[\"sip\",\"websocket\",\"webrtc\",\"node\",\"browser\",\"library\"],\"license\":\"MIT\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/versatica/JsSIP.git\"},\"bugs\":{\"url\":\"https://github.com/versatica/JsSIP/issues\"},\"dependencies\":{\"debug\":\"^3.1.0\",\"events\":\"^2.0.0\",\"sdp-transform\":\"^2.4.1\",\"webrtc-adapter\":\"^6.1.5\"},\"devDependencies\":{\"ansi-colors\":\"^1.1.0\",\"babel-core\":\"^6.26.0\",\"babel-preset-env\":\"^1.6.1\",\"browserify\":\"^16.2.0\",\"eslint\":\"^4.19.1\",\"fancy-log\":\"^1.3.2\",\"gulp\":\"^4.0.0\",\"gulp-babel\":\"^7.0.1\",\"gulp-eslint\":\"^4.0.2\",\"gulp-expect-file\":\"0.0.7\",\"gulp-header\":\"^2.0.5\",\"gulp-nodeunit-runner\":\"^0.2.2\",\"gulp-plumber\":\"^1.2.0\",\"gulp-rename\":\"^1.2.2\",\"gulp-uglify\":\"^3.0.0\",\"pegjs\":\"^0.7.0\",\"vinyl-buffer\":\"^1.0.1\",\"vinyl-source-stream\":\"^2.0.0\"},\"scripts\":{\"test\":\"gulp test\",\"prepublishOnly\":\"gulp babel\"}};\n\n//# sourceURL=webpack:///./node_modules/jssip/package.json?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n//# sourceURL=webpack:///./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js":
/*!******************************************************************!*\
  !*** ./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nvar SDPUtils = __webpack_require__(/*! sdp */ \"./node_modules/sdp/sdp.js\");\n\nfunction fixStatsType(stat) {\n  return {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  }[stat.type] || stat.type;\n}\n\nfunction writeMediaSection(transceiver, caps, type, stream, dtlsRole) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : dtlsRole || 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    var trackId = transceiver.rtpSender._initialTrackId || transceiver.rtpSender.track.id;\n    transceiver.rtpSender._initialTrackId = trackId;\n    // spec.\n    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' + trackId + '\\r\\n';\n    sdp += 'a=' + msid;\n    // for Chrome. Legacy should no longer be required.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;\n\n    // RTX\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n}\n\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function (server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function (url) {\n        var validTurn = url.indexOf('turn:') === 0 && url.indexOf('transport=udp') !== -1 && url.indexOf('turn:[') === -1 && !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 && url.indexOf('?transport=udp') === -1;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n}\n\n// Determines the intersection of local and remote capabilities.\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\n  var commonCapabilities = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: []\n  };\n\n  var findCodecByPayloadType = function (pt, codecs) {\n    pt = parseInt(pt, 10);\n    for (var i = 0; i < codecs.length; i++) {\n      if (codecs[i].payloadType === pt || codecs[i].preferredPayloadType === pt) {\n        return codecs[i];\n      }\n    }\n  };\n\n  var rtxCapabilityMatches = function (lRtx, rRtx, lCodecs, rCodecs) {\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\n    return lCodec && rCodec && lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\n  };\n\n  localCapabilities.codecs.forEach(function (lCodec) {\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n      var rCodec = remoteCapabilities.codecs[i];\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() && lCodec.clockRate === rCodec.clockRate) {\n        if (lCodec.name.toLowerCase() === 'rtx' && lCodec.parameters && rCodec.parameters.apt) {\n          // for RTX we need to find the local rtx that has a apt\n          // which points to the same local codec as the remote one.\n          if (!rtxCapabilityMatches(lCodec, rCodec, localCapabilities.codecs, remoteCapabilities.codecs)) {\n            continue;\n          }\n        }\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\n        // number of channels is the highest common number of channels\n        rCodec.numChannels = Math.min(lCodec.numChannels, rCodec.numChannels);\n        // push rCodec so we reply with offerer payload type\n        commonCapabilities.codecs.push(rCodec);\n\n        // determine common feedback mechanisms\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function (fb) {\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n            if (lCodec.rtcpFeedback[j].type === fb.type && lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n              return true;\n            }\n          }\n          return false;\n        });\n        // FIXME: also need to determine .parameters\n        //  see https://github.com/openpeer/ortc/issues/569\n        break;\n      }\n    }\n  });\n\n  localCapabilities.headerExtensions.forEach(function (lHeaderExtension) {\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length; i++) {\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\n        break;\n      }\n    }\n  });\n\n  // FIXME: fecMechanisms\n  return commonCapabilities;\n}\n\n// is action=setLocalDescription with type allowed in signalingState\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\n  return {\n    offer: {\n      setLocalDescription: ['stable', 'have-local-offer'],\n      setRemoteDescription: ['stable', 'have-remote-offer']\n    },\n    answer: {\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\n    }\n  }[type][action].indexOf(signalingState) !== -1;\n}\n\nfunction maybeAddCandidate(iceTransport, candidate) {\n  // Edge's internal representation adds some fields therefore\n  // not all fieldѕ are taken into account.\n  var alreadyAdded = iceTransport.getRemoteCandidates().find(function (remoteCandidate) {\n    return candidate.foundation === remoteCandidate.foundation && candidate.ip === remoteCandidate.ip && candidate.port === remoteCandidate.port && candidate.priority === remoteCandidate.priority && candidate.protocol === remoteCandidate.protocol && candidate.type === remoteCandidate.type;\n  });\n  if (!alreadyAdded) {\n    iceTransport.addRemoteCandidate(candidate);\n  }\n  return !alreadyAdded;\n}\n\nfunction makeError(name, description) {\n  var e = new Error(description);\n  e.name = name;\n  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names\n  e.code = {\n    NotSupportedError: 9,\n    InvalidStateError: 11,\n    InvalidAccessError: 15,\n    TypeError: undefined,\n    OperationError: undefined\n  }[name];\n  return e;\n}\n\nmodule.exports = function (window, edgeVersion) {\n  // https://w3c.github.io/mediacapture-main/#mediastream\n  // Helper function to add the track to the stream and\n  // dispatch the event ourselves.\n  function addTrackToStreamAndFireEvent(track, stream) {\n    stream.addTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack', { track: track }));\n  }\n\n  function removeTrackFromStreamAndFireEvent(track, stream) {\n    stream.removeTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack', { track: track }));\n  }\n\n  function fireAddTrack(pc, track, receiver, streams) {\n    var trackEvent = new Event('track');\n    trackEvent.track = track;\n    trackEvent.receiver = receiver;\n    trackEvent.transceiver = { receiver: receiver };\n    trackEvent.streams = streams;\n    window.setTimeout(function () {\n      pc._dispatchEvent('track', trackEvent);\n    });\n  }\n\n  var RTCPeerConnection = function (config) {\n    var pc = this;\n\n    var _eventTarget = document.createDocumentFragment();\n    ['addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(function (method) {\n      pc[method] = _eventTarget[method].bind(_eventTarget);\n    });\n\n    this.canTrickleIceCandidates = null;\n\n    this.needNegotiation = false;\n\n    this.localStreams = [];\n    this.remoteStreams = [];\n\n    this._localDescription = null;\n    this._remoteDescription = null;\n\n    this.signalingState = 'stable';\n    this.iceConnectionState = 'new';\n    this.connectionState = 'new';\n    this.iceGatheringState = 'new';\n\n    config = JSON.parse(JSON.stringify(config || {}));\n\n    this.usingBundle = config.bundlePolicy === 'max-bundle';\n    if (config.rtcpMuxPolicy === 'negotiate') {\n      throw makeError('NotSupportedError', 'rtcpMuxPolicy \\'negotiate\\' is not supported');\n    } else if (!config.rtcpMuxPolicy) {\n      config.rtcpMuxPolicy = 'require';\n    }\n\n    switch (config.iceTransportPolicy) {\n      case 'all':\n      case 'relay':\n        break;\n      default:\n        config.iceTransportPolicy = 'all';\n        break;\n    }\n\n    switch (config.bundlePolicy) {\n      case 'balanced':\n      case 'max-compat':\n      case 'max-bundle':\n        break;\n      default:\n        config.bundlePolicy = 'balanced';\n        break;\n    }\n\n    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);\n\n    this._iceGatherers = [];\n    if (config.iceCandidatePoolSize) {\n      for (var i = config.iceCandidatePoolSize; i > 0; i--) {\n        this._iceGatherers.push(new window.RTCIceGatherer({\n          iceServers: config.iceServers,\n          gatherPolicy: config.iceTransportPolicy\n        }));\n      }\n    } else {\n      config.iceCandidatePoolSize = 0;\n    }\n\n    this._config = config;\n\n    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n    // everything that is needed to describe a SDP m-line.\n    this.transceivers = [];\n\n    this._sdpSessionId = SDPUtils.generateSessionId();\n    this._sdpSessionVersion = 0;\n\n    this._dtlsRole = undefined; // role for a=setup to use in answers.\n\n    this._isClosed = false;\n  };\n\n  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {\n    configurable: true,\n    get: function () {\n      return this._localDescription;\n    }\n  });\n  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {\n    configurable: true,\n    get: function () {\n      return this._remoteDescription;\n    }\n  });\n\n  // set up event handlers on prototype\n  RTCPeerConnection.prototype.onicecandidate = null;\n  RTCPeerConnection.prototype.onaddstream = null;\n  RTCPeerConnection.prototype.ontrack = null;\n  RTCPeerConnection.prototype.onremovestream = null;\n  RTCPeerConnection.prototype.onsignalingstatechange = null;\n  RTCPeerConnection.prototype.oniceconnectionstatechange = null;\n  RTCPeerConnection.prototype.onconnectionstatechange = null;\n  RTCPeerConnection.prototype.onicegatheringstatechange = null;\n  RTCPeerConnection.prototype.onnegotiationneeded = null;\n  RTCPeerConnection.prototype.ondatachannel = null;\n\n  RTCPeerConnection.prototype._dispatchEvent = function (name, event) {\n    if (this._isClosed) {\n      return;\n    }\n    this.dispatchEvent(event);\n    if (typeof this['on' + name] === 'function') {\n      this['on' + name](event);\n    }\n  };\n\n  RTCPeerConnection.prototype._emitGatheringStateChange = function () {\n    var event = new Event('icegatheringstatechange');\n    this._dispatchEvent('icegatheringstatechange', event);\n  };\n\n  RTCPeerConnection.prototype.getConfiguration = function () {\n    return this._config;\n  };\n\n  RTCPeerConnection.prototype.getLocalStreams = function () {\n    return this.localStreams;\n  };\n\n  RTCPeerConnection.prototype.getRemoteStreams = function () {\n    return this.remoteStreams;\n  };\n\n  // internal helper to create a transceiver object.\n  // (which is not yet the same as the WebRTC 1.0 transceiver)\n  RTCPeerConnection.prototype._createTransceiver = function (kind, doNotAdd) {\n    var hasBundleTransport = this.transceivers.length > 0;\n    var transceiver = {\n      track: null,\n      iceGatherer: null,\n      iceTransport: null,\n      dtlsTransport: null,\n      localCapabilities: null,\n      remoteCapabilities: null,\n      rtpSender: null,\n      rtpReceiver: null,\n      kind: kind,\n      mid: null,\n      sendEncodingParameters: null,\n      recvEncodingParameters: null,\n      stream: null,\n      associatedRemoteMediaStreams: [],\n      wantReceive: true\n    };\n    if (this.usingBundle && hasBundleTransport) {\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\n    } else {\n      var transports = this._createIceAndDtlsTransports();\n      transceiver.iceTransport = transports.iceTransport;\n      transceiver.dtlsTransport = transports.dtlsTransport;\n    }\n    if (!doNotAdd) {\n      this.transceivers.push(transceiver);\n    }\n    return transceiver;\n  };\n\n  RTCPeerConnection.prototype.addTrack = function (track, stream) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError', 'Attempted to call addTrack on a closed peerconnection.');\n    }\n\n    var alreadyExists = this.transceivers.find(function (s) {\n      return s.track === track;\n    });\n\n    if (alreadyExists) {\n      throw makeError('InvalidAccessError', 'Track already exists.');\n    }\n\n    var transceiver;\n    for (var i = 0; i < this.transceivers.length; i++) {\n      if (!this.transceivers[i].track && this.transceivers[i].kind === track.kind) {\n        transceiver = this.transceivers[i];\n      }\n    }\n    if (!transceiver) {\n      transceiver = this._createTransceiver(track.kind);\n    }\n\n    this._maybeFireNegotiationNeeded();\n\n    if (this.localStreams.indexOf(stream) === -1) {\n      this.localStreams.push(stream);\n    }\n\n    transceiver.track = track;\n    transceiver.stream = stream;\n    transceiver.rtpSender = new window.RTCRtpSender(track, transceiver.dtlsTransport);\n    return transceiver.rtpSender;\n  };\n\n  RTCPeerConnection.prototype.addStream = function (stream) {\n    var pc = this;\n    if (edgeVersion >= 15025) {\n      stream.getTracks().forEach(function (track) {\n        pc.addTrack(track, stream);\n      });\n    } else {\n      // Clone is necessary for local demos mostly, attaching directly\n      // to two different senders does not work (build 10547).\n      // Fixed in 15025 (or earlier)\n      var clonedStream = stream.clone();\n      stream.getTracks().forEach(function (track, idx) {\n        var clonedTrack = clonedStream.getTracks()[idx];\n        track.addEventListener('enabled', function (event) {\n          clonedTrack.enabled = event.enabled;\n        });\n      });\n      clonedStream.getTracks().forEach(function (track) {\n        pc.addTrack(track, clonedStream);\n      });\n    }\n  };\n\n  RTCPeerConnection.prototype.removeTrack = function (sender) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError', 'Attempted to call removeTrack on a closed peerconnection.');\n    }\n\n    if (!(sender instanceof window.RTCRtpSender)) {\n      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.');\n    }\n\n    var transceiver = this.transceivers.find(function (t) {\n      return t.rtpSender === sender;\n    });\n\n    if (!transceiver) {\n      throw makeError('InvalidAccessError', 'Sender was not created by this connection.');\n    }\n    var stream = transceiver.stream;\n\n    transceiver.rtpSender.stop();\n    transceiver.rtpSender = null;\n    transceiver.track = null;\n    transceiver.stream = null;\n\n    // remove the stream from the set of local streams\n    var localStreams = this.transceivers.map(function (t) {\n      return t.stream;\n    });\n    if (localStreams.indexOf(stream) === -1 && this.localStreams.indexOf(stream) > -1) {\n      this.localStreams.splice(this.localStreams.indexOf(stream), 1);\n    }\n\n    this._maybeFireNegotiationNeeded();\n  };\n\n  RTCPeerConnection.prototype.removeStream = function (stream) {\n    var pc = this;\n    stream.getTracks().forEach(function (track) {\n      var sender = pc.getSenders().find(function (s) {\n        return s.track === track;\n      });\n      if (sender) {\n        pc.removeTrack(sender);\n      }\n    });\n  };\n\n  RTCPeerConnection.prototype.getSenders = function () {\n    return this.transceivers.filter(function (transceiver) {\n      return !!transceiver.rtpSender;\n    }).map(function (transceiver) {\n      return transceiver.rtpSender;\n    });\n  };\n\n  RTCPeerConnection.prototype.getReceivers = function () {\n    return this.transceivers.filter(function (transceiver) {\n      return !!transceiver.rtpReceiver;\n    }).map(function (transceiver) {\n      return transceiver.rtpReceiver;\n    });\n  };\n\n  RTCPeerConnection.prototype._createIceGatherer = function (sdpMLineIndex, usingBundle) {\n    var pc = this;\n    if (usingBundle && sdpMLineIndex > 0) {\n      return this.transceivers[0].iceGatherer;\n    } else if (this._iceGatherers.length) {\n      return this._iceGatherers.shift();\n    }\n    var iceGatherer = new window.RTCIceGatherer({\n      iceServers: this._config.iceServers,\n      gatherPolicy: this._config.iceTransportPolicy\n    });\n    Object.defineProperty(iceGatherer, 'state', { value: 'new', writable: true });\n\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];\n    this.transceivers[sdpMLineIndex].bufferCandidates = function (event) {\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\n      // polyfill since RTCIceGatherer.state is not implemented in\n      // Edge 10547 yet.\n      iceGatherer.state = end ? 'completed' : 'gathering';\n      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {\n        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);\n      }\n    };\n    iceGatherer.addEventListener('localcandidate', this.transceivers[sdpMLineIndex].bufferCandidates);\n    return iceGatherer;\n  };\n\n  // start gathering from an RTCIceGatherer.\n  RTCPeerConnection.prototype._gather = function (mid, sdpMLineIndex) {\n    var pc = this;\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer.onlocalcandidate) {\n      return;\n    }\n    var bufferedCandidateEvents = this.transceivers[sdpMLineIndex].bufferedCandidateEvents;\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;\n    iceGatherer.removeEventListener('localcandidate', this.transceivers[sdpMLineIndex].bufferCandidates);\n    iceGatherer.onlocalcandidate = function (evt) {\n      if (pc.usingBundle && sdpMLineIndex > 0) {\n        // if we know that we use bundle we can drop candidates with\n        // ѕdpMLineIndex > 0. If we don't do this then our state gets\n        // confused since we dispose the extra ice gatherer.\n        return;\n      }\n      var event = new Event('icecandidate');\n      event.candidate = { sdpMid: mid, sdpMLineIndex: sdpMLineIndex };\n\n      var cand = evt.candidate;\n      // Edge emits an empty object for RTCIceCandidateComplete‥\n      var end = !cand || Object.keys(cand).length === 0;\n      if (end) {\n        // polyfill since RTCIceGatherer.state is not implemented in\n        // Edge 10547 yet.\n        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {\n          iceGatherer.state = 'completed';\n        }\n      } else {\n        if (iceGatherer.state === 'new') {\n          iceGatherer.state = 'gathering';\n        }\n        // RTCIceCandidate doesn't have a component, needs to be added\n        cand.component = 1;\n        // also the usernameFragment. TODO: update SDP to take both variants.\n        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;\n\n        var serializedCandidate = SDPUtils.writeCandidate(cand);\n        event.candidate = Object.assign(event.candidate, SDPUtils.parseCandidate(serializedCandidate));\n\n        event.candidate.candidate = serializedCandidate;\n        event.candidate.toJSON = function () {\n          return {\n            candidate: event.candidate.candidate,\n            sdpMid: event.candidate.sdpMid,\n            sdpMLineIndex: event.candidate.sdpMLineIndex,\n            usernameFragment: event.candidate.usernameFragment\n          };\n        };\n      }\n\n      // update local description.\n      var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);\n      if (!end) {\n        sections[event.candidate.sdpMLineIndex] += 'a=' + event.candidate.candidate + '\\r\\n';\n      } else {\n        sections[event.candidate.sdpMLineIndex] += 'a=end-of-candidates\\r\\n';\n      }\n      pc._localDescription.sdp = SDPUtils.getDescription(pc._localDescription.sdp) + sections.join('');\n      var complete = pc.transceivers.every(function (transceiver) {\n        return transceiver.iceGatherer && transceiver.iceGatherer.state === 'completed';\n      });\n\n      if (pc.iceGatheringState !== 'gathering') {\n        pc.iceGatheringState = 'gathering';\n        pc._emitGatheringStateChange();\n      }\n\n      // Emit candidate. Also emit null candidate when all gatherers are\n      // complete.\n      if (!end) {\n        pc._dispatchEvent('icecandidate', event);\n      }\n      if (complete) {\n        pc._dispatchEvent('icecandidate', new Event('icecandidate'));\n        pc.iceGatheringState = 'complete';\n        pc._emitGatheringStateChange();\n      }\n    };\n\n    // emit already gathered candidates.\n    window.setTimeout(function () {\n      bufferedCandidateEvents.forEach(function (e) {\n        iceGatherer.onlocalcandidate(e);\n      });\n    }, 0);\n  };\n\n  // Create ICE transport and DTLS transport.\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function () {\n    var pc = this;\n    var iceTransport = new window.RTCIceTransport(null);\n    iceTransport.onicestatechange = function () {\n      pc._updateIceConnectionState();\n      pc._updateConnectionState();\n    };\n\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\n    dtlsTransport.ondtlsstatechange = function () {\n      pc._updateConnectionState();\n    };\n    dtlsTransport.onerror = function () {\n      // onerror does not set state to failed by itself.\n      Object.defineProperty(dtlsTransport, 'state', { value: 'failed', writable: true });\n      pc._updateConnectionState();\n    };\n\n    return {\n      iceTransport: iceTransport,\n      dtlsTransport: dtlsTransport\n    };\n  };\n\n  // Destroy ICE gatherer, ICE transport and DTLS transport.\n  // Without triggering the callbacks.\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function (sdpMLineIndex) {\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer) {\n      delete iceGatherer.onlocalcandidate;\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\n    }\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\n    if (iceTransport) {\n      delete iceTransport.onicestatechange;\n      delete this.transceivers[sdpMLineIndex].iceTransport;\n    }\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\n    if (dtlsTransport) {\n      delete dtlsTransport.ondtlsstatechange;\n      delete dtlsTransport.onerror;\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\n    }\n  };\n\n  // Start the RTP Sender and Receiver for a transceiver.\n  RTCPeerConnection.prototype._transceive = function (transceiver, send, recv) {\n    var params = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);\n    if (send && transceiver.rtpSender) {\n      params.encodings = transceiver.sendEncodingParameters;\n      params.rtcp = {\n        cname: SDPUtils.localCName,\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.recvEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpSender.send(params);\n    }\n    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {\n      // remove RTX field in Edge 14942\n      if (transceiver.kind === 'video' && transceiver.recvEncodingParameters && edgeVersion < 15019) {\n        transceiver.recvEncodingParameters.forEach(function (p) {\n          delete p.rtx;\n        });\n      }\n      if (transceiver.recvEncodingParameters.length) {\n        params.encodings = transceiver.recvEncodingParameters;\n      } else {\n        params.encodings = [{}];\n      }\n      params.rtcp = {\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.rtcpParameters.cname) {\n        params.rtcp.cname = transceiver.rtcpParameters.cname;\n      }\n      if (transceiver.sendEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpReceiver.receive(params);\n    }\n  };\n\n  RTCPeerConnection.prototype.setLocalDescription = function (description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError', 'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setLocalDescription', description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError', 'Can not set local ' + description.type + ' in state ' + pc.signalingState));\n    }\n\n    var sections;\n    var sessionpart;\n    if (description.type === 'offer') {\n      // VERY limited support for SDP munging. Limited to:\n      // * changing the order of codecs\n      sections = SDPUtils.splitSections(description.sdp);\n      sessionpart = sections.shift();\n      sections.forEach(function (mediaSection, sdpMLineIndex) {\n        var caps = SDPUtils.parseRtpParameters(mediaSection);\n        pc.transceivers[sdpMLineIndex].localCapabilities = caps;\n      });\n\n      pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {\n        pc._gather(transceiver.mid, sdpMLineIndex);\n      });\n    } else if (description.type === 'answer') {\n      sections = SDPUtils.splitSections(pc._remoteDescription.sdp);\n      sessionpart = sections.shift();\n      var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;\n      sections.forEach(function (mediaSection, sdpMLineIndex) {\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        var iceGatherer = transceiver.iceGatherer;\n        var iceTransport = transceiver.iceTransport;\n        var dtlsTransport = transceiver.dtlsTransport;\n        var localCapabilities = transceiver.localCapabilities;\n        var remoteCapabilities = transceiver.remoteCapabilities;\n\n        // treat bundle-only as not-rejected.\n        var rejected = SDPUtils.isRejected(mediaSection) && SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n\n        if (!rejected && !transceiver.rejected) {\n          var remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);\n          if (isIceLite) {\n            remoteDtlsParameters.role = 'server';\n          }\n\n          if (!pc.usingBundle || sdpMLineIndex === 0) {\n            pc._gather(transceiver.mid, sdpMLineIndex);\n            if (iceTransport.state === 'new') {\n              iceTransport.start(iceGatherer, remoteIceParameters, isIceLite ? 'controlling' : 'controlled');\n            }\n            if (dtlsTransport.state === 'new') {\n              dtlsTransport.start(remoteDtlsParameters);\n            }\n          }\n\n          // Calculate intersection of capabilities.\n          var params = getCommonCapabilities(localCapabilities, remoteCapabilities);\n\n          // Start the RTCRtpSender. The RTCRtpReceiver for this\n          // transceiver has already been started in setRemoteDescription.\n          pc._transceive(transceiver, params.codecs.length > 0, false);\n        }\n      });\n    }\n\n    pc._localDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-local-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.setRemoteDescription = function (description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError', 'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setRemoteDescription', description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError', 'Can not set remote ' + description.type + ' in state ' + pc.signalingState));\n    }\n\n    var streams = {};\n    pc.remoteStreams.forEach(function (stream) {\n      streams[stream.id] = stream;\n    });\n    var receiverList = [];\n    var sections = SDPUtils.splitSections(description.sdp);\n    var sessionpart = sections.shift();\n    var isIceLite = SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;\n    var usingBundle = SDPUtils.matchPrefix(sessionpart, 'a=group:BUNDLE ').length > 0;\n    pc.usingBundle = usingBundle;\n    var iceOptions = SDPUtils.matchPrefix(sessionpart, 'a=ice-options:')[0];\n    if (iceOptions) {\n      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ').indexOf('trickle') >= 0;\n    } else {\n      pc.canTrickleIceCandidates = false;\n    }\n\n    sections.forEach(function (mediaSection, sdpMLineIndex) {\n      var lines = SDPUtils.splitLines(mediaSection);\n      var kind = SDPUtils.getKind(mediaSection);\n      // treat bundle-only as not-rejected.\n      var rejected = SDPUtils.isRejected(mediaSection) && SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n      var protocol = lines[0].substr(2).split(' ')[2];\n\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\n\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\n\n      // Reject datachannels which are not implemented yet.\n      if (rejected || kind === 'application' && (protocol === 'DTLS/SCTP' || protocol === 'UDP/DTLS/SCTP')) {\n        // TODO: this is dangerous in the case where a non-rejected m-line\n        //     becomes rejected.\n        pc.transceivers[sdpMLineIndex] = {\n          mid: mid,\n          kind: kind,\n          protocol: protocol,\n          rejected: true\n        };\n        return;\n      }\n\n      if (!rejected && pc.transceivers[sdpMLineIndex] && pc.transceivers[sdpMLineIndex].rejected) {\n        // recycle a rejected transceiver.\n        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);\n      }\n\n      var transceiver;\n      var iceGatherer;\n      var iceTransport;\n      var dtlsTransport;\n      var rtpReceiver;\n      var sendEncodingParameters;\n      var recvEncodingParameters;\n      var localCapabilities;\n\n      var track;\n      // FIXME: ensure the mediaSection has rtcp-mux set.\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n      var remoteIceParameters;\n      var remoteDtlsParameters;\n      if (!rejected) {\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);\n        remoteDtlsParameters.role = 'client';\n      }\n      recvEncodingParameters = SDPUtils.parseRtpEncodingParameters(mediaSection);\n\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\n\n      var isComplete = SDPUtils.matchPrefix(mediaSection, 'a=end-of-candidates', sessionpart).length > 0;\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:').map(function (cand) {\n        return SDPUtils.parseCandidate(cand);\n      }).filter(function (cand) {\n        return cand.component === 1;\n      });\n\n      // Check if we can use BUNDLE and dispose transports.\n      if ((description.type === 'offer' || description.type === 'answer') && !rejected && usingBundle && sdpMLineIndex > 0 && pc.transceivers[sdpMLineIndex]) {\n        pc._disposeIceAndDtlsTransports(sdpMLineIndex);\n        pc.transceivers[sdpMLineIndex].iceGatherer = pc.transceivers[0].iceGatherer;\n        pc.transceivers[sdpMLineIndex].iceTransport = pc.transceivers[0].iceTransport;\n        pc.transceivers[sdpMLineIndex].dtlsTransport = pc.transceivers[0].dtlsTransport;\n        if (pc.transceivers[sdpMLineIndex].rtpSender) {\n          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(pc.transceivers[0].dtlsTransport);\n        }\n        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {\n          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(pc.transceivers[0].dtlsTransport);\n        }\n      }\n      if (description.type === 'offer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex] || pc._createTransceiver(kind);\n        transceiver.mid = mid;\n\n        if (!transceiver.iceGatherer) {\n          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, usingBundle);\n        }\n\n        if (cands.length && transceiver.iceTransport.state === 'new') {\n          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {\n            transceiver.iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function (candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);\n\n        // filter RTX until additional stuff needed for RTX is implemented\n        // in adapter.js\n        if (edgeVersion < 15019) {\n          localCapabilities.codecs = localCapabilities.codecs.filter(function (codec) {\n            return codec.name !== 'rtx';\n          });\n        }\n\n        sendEncodingParameters = transceiver.sendEncodingParameters || [{\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\n        }];\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        var isNewTrack = false;\n        if (direction === 'sendrecv' || direction === 'sendonly') {\n          isNewTrack = !transceiver.rtpReceiver;\n          rtpReceiver = transceiver.rtpReceiver || new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\n\n          if (isNewTrack) {\n            var stream;\n            track = rtpReceiver.track;\n            // FIXME: does not work with Plan B.\n            if (remoteMsid && remoteMsid.stream === '-') {\n              // no-op. a stream id of '-' means: no associated stream.\n            } else if (remoteMsid) {\n              if (!streams[remoteMsid.stream]) {\n                streams[remoteMsid.stream] = new window.MediaStream();\n                Object.defineProperty(streams[remoteMsid.stream], 'id', {\n                  get: function () {\n                    return remoteMsid.stream;\n                  }\n                });\n              }\n              Object.defineProperty(track, 'id', {\n                get: function () {\n                  return remoteMsid.track;\n                }\n              });\n              stream = streams[remoteMsid.stream];\n            } else {\n              if (!streams.default) {\n                streams.default = new window.MediaStream();\n              }\n              stream = streams.default;\n            }\n            if (stream) {\n              addTrackToStreamAndFireEvent(track, stream);\n              transceiver.associatedRemoteMediaStreams.push(stream);\n            }\n            receiverList.push([track, rtpReceiver, stream]);\n          }\n        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {\n          transceiver.associatedRemoteMediaStreams.forEach(function (s) {\n            var nativeTrack = s.getTracks().find(function (t) {\n              return t.id === transceiver.rtpReceiver.track.id;\n            });\n            if (nativeTrack) {\n              removeTrackFromStreamAndFireEvent(nativeTrack, s);\n            }\n          });\n          transceiver.associatedRemoteMediaStreams = [];\n        }\n\n        transceiver.localCapabilities = localCapabilities;\n        transceiver.remoteCapabilities = remoteCapabilities;\n        transceiver.rtpReceiver = rtpReceiver;\n        transceiver.rtcpParameters = rtcpParameters;\n        transceiver.sendEncodingParameters = sendEncodingParameters;\n        transceiver.recvEncodingParameters = recvEncodingParameters;\n\n        // Start the RTCRtpReceiver now. The RTPSender is started in\n        // setLocalDescription.\n        pc._transceive(pc.transceivers[sdpMLineIndex], false, isNewTrack);\n      } else if (description.type === 'answer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex];\n        iceGatherer = transceiver.iceGatherer;\n        iceTransport = transceiver.iceTransport;\n        dtlsTransport = transceiver.dtlsTransport;\n        rtpReceiver = transceiver.rtpReceiver;\n        sendEncodingParameters = transceiver.sendEncodingParameters;\n        localCapabilities = transceiver.localCapabilities;\n\n        pc.transceivers[sdpMLineIndex].recvEncodingParameters = recvEncodingParameters;\n        pc.transceivers[sdpMLineIndex].remoteCapabilities = remoteCapabilities;\n        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\n\n        if (cands.length && iceTransport.state === 'new') {\n          if ((isIceLite || isComplete) && (!usingBundle || sdpMLineIndex === 0)) {\n            iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function (candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        if (!usingBundle || sdpMLineIndex === 0) {\n          if (iceTransport.state === 'new') {\n            iceTransport.start(iceGatherer, remoteIceParameters, 'controlling');\n          }\n          if (dtlsTransport.state === 'new') {\n            dtlsTransport.start(remoteDtlsParameters);\n          }\n        }\n\n        pc._transceive(transceiver, direction === 'sendrecv' || direction === 'recvonly', direction === 'sendrecv' || direction === 'sendonly');\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        if (rtpReceiver && (direction === 'sendrecv' || direction === 'sendonly')) {\n          track = rtpReceiver.track;\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams.default);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        } else {\n          // FIXME: actually the receiver should be created later.\n          delete transceiver.rtpReceiver;\n        }\n      }\n    });\n\n    if (pc._dtlsRole === undefined) {\n      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';\n    }\n\n    pc._remoteDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-remote-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n    Object.keys(streams).forEach(function (sid) {\n      var stream = streams[sid];\n      if (stream.getTracks().length) {\n        if (pc.remoteStreams.indexOf(stream) === -1) {\n          pc.remoteStreams.push(stream);\n          var event = new Event('addstream');\n          event.stream = stream;\n          window.setTimeout(function () {\n            pc._dispatchEvent('addstream', event);\n          });\n        }\n\n        receiverList.forEach(function (item) {\n          var track = item[0];\n          var receiver = item[1];\n          if (stream.id !== item[2].id) {\n            return;\n          }\n          fireAddTrack(pc, track, receiver, [stream]);\n        });\n      }\n    });\n    receiverList.forEach(function (item) {\n      if (item[2]) {\n        return;\n      }\n      fireAddTrack(pc, item[0], item[1], []);\n    });\n\n    // check whether addIceCandidate({}) was called within four seconds after\n    // setRemoteDescription.\n    window.setTimeout(function () {\n      if (!(pc && pc.transceivers)) {\n        return;\n      }\n      pc.transceivers.forEach(function (transceiver) {\n        if (transceiver.iceTransport && transceiver.iceTransport.state === 'new' && transceiver.iceTransport.getRemoteCandidates().length > 0) {\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' + 'an end-of-candidates notification');\n          transceiver.iceTransport.addRemoteCandidate({});\n        }\n      });\n    }, 4000);\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.close = function () {\n    this.transceivers.forEach(function (transceiver) {\n      /* not yet\n      if (transceiver.iceGatherer) {\n        transceiver.iceGatherer.close();\n      }\n      */\n      if (transceiver.iceTransport) {\n        transceiver.iceTransport.stop();\n      }\n      if (transceiver.dtlsTransport) {\n        transceiver.dtlsTransport.stop();\n      }\n      if (transceiver.rtpSender) {\n        transceiver.rtpSender.stop();\n      }\n      if (transceiver.rtpReceiver) {\n        transceiver.rtpReceiver.stop();\n      }\n    });\n    // FIXME: clean up tracks, local streams, remote streams, etc\n    this._isClosed = true;\n    this._updateSignalingState('closed');\n  };\n\n  // Update the signaling state.\n  RTCPeerConnection.prototype._updateSignalingState = function (newState) {\n    this.signalingState = newState;\n    var event = new Event('signalingstatechange');\n    this._dispatchEvent('signalingstatechange', event);\n  };\n\n  // Determine whether to fire the negotiationneeded event.\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function () {\n    var pc = this;\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\n      return;\n    }\n    this.needNegotiation = true;\n    window.setTimeout(function () {\n      if (pc.needNegotiation) {\n        pc.needNegotiation = false;\n        var event = new Event('negotiationneeded');\n        pc._dispatchEvent('negotiationneeded', event);\n      }\n    }, 0);\n  };\n\n  // Update the ice connection state.\n  RTCPeerConnection.prototype._updateIceConnectionState = function () {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      checking: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function (transceiver) {\n      states[transceiver.iceTransport.state]++;\n    });\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.checking > 0) {\n      newState = 'checking';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    } else if (states.completed > 0) {\n      newState = 'completed';\n    }\n\n    if (newState !== this.iceConnectionState) {\n      this.iceConnectionState = newState;\n      var event = new Event('iceconnectionstatechange');\n      this._dispatchEvent('iceconnectionstatechange', event);\n    }\n  };\n\n  // Update the connection state.\n  RTCPeerConnection.prototype._updateConnectionState = function () {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      connecting: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function (transceiver) {\n      states[transceiver.iceTransport.state]++;\n      states[transceiver.dtlsTransport.state]++;\n    });\n    // ICETransport.completed and connected are the same for this purpose.\n    states.connected += states.completed;\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.connecting > 0) {\n      newState = 'connecting';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    }\n\n    if (newState !== this.connectionState) {\n      this.connectionState = newState;\n      var event = new Event('connectionstatechange');\n      this._dispatchEvent('connectionstatechange', event);\n    }\n  };\n\n  RTCPeerConnection.prototype.createOffer = function () {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError', 'Can not call createOffer after close'));\n    }\n\n    var numAudioTracks = pc.transceivers.filter(function (t) {\n      return t.kind === 'audio';\n    }).length;\n    var numVideoTracks = pc.transceivers.filter(function (t) {\n      return t.kind === 'video';\n    }).length;\n\n    // Determine number of audio and video tracks we need to send/recv.\n    var offerOptions = arguments[0];\n    if (offerOptions) {\n      // Reject Chrome legacy constraints.\n      if (offerOptions.mandatory || offerOptions.optional) {\n        throw new TypeError('Legacy mandatory/optional constraints not supported.');\n      }\n      if (offerOptions.offerToReceiveAudio !== undefined) {\n        if (offerOptions.offerToReceiveAudio === true) {\n          numAudioTracks = 1;\n        } else if (offerOptions.offerToReceiveAudio === false) {\n          numAudioTracks = 0;\n        } else {\n          numAudioTracks = offerOptions.offerToReceiveAudio;\n        }\n      }\n      if (offerOptions.offerToReceiveVideo !== undefined) {\n        if (offerOptions.offerToReceiveVideo === true) {\n          numVideoTracks = 1;\n        } else if (offerOptions.offerToReceiveVideo === false) {\n          numVideoTracks = 0;\n        } else {\n          numVideoTracks = offerOptions.offerToReceiveVideo;\n        }\n      }\n    }\n\n    pc.transceivers.forEach(function (transceiver) {\n      if (transceiver.kind === 'audio') {\n        numAudioTracks--;\n        if (numAudioTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      } else if (transceiver.kind === 'video') {\n        numVideoTracks--;\n        if (numVideoTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      }\n    });\n\n    // Create M-lines for recvonly streams.\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\n      if (numAudioTracks > 0) {\n        pc._createTransceiver('audio');\n        numAudioTracks--;\n      }\n      if (numVideoTracks > 0) {\n        pc._createTransceiver('video');\n        numVideoTracks--;\n      }\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId, pc._sdpSessionVersion++);\n    pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {\n      // For each track, create an ice gatherer, ice transport,\n      // dtls transport, potentially rtpsender and rtpreceiver.\n      var track = transceiver.track;\n      var kind = transceiver.kind;\n      var mid = transceiver.mid || SDPUtils.generateIdentifier();\n      transceiver.mid = mid;\n\n      if (!transceiver.iceGatherer) {\n        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, pc.usingBundle);\n      }\n\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\n      // filter RTX until additional stuff needed for RTX is implemented\n      // in adapter.js\n      if (edgeVersion < 15019) {\n        localCapabilities.codecs = localCapabilities.codecs.filter(function (codec) {\n          return codec.name !== 'rtx';\n        });\n      }\n      localCapabilities.codecs.forEach(function (codec) {\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\n        // by adding level-asymmetry-allowed=1\n        if (codec.name === 'H264' && codec.parameters['level-asymmetry-allowed'] === undefined) {\n          codec.parameters['level-asymmetry-allowed'] = '1';\n        }\n\n        // for subsequent offers, we might have to re-use the payload\n        // type of the last offer.\n        if (transceiver.remoteCapabilities && transceiver.remoteCapabilities.codecs) {\n          transceiver.remoteCapabilities.codecs.forEach(function (remoteCodec) {\n            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() && codec.clockRate === remoteCodec.clockRate) {\n              codec.preferredPayloadType = remoteCodec.payloadType;\n            }\n          });\n        }\n      });\n      localCapabilities.headerExtensions.forEach(function (hdrExt) {\n        var remoteExtensions = transceiver.remoteCapabilities && transceiver.remoteCapabilities.headerExtensions || [];\n        remoteExtensions.forEach(function (rHdrExt) {\n          if (hdrExt.uri === rHdrExt.uri) {\n            hdrExt.id = rHdrExt.id;\n          }\n        });\n      });\n\n      // generate an ssrc now, to be used later in rtpSender.send\n      var sendEncodingParameters = transceiver.sendEncodingParameters || [{\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\n      }];\n      if (track) {\n        // add RTX\n        if (edgeVersion >= 15019 && kind === 'video' && !sendEncodingParameters[0].rtx) {\n          sendEncodingParameters[0].rtx = {\n            ssrc: sendEncodingParameters[0].ssrc + 1\n          };\n        }\n      }\n\n      if (transceiver.wantReceive) {\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\n      }\n\n      transceiver.localCapabilities = localCapabilities;\n      transceiver.sendEncodingParameters = sendEncodingParameters;\n    });\n\n    // always offer BUNDLE and dispose on return if not supported.\n    if (pc._config.bundlePolicy !== 'max-compat') {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function (t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {\n      sdp += writeMediaSection(transceiver, transceiver.localCapabilities, 'offer', transceiver.stream, pc._dtlsRole);\n      sdp += 'a=rtcp-rsize\\r\\n';\n\n      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' && (sdpMLineIndex === 0 || !pc.usingBundle)) {\n        transceiver.iceGatherer.getLocalCandidates().forEach(function (cand) {\n          cand.component = 1;\n          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\\r\\n';\n        });\n\n        if (transceiver.iceGatherer.state === 'completed') {\n          sdp += 'a=end-of-candidates\\r\\n';\n        }\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'offer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.createAnswer = function () {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError', 'Can not call createAnswer after close'));\n    }\n\n    if (!(pc.signalingState === 'have-remote-offer' || pc.signalingState === 'have-local-pranswer')) {\n      return Promise.reject(makeError('InvalidStateError', 'Can not call createAnswer in signalingState ' + pc.signalingState));\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId, pc._sdpSessionVersion++);\n    if (pc.usingBundle) {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function (t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    var mediaSectionsInOffer = SDPUtils.getMediaSections(pc._remoteDescription.sdp).length;\n    pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {\n      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {\n        return;\n      }\n      if (transceiver.rejected) {\n        if (transceiver.kind === 'application') {\n          if (transceiver.protocol === 'DTLS/SCTP') {\n            // legacy fmt\n            sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n';\n          } else {\n            sdp += 'm=application 0 ' + transceiver.protocol + ' webrtc-datachannel\\r\\n';\n          }\n        } else if (transceiver.kind === 'audio') {\n          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\n' + 'a=rtpmap:0 PCMU/8000\\r\\n';\n        } else if (transceiver.kind === 'video') {\n          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\\r\\n' + 'a=rtpmap:120 VP8/90000\\r\\n';\n        }\n        sdp += 'c=IN IP4 0.0.0.0\\r\\n' + 'a=inactive\\r\\n' + 'a=mid:' + transceiver.mid + '\\r\\n';\n        return;\n      }\n\n      // FIXME: look at direction.\n      if (transceiver.stream) {\n        var localTrack;\n        if (transceiver.kind === 'audio') {\n          localTrack = transceiver.stream.getAudioTracks()[0];\n        } else if (transceiver.kind === 'video') {\n          localTrack = transceiver.stream.getVideoTracks()[0];\n        }\n        if (localTrack) {\n          // add RTX\n          if (edgeVersion >= 15019 && transceiver.kind === 'video' && !transceiver.sendEncodingParameters[0].rtx) {\n            transceiver.sendEncodingParameters[0].rtx = {\n              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1\n            };\n          }\n        }\n      }\n\n      // Calculate intersection of capabilities.\n      var commonCapabilities = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);\n\n      var hasRtx = commonCapabilities.codecs.filter(function (c) {\n        return c.name.toLowerCase() === 'rtx';\n      }).length;\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n        delete transceiver.sendEncodingParameters[0].rtx;\n      }\n\n      sdp += writeMediaSection(transceiver, commonCapabilities, 'answer', transceiver.stream, pc._dtlsRole);\n      if (transceiver.rtcpParameters && transceiver.rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'answer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.addIceCandidate = function (candidate) {\n    var pc = this;\n    var sections;\n    if (candidate && !(candidate.sdpMLineIndex !== undefined || candidate.sdpMid)) {\n      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));\n    }\n\n    // TODO: needs to go into ops queue.\n    return new Promise(function (resolve, reject) {\n      if (!pc._remoteDescription) {\n        return reject(makeError('InvalidStateError', 'Can not add ICE candidate without a remote description'));\n      } else if (!candidate || candidate.candidate === '') {\n        for (var j = 0; j < pc.transceivers.length; j++) {\n          if (pc.transceivers[j].rejected) {\n            continue;\n          }\n          pc.transceivers[j].iceTransport.addRemoteCandidate({});\n          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);\n          sections[j] += 'a=end-of-candidates\\r\\n';\n          pc._remoteDescription.sdp = SDPUtils.getDescription(pc._remoteDescription.sdp) + sections.join('');\n          if (pc.usingBundle) {\n            break;\n          }\n        }\n      } else {\n        var sdpMLineIndex = candidate.sdpMLineIndex;\n        if (candidate.sdpMid) {\n          for (var i = 0; i < pc.transceivers.length; i++) {\n            if (pc.transceivers[i].mid === candidate.sdpMid) {\n              sdpMLineIndex = i;\n              break;\n            }\n          }\n        }\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        if (transceiver) {\n          if (transceiver.rejected) {\n            return resolve();\n          }\n          var cand = Object.keys(candidate.candidate).length > 0 ? SDPUtils.parseCandidate(candidate.candidate) : {};\n          // Ignore Chrome's invalid candidates since Edge does not like them.\n          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n            return resolve();\n          }\n          // Ignore RTCP candidates, we assume RTCP-MUX.\n          if (cand.component && cand.component !== 1) {\n            return resolve();\n          }\n          // when using bundle, avoid adding candidates to the wrong\n          // ice transport. And avoid adding candidates added in the SDP.\n          if (sdpMLineIndex === 0 || sdpMLineIndex > 0 && transceiver.iceTransport !== pc.transceivers[0].iceTransport) {\n            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {\n              return reject(makeError('OperationError', 'Can not add ICE candidate'));\n            }\n          }\n\n          // update the remoteDescription.\n          var candidateString = candidate.candidate.trim();\n          if (candidateString.indexOf('a=') === 0) {\n            candidateString = candidateString.substr(2);\n          }\n          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);\n          sections[sdpMLineIndex] += 'a=' + (cand.type ? candidateString : 'end-of-candidates') + '\\r\\n';\n          pc._remoteDescription.sdp = SDPUtils.getDescription(pc._remoteDescription.sdp) + sections.join('');\n        } else {\n          return reject(makeError('OperationError', 'Can not add ICE candidate'));\n        }\n      }\n      resolve();\n    });\n  };\n\n  RTCPeerConnection.prototype.getStats = function (selector) {\n    if (selector && selector instanceof window.MediaStreamTrack) {\n      var senderOrReceiver = null;\n      this.transceivers.forEach(function (transceiver) {\n        if (transceiver.rtpSender && transceiver.rtpSender.track === selector) {\n          senderOrReceiver = transceiver.rtpSender;\n        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track === selector) {\n          senderOrReceiver = transceiver.rtpReceiver;\n        }\n      });\n      if (!senderOrReceiver) {\n        throw makeError('InvalidAccessError', 'Invalid selector.');\n      }\n      return senderOrReceiver.getStats();\n    }\n\n    var promises = [];\n    this.transceivers.forEach(function (transceiver) {\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport', 'dtlsTransport'].forEach(function (method) {\n        if (transceiver[method]) {\n          promises.push(transceiver[method].getStats());\n        }\n      });\n    });\n    return Promise.all(promises).then(function (allStats) {\n      var results = new Map();\n      allStats.forEach(function (stats) {\n        stats.forEach(function (stat) {\n          results.set(stat.id, stat);\n        });\n      });\n      return results;\n    });\n  };\n\n  // fix low-level stat names and return Map instead of object.\n  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer', 'RTCIceTransport', 'RTCDtlsTransport'];\n  ortcObjects.forEach(function (ortcObjectName) {\n    var obj = window[ortcObjectName];\n    if (obj && obj.prototype && obj.prototype.getStats) {\n      var nativeGetstats = obj.prototype.getStats;\n      obj.prototype.getStats = function () {\n        return nativeGetstats.apply(this).then(function (nativeStats) {\n          var mapStats = new Map();\n          Object.keys(nativeStats).forEach(function (id) {\n            nativeStats[id].type = fixStatsType(nativeStats[id]);\n            mapStats.set(id, nativeStats[id]);\n          });\n          return mapStats;\n        });\n      };\n    }\n  });\n\n  // legacy callback shims. Should be moved to adapter.js some days.\n  var methods = ['createOffer', 'createAnswer'];\n  methods.forEach(function (method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function () {\n      var args = arguments;\n      if (typeof args[0] === 'function' || typeof args[1] === 'function') {\n        // legacy\n        return nativeMethod.apply(this, [arguments[2]]).then(function (description) {\n          if (typeof args[0] === 'function') {\n            args[0].apply(null, [description]);\n          }\n        }, function (error) {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];\n  methods.forEach(function (method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function () {\n      var args = arguments;\n      if (typeof args[1] === 'function' || typeof args[2] === 'function') {\n        // legacy\n        return nativeMethod.apply(this, arguments).then(function () {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        }, function (error) {\n          if (typeof args[2] === 'function') {\n            args[2].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  // getStats is special. It doesn't have a spec legacy method yet we support\n  // getStats(something, cb) without error callbacks.\n  ['getStats'].forEach(function (method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function () {\n      var args = arguments;\n      if (typeof args[1] === 'function') {\n        return nativeMethod.apply(this, arguments).then(function () {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  return RTCPeerConnection;\n};\n\n//# sourceURL=webpack:///./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/grammar.js":
/*!***************************************************!*\
  !*** ./node_modules/sdp-transform/lib/grammar.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{ //o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..\n  r: [{ name: 'repeats' }], // TODO: this one can also be parsed properly\n  //k: [{}], // outdated thing ignored\n  t: [{ //t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{ //c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{ //b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w\\/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [{ //a=rtpmap:110 opus/48000/2\n    push: 'rtp',\n    reg: /^rtpmap:(\\d*) ([\\w\\-\\.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n    names: ['payload', 'codec', 'rate', 'encoding'],\n    format: function (o) {\n      return o.encoding ? 'rtpmap:%d %s/%s/%s' : o.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s';\n    }\n  }, { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n    //a=fmtp:111 minptime=10; useinbandfec=1\n    push: 'fmtp',\n    reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n    names: ['payload', 'config'],\n    format: 'fmtp:%d %s'\n  }, { //a=control:streamid=0\n    name: 'control',\n    reg: /^control:(.*)/,\n    format: 'control:%s'\n  }, { //a=rtcp:65179 IN IP4 193.84.77.194\n    name: 'rtcp',\n    reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n    names: ['port', 'netType', 'ipVer', 'address'],\n    format: function (o) {\n      return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';\n    }\n  }, { //a=rtcp-fb:98 trr-int 100\n    push: 'rtcpFbTrrInt',\n    reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n    names: ['payload', 'value'],\n    format: 'rtcp-fb:%d trr-int %d'\n  }, { //a=rtcp-fb:98 nack rpsi\n    push: 'rtcpFb',\n    reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n    names: ['payload', 'type', 'subtype'],\n    format: function (o) {\n      return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';\n    }\n  }, { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n    //a=extmap:1/recvonly URI-gps-string\n    push: 'ext',\n    reg: /^extmap:(\\d+)(?:\\/(\\w+))? (\\S*)(?: (\\S*))?/,\n    names: ['value', 'direction', 'uri', 'config'],\n    format: function (o) {\n      return 'extmap:%d' + (o.direction ? '/%s' : '%v') + ' %s' + (o.config ? ' %s' : '');\n    }\n  }, { //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n    push: 'crypto',\n    reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n    names: ['id', 'suite', 'config', 'sessionConfig'],\n    format: function (o) {\n      return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';\n    }\n  }, { //a=setup:actpass\n    name: 'setup',\n    reg: /^setup:(\\w*)/,\n    format: 'setup:%s'\n  }, { //a=mid:1\n    name: 'mid',\n    reg: /^mid:([^\\s]*)/,\n    format: 'mid:%s'\n  }, { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n    name: 'msid',\n    reg: /^msid:(.*)/,\n    format: 'msid:%s'\n  }, { //a=ptime:20\n    name: 'ptime',\n    reg: /^ptime:(\\d*)/,\n    format: 'ptime:%d'\n  }, { //a=maxptime:60\n    name: 'maxptime',\n    reg: /^maxptime:(\\d*)/,\n    format: 'maxptime:%d'\n  }, { //a=sendrecv\n    name: 'direction',\n    reg: /^(sendrecv|recvonly|sendonly|inactive)/\n  }, { //a=ice-lite\n    name: 'icelite',\n    reg: /^(ice-lite)/\n  }, { //a=ice-ufrag:F7gI\n    name: 'iceUfrag',\n    reg: /^ice-ufrag:(\\S*)/,\n    format: 'ice-ufrag:%s'\n  }, { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n    name: 'icePwd',\n    reg: /^ice-pwd:(\\S*)/,\n    format: 'ice-pwd:%s'\n  }, { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n    name: 'fingerprint',\n    reg: /^fingerprint:(\\S*) (\\S*)/,\n    names: ['type', 'hash'],\n    format: 'fingerprint:%s %s'\n  }, { //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n    //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n    //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n    //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n    //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n    push: 'candidates',\n    reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n    names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n    format: function (o) {\n      var str = 'candidate:%s %d %s %d %s %d typ %s';\n\n      str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';\n\n      // NB: candidate has three optional chunks, so %void middles one if it's missing\n      str += o.tcptype != null ? ' tcptype %s' : '%v';\n\n      if (o.generation != null) {\n        str += ' generation %d';\n      }\n\n      str += o['network-id'] != null ? ' network-id %d' : '%v';\n      str += o['network-cost'] != null ? ' network-cost %d' : '%v';\n      return str;\n    }\n  }, { //a=end-of-candidates (keep after the candidates line for readability)\n    name: 'endOfCandidates',\n    reg: /^(end-of-candidates)/\n  }, { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n    name: 'remoteCandidates',\n    reg: /^remote-candidates:(.*)/,\n    format: 'remote-candidates:%s'\n  }, { //a=ice-options:google-ice\n    name: 'iceOptions',\n    reg: /^ice-options:(\\S*)/,\n    format: 'ice-options:%s'\n  }, { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n    push: 'ssrcs',\n    reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n    names: ['id', 'attribute', 'value'],\n    format: function (o) {\n      var str = 'ssrc:%d';\n      if (o.attribute != null) {\n        str += ' %s';\n        if (o.value != null) {\n          str += ':%s';\n        }\n      }\n      return str;\n    }\n  }, { //a=ssrc-group:FEC 1 2\n    //a=ssrc-group:FEC-FR 3004364195 1080772241\n    push: 'ssrcGroups',\n    // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n    reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n    names: ['semantics', 'ssrcs'],\n    format: 'ssrc-group:%s %s'\n  }, { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n    name: 'msidSemantic',\n    reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n    names: ['semantic', 'token'],\n    format: 'msid-semantic: %s %s' // space after ':' is not accidental\n  }, { //a=group:BUNDLE audio video\n    push: 'groups',\n    reg: /^group:(\\w*) (.*)/,\n    names: ['type', 'mids'],\n    format: 'group:%s %s'\n  }, { //a=rtcp-mux\n    name: 'rtcpMux',\n    reg: /^(rtcp-mux)/\n  }, { //a=rtcp-rsize\n    name: 'rtcpRsize',\n    reg: /^(rtcp-rsize)/\n  }, { //a=sctpmap:5000 webrtc-datachannel 1024\n    name: 'sctpmap',\n    reg: /^sctpmap:([\\w_\\/]*) (\\S*)(?: (\\S*))?/,\n    names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n    format: function (o) {\n      return o.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s';\n    }\n  }, { //a=x-google-flag:conference\n    name: 'xGoogleFlag',\n    reg: /^x-google-flag:([^\\s]*)/,\n    format: 'x-google-flag:%s'\n  }, { //a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n    push: 'rids',\n    reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n    names: ['id', 'direction', 'params'],\n    format: function (o) {\n      return o.params ? 'rid:%s %s %s' : 'rid:%s %s';\n    }\n  }, { //a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n    //a=imageattr:* send [x=800,y=640] recv *\n    //a=imageattr:100 recv [x=320,y=240]\n    push: 'imageattrs',\n    reg: new RegExp(\n    //a=imageattr:97\n    '^imageattr:(\\\\d+|\\\\*)' +\n    //send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n    '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n    //recv [x=330,y=250]\n    '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'),\n    names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n    format: function (o) {\n      return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n    }\n  }, { //a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n    //a=simulcast:recv 1;4,5 send 6;7\n    name: 'simulcast',\n    reg: new RegExp(\n    //a=simulcast:\n    '^simulcast:' +\n    //send 1,2,3;~4,~5\n    '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n    //space + recv 6;~7,~8\n    '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n    //end\n    '$'),\n    names: ['dir1', 'list1', 'dir2', 'list2'],\n    format: function (o) {\n      return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n    }\n  }, { //Old simulcast draft 03 (implemented by Firefox)\n    //  https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n    //a=simulcast: recv pt=97;98 send pt=97\n    //a=simulcast: send rid=5;6;7 paused=6,7\n    name: 'simulcast_03',\n    reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n    names: ['value'],\n    format: 'simulcast: %s'\n  }, {\n    //a=framerate:25\n    //a=framerate:29.97\n    name: 'framerate',\n    reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n    format: 'framerate:%s'\n  }, { // RFC4570\n    //a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n    name: 'sourceFilter',\n    reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n    names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n    format: 'source-filter: %s %s %s %s %s'\n  }, { // any a= that we don't understand is kepts verbatim on media.invalid\n    push: 'invalid',\n    names: ['value']\n  }]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/grammar.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/sdp-transform/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar parser = __webpack_require__(/*! ./parser */ \"./node_modules/sdp-transform/lib/parser.js\");\nvar writer = __webpack_require__(/*! ./writer */ \"./node_modules/sdp-transform/lib/writer.js\");\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseFmtpConfig = parser.parseFmtpConfig;\nexports.parseParams = parser.parseParams;\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/index.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/parser.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/parser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  } else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i + 1] != null) {\n        location[names[i]] = toIntIfInt(match[i + 1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  } else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ? {} : // blank object that will be pushed\n  needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {},\n      media = [],\n      location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({ rtp: [], fmtp: [] });\n      location = media[media.length - 1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar paramReducer = function (acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  } else if (s.length === 1 && expr.length > 1) {\n    acc[s[0]] = undefined;\n  }\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/\\;\\s?/).reduce(paramReducer, {});\n};\n\n// For backward compatibility - alias will be removed in 3.0.0\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid,\n          paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/parser.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/writer.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/writer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n      case '%%':\n        return '%';\n      case '%s':\n        return String(arg);\n      case '%d':\n        return Number(arg);\n      case '%v':\n        return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      } else {\n        // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  } else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a'];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      } else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        } else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/writer.js?");

/***/ }),

/***/ "./node_modules/sdp/sdp.js":
/*!*********************************!*\
  !*** ./node_modules/sdp/sdp.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* eslint-env node */\n\n\n// SDP helpers.\n\nvar SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function () {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function (blob) {\n  return blob.trim().split('\\n').map(function (line) {\n    return line.trim();\n  });\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function (blob) {\n  var parts = blob.split('\\nm=');\n  return parts.map(function (part, index) {\n    return (index > 0 ? 'm=' + part : part).trim() + '\\r\\n';\n  });\n};\n\n// returns the session description.\nSDPUtils.getDescription = function (blob) {\n  var sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// returns the individual media sections.\nSDPUtils.getMediaSections = function (blob) {\n  var sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function (blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(function (line) {\n    return line.indexOf(prefix) === 0;\n  });\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\nSDPUtils.parseCandidate = function (line) {\n  var parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  var candidate = {\n    foundation: parts[0],\n    component: parseInt(parts[1], 10),\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n\n  for (var i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compability.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default:\n        // extension handling, in particular ufrag\n        candidate[parts[i]] = parts[i + 1];\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\nSDPUtils.writeCandidate = function (candidate) {\n  var sdp = [];\n  sdp.push(candidate.foundation);\n  sdp.push(candidate.component);\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.ip);\n  sdp.push(candidate.port);\n\n  var type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function (line) {\n  return line.substr(14).split(' ');\n};\n\n// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function (line) {\n  var parts = line.substr(9).split(' ');\n  var parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generate an a=rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function (codec) {\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  var channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses an a=extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function (line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n};\n\n// Generates a=extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function (headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses an ftmp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function (line) {\n  var parsed = {};\n  var kv;\n  var parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (var j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function (codec) {\n  var line = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    var params = [];\n    Object.keys(codec.parameters).forEach(function (param) {\n      if (codec.parameters[param]) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function (line) {\n  var parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function (codec) {\n  var lines = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(function (fb) {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses an RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function (line) {\n  var sp = line.indexOf(' ');\n  var parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  var colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function (mediaSection) {\n  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n};\n\nSDPUtils.parseFingerprint = function (line) {\n  var parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1]\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role.\n  // Note2: 'algorithm' is not case sensitive except in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function (params, setupType) {\n  var sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(function (fp) {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function (mediaSection, sessionpart) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  // Search in session part, too.\n  lines = lines.concat(SDPUtils.splitLines(sessionpart));\n  var iceParameters = {\n    usernameFragment: lines.filter(function (line) {\n      return line.indexOf('a=ice-ufrag:') === 0;\n    })[0].substr(12),\n    password: lines.filter(function (line) {\n      return line.indexOf('a=ice-pwd:') === 0;\n    })[0].substr(10)\n  };\n  return iceParameters;\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function (params) {\n  return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n';\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function (mediaSection) {\n  var description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  for (var i = 3; i < mline.length; i++) {\n    // find all codecs from mline[3..]\n    var pt = mline[i];\n    var rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      var codec = SDPUtils.parseRtpMap(rtpmapline);\n      var fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default:\n          // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function (line) {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function (kind, caps) {\n  var sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(function (codec) {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(function (codec) {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  var maxptime = 0;\n  caps.codecs.forEach(function (codec) {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  sdp += 'a=rtcp-mux\\r\\n';\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(function (extension) {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function (mediaSection) {\n  var encodingParameters = [];\n  var description = SDPUtils.parseRtpParameters(mediaSection);\n  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {\n    return SDPUtils.parseSsrcMedia(line);\n  }).filter(function (parts) {\n    return parts.attribute === 'cname';\n  });\n  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  var secondarySsrc;\n\n  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(function (line) {\n    var parts = line.substr(17).split(' ');\n    return parts.map(function (part) {\n      return parseInt(part, 10);\n    });\n  });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(function (codec) {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      var encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10)\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = { ssrc: secondarySsrc };\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: secondarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(function (params) {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function (mediaSection) {\n  var rtcpParameters = {};\n\n  var cname;\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {\n    return SDPUtils.parseSsrcMedia(line);\n  }).filter(function (obj) {\n    return obj.attribute === 'cname';\n  })[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrіbute.\n  // Note that Edge does not support unmuxed RTCP.\n  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function (mediaSection) {\n  var parts;\n  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return { stream: parts[0], track: parts[1] };\n  }\n  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {\n    return SDPUtils.parseSsrcMedia(line);\n  }).filter(function (parts) {\n    return parts.attribute === 'msid';\n  });\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return { stream: parts[0], track: parts[1] };\n  }\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function () {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boilder plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\nSDPUtils.writeSessionBoilerplate = function (sessId, sessVer) {\n  var sessionId;\n  var version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' + 'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n';\n};\n\nSDPUtils.writeMediaSection = function (transceiver, caps, type, stream) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.direction) {\n    sdp += 'a=' + transceiver.direction + '\\r\\n';\n  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    // spec.\n    var msid = 'msid:' + stream.id + ' ' + transceiver.rtpSender.track.id + '\\r\\n';\n    sdp += 'a=' + msid;\n\n    // for Chrome.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function (mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  var lines = SDPUtils.splitLines(mediaSection);\n  for (var i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n      // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function (mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function (mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function (mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\n\nSDPUtils.parseOLine = function (mediaSection) {\n  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  var parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5]\n  };\n};\n\n// Expose public methods.\nif (true) {\n  module.exports = SDPUtils;\n}\n\n//# sourceURL=webpack:///./node_modules/sdp/sdp.js?");

/***/ }),

/***/ "./node_modules/spark-md5/spark-md5.js":
/*!*********************************************!*\
  !*** ./node_modules/spark-md5/spark-md5.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function (factory) {\n    if (true) {\n        // Node/CommonJS\n        module.exports = factory();\n    } else { var glob; }\n})(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n\n    var add32 = function (a, b) {\n        return a + b & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32(a << s | a >>> 32 - s, b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b = (b << 21 | b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b = (b << 21 | b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b = (b << 21 | b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);\n        }\n        tail[i >> 2] |= 0x80 << (i % 4 << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << (i % 4 << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << (i % 4 << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[n >> j * 8 + 4 & 0x0F] + hex_chr[n >> j * 8 & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return msw << 16 | lsw & 0xFFFF;\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = val | 0 || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n            buff = new ArrayBuffer(length),\n            arr = new Uint8Array(buff),\n            i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << (i % 4 << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << (i % 4 << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n});\n\n//# sourceURL=webpack:///./node_modules/spark-md5/spark-md5.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/adapter_core.js":
/*!************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_core.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\nvar adapterFactory = __webpack_require__(/*! ./adapter_factory.js */ \"./node_modules/webrtc-adapter/src/js/adapter_factory.js\");\nmodule.exports = adapterFactory({ window: global.window });\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/adapter_core.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/adapter_factory.js":
/*!***************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_factory.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n// Shimming starts here.\nmodule.exports = function (dependencies, opts) {\n  var window = dependencies && dependencies.window;\n\n  var options = {\n    shimChrome: true,\n    shimFirefox: true,\n    shimEdge: true,\n    shimSafari: true\n  };\n\n  for (var key in opts) {\n    if (hasOwnProperty.call(opts, key)) {\n      options[key] = opts[key];\n    }\n  }\n\n  // Utils.\n  var logging = utils.log;\n  var browserDetails = utils.detectBrowser(window);\n\n  // Uncomment the line below if you want logging to occur, including logging\n  // for the switch statement below. Can also be turned on in the browser via\n  // adapter.disableLog(false), but then logging from the switch statement below\n  // will not appear.\n  // require('./utils').disableLog(false);\n\n  // Browser shims.\n  var chromeShim = __webpack_require__(/*! ./chrome/chrome_shim */ \"./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js\") || null;\n  var edgeShim = __webpack_require__(/*! ./edge/edge_shim */ \"./node_modules/webrtc-adapter/src/js/edge/edge_shim.js\") || null;\n  var firefoxShim = __webpack_require__(/*! ./firefox/firefox_shim */ \"./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js\") || null;\n  var safariShim = __webpack_require__(/*! ./safari/safari_shim */ \"./node_modules/webrtc-adapter/src/js/safari/safari_shim.js\") || null;\n  var commonShim = __webpack_require__(/*! ./common_shim */ \"./node_modules/webrtc-adapter/src/js/common_shim.js\") || null;\n\n  // Export to the adapter global object visible in the browser.\n  var adapter = {\n    browserDetails: browserDetails,\n    commonShim: commonShim,\n    extractVersion: utils.extractVersion,\n    disableLog: utils.disableLog,\n    disableWarnings: utils.disableWarnings\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = chromeShim;\n      commonShim.shimCreateObjectURL(window);\n\n      chromeShim.shimGetUserMedia(window);\n      chromeShim.shimMediaStream(window);\n      chromeShim.shimSourceObject(window);\n      chromeShim.shimPeerConnection(window);\n      chromeShim.shimOnTrack(window);\n      chromeShim.shimAddTrackRemoveTrack(window);\n      chromeShim.shimGetSendersWithDtmf(window);\n      chromeShim.shimSenderReceiverGetStats(window);\n      chromeShim.fixNegotiationNeeded(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'firefox':\n      if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = firefoxShim;\n      commonShim.shimCreateObjectURL(window);\n\n      firefoxShim.shimGetUserMedia(window);\n      firefoxShim.shimSourceObject(window);\n      firefoxShim.shimPeerConnection(window);\n      firefoxShim.shimOnTrack(window);\n      firefoxShim.shimRemoveStream(window);\n      firefoxShim.shimSenderGetStats(window);\n      firefoxShim.shimReceiverGetStats(window);\n      firefoxShim.shimRTCDataChannel(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'edge':\n      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {\n        logging('MS edge shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming edge.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = edgeShim;\n      commonShim.shimCreateObjectURL(window);\n\n      edgeShim.shimGetUserMedia(window);\n      edgeShim.shimPeerConnection(window);\n      edgeShim.shimReplaceTrack(window);\n\n      // the edge shim implements the full RTCIceCandidate object.\n\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'safari':\n      if (!safariShim || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = safariShim;\n      commonShim.shimCreateObjectURL(window);\n\n      safariShim.shimRTCIceServerUrls(window);\n      safariShim.shimCallbacksAPI(window);\n      safariShim.shimLocalStreamsAPI(window);\n      safariShim.shimRemoteStreamsAPI(window);\n      safariShim.shimTrackEventTransceiver(window);\n      safariShim.shimGetUserMedia(window);\n      safariShim.shimCreateOfferLegacy(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n\n  return adapter;\n};\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/adapter_factory.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nvar utils = __webpack_require__(/*! ../utils.js */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\nvar logging = utils.log;\n\n/* iterates the stats graph recursively. */\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(function (name) {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(function (id) {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n\n/* filter getStats for a sender/receiver track. */\nfunction filterStats(result, track, outbound) {\n  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  var filteredResult = new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  var trackStats = [];\n  result.forEach(function (value) {\n    if (value.type === 'track' && value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(function (trackStat) {\n    result.forEach(function (stats) {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\n\nmodule.exports = {\n  shimGetUserMedia: __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js\"),\n  shimMediaStream: function (window) {\n    window.MediaStream = window.MediaStream || window.webkitMediaStream;\n  },\n\n  shimOnTrack: function (window) {\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n        get: function () {\n          return this._ontrack;\n        },\n        set: function (f) {\n          if (this._ontrack) {\n            this.removeEventListener('track', this._ontrack);\n          }\n          this.addEventListener('track', this._ontrack = f);\n        },\n        enumerable: true,\n        configurable: true\n      });\n      var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n      window.RTCPeerConnection.prototype.setRemoteDescription = function () {\n        var pc = this;\n        if (!pc._ontrackpoly) {\n          pc._ontrackpoly = function (e) {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', function (te) {\n              var receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = pc.getReceivers().find(function (r) {\n                  return r.track && r.track.id === te.track.id;\n                });\n              } else {\n                receiver = { track: te.track };\n              }\n\n              var event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = { receiver: receiver };\n              event.streams = [e.stream];\n              pc.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(function (track) {\n              var receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = pc.getReceivers().find(function (r) {\n                  return r.track && r.track.id === track.id;\n                });\n              } else {\n                receiver = { track: track };\n              }\n              var event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = { receiver: receiver };\n              event.streams = [e.stream];\n              pc.dispatchEvent(event);\n            });\n          };\n          pc.addEventListener('addstream', pc._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(pc, arguments);\n      };\n    } else if (!('RTCRtpTransceiver' in window)) {\n      utils.wrapPeerConnectionEvent(window, 'track', function (e) {\n        if (!e.transceiver) {\n          e.transceiver = { receiver: e.receiver };\n        }\n        return e;\n      });\n    }\n  },\n\n  shimGetSendersWithDtmf: function (window) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {\n      var shimSenderWithDtmf = function (pc, track) {\n        return {\n          track: track,\n          get dtmf() {\n            if (this._dtmf === undefined) {\n              if (track.kind === 'audio') {\n                this._dtmf = pc.createDTMFSender(track);\n              } else {\n                this._dtmf = null;\n              }\n            }\n            return this._dtmf;\n          },\n          _pc: pc\n        };\n      };\n\n      // augment addTrack when getSenders is not available.\n      if (!window.RTCPeerConnection.prototype.getSenders) {\n        window.RTCPeerConnection.prototype.getSenders = function () {\n          this._senders = this._senders || [];\n          return this._senders.slice(); // return a copy of the internal state.\n        };\n        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n        window.RTCPeerConnection.prototype.addTrack = function (track, stream) {\n          var pc = this;\n          var sender = origAddTrack.apply(pc, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(pc, track);\n            pc._senders.push(sender);\n          }\n          return sender;\n        };\n\n        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n        window.RTCPeerConnection.prototype.removeTrack = function (sender) {\n          var pc = this;\n          origRemoveTrack.apply(pc, arguments);\n          var idx = pc._senders.indexOf(sender);\n          if (idx !== -1) {\n            pc._senders.splice(idx, 1);\n          }\n        };\n      }\n      var origAddStream = window.RTCPeerConnection.prototype.addStream;\n      window.RTCPeerConnection.prototype.addStream = function (stream) {\n        var pc = this;\n        pc._senders = pc._senders || [];\n        origAddStream.apply(pc, [stream]);\n        stream.getTracks().forEach(function (track) {\n          pc._senders.push(shimSenderWithDtmf(pc, track));\n        });\n      };\n\n      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n      window.RTCPeerConnection.prototype.removeStream = function (stream) {\n        var pc = this;\n        pc._senders = pc._senders || [];\n        origRemoveStream.apply(pc, [stream]);\n\n        stream.getTracks().forEach(function (track) {\n          var sender = pc._senders.find(function (s) {\n            return s.track === track;\n          });\n          if (sender) {\n            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender\n          }\n        });\n      };\n    } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n      window.RTCPeerConnection.prototype.getSenders = function () {\n        var pc = this;\n        var senders = origGetSenders.apply(pc, []);\n        senders.forEach(function (sender) {\n          sender._pc = pc;\n        });\n        return senders;\n      };\n\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n        get: function () {\n          if (this._dtmf === undefined) {\n            if (this.track.kind === 'audio') {\n              this._dtmf = this._pc.createDTMFSender(this.track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        }\n      });\n    }\n  },\n\n  shimSenderReceiverGetStats: function (window) {\n    if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {\n      return;\n    }\n\n    // shim sender stats.\n    if (!('getStats' in window.RTCRtpSender.prototype)) {\n      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n      if (origGetSenders) {\n        window.RTCPeerConnection.prototype.getSenders = function () {\n          var pc = this;\n          var senders = origGetSenders.apply(pc, []);\n          senders.forEach(function (sender) {\n            sender._pc = pc;\n          });\n          return senders;\n        };\n      }\n\n      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      if (origAddTrack) {\n        window.RTCPeerConnection.prototype.addTrack = function () {\n          var sender = origAddTrack.apply(this, arguments);\n          sender._pc = this;\n          return sender;\n        };\n      }\n      window.RTCRtpSender.prototype.getStats = function () {\n        var sender = this;\n        return this._pc.getStats().then(function (result) {\n          /* Note: this will include stats of all senders that\n           *   send a track with the same id as sender.track as\n           *   it is not possible to identify the RTCRtpSender.\n           */\n          return filterStats(result, sender.track, true);\n        });\n      };\n    }\n\n    // shim receiver stats.\n    if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n      var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n      if (origGetReceivers) {\n        window.RTCPeerConnection.prototype.getReceivers = function () {\n          var pc = this;\n          var receivers = origGetReceivers.apply(pc, []);\n          receivers.forEach(function (receiver) {\n            receiver._pc = pc;\n          });\n          return receivers;\n        };\n      }\n      utils.wrapPeerConnectionEvent(window, 'track', function (e) {\n        e.receiver._pc = e.srcElement;\n        return e;\n      });\n      window.RTCRtpReceiver.prototype.getStats = function () {\n        var receiver = this;\n        return this._pc.getStats().then(function (result) {\n          return filterStats(result, receiver.track, false);\n        });\n      };\n    }\n\n    if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {\n      return;\n    }\n\n    // shim RTCPeerConnection.getStats(track).\n    var origGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function () {\n      var pc = this;\n      if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\n        var track = arguments[0];\n        var sender;\n        var receiver;\n        var err;\n        pc.getSenders().forEach(function (s) {\n          if (s.track === track) {\n            if (sender) {\n              err = true;\n            } else {\n              sender = s;\n            }\n          }\n        });\n        pc.getReceivers().forEach(function (r) {\n          if (r.track === track) {\n            if (receiver) {\n              err = true;\n            } else {\n              receiver = r;\n            }\n          }\n          return r.track === track;\n        });\n        if (err || sender && receiver) {\n          return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\n        } else if (sender) {\n          return sender.getStats();\n        } else if (receiver) {\n          return receiver.getStats();\n        }\n        return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\n      }\n      return origGetStats.apply(pc, arguments);\n    };\n  },\n\n  shimSourceObject: function (window) {\n    var URL = window && window.URL;\n\n    if (typeof window === 'object') {\n      if (window.HTMLMediaElement && !('srcObject' in window.HTMLMediaElement.prototype)) {\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n          get: function () {\n            return this._srcObject;\n          },\n          set: function (stream) {\n            var self = this;\n            // Use _srcObject as a private property for this shim\n            this._srcObject = stream;\n            if (this.src) {\n              URL.revokeObjectURL(this.src);\n            }\n\n            if (!stream) {\n              this.src = '';\n              return undefined;\n            }\n            this.src = URL.createObjectURL(stream);\n            // We need to recreate the blob url when a track is added or\n            // removed. Doing it manually since we want to avoid a recursion.\n            stream.addEventListener('addtrack', function () {\n              if (self.src) {\n                URL.revokeObjectURL(self.src);\n              }\n              self.src = URL.createObjectURL(stream);\n            });\n            stream.addEventListener('removetrack', function () {\n              if (self.src) {\n                URL.revokeObjectURL(self.src);\n              }\n              self.src = URL.createObjectURL(stream);\n            });\n          }\n        });\n      }\n    }\n  },\n\n  shimAddTrackRemoveTrackWithNative: function (window) {\n    // shim addTrack/removeTrack with native variants in order to make\n    // the interactions with legacy getLocalStreams behave as in other browsers.\n    // Keeps a mapping stream.id => [stream, rtpsenders...]\n    window.RTCPeerConnection.prototype.getLocalStreams = function () {\n      var pc = this;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams).map(function (streamId) {\n        return pc._shimmedLocalStreams[streamId][0];\n      });\n    };\n\n    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addTrack = function (track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      var sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function (stream) {\n      var pc = this;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      stream.getTracks().forEach(function (track) {\n        var alreadyExists = pc.getSenders().find(function (s) {\n          return s.track === track;\n        });\n        if (alreadyExists) {\n          throw new DOMException('Track already exists.', 'InvalidAccessError');\n        }\n      });\n      var existingSenders = pc.getSenders();\n      origAddStream.apply(this, arguments);\n      var newSenders = pc.getSenders().filter(function (newSender) {\n        return existingSenders.indexOf(newSender) === -1;\n      });\n      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n    };\n\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function (stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n    window.RTCPeerConnection.prototype.removeTrack = function (sender) {\n      var pc = this;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {\n          var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            pc._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (pc._shimmedLocalStreams[streamId].length === 1) {\n            delete pc._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n  },\n\n  shimAddTrackRemoveTrack: function (window) {\n    var browserDetails = utils.detectBrowser(window);\n    // shim addTrack and removeTrack.\n    if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n      return this.shimAddTrackRemoveTrackWithNative(window);\n    }\n\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\n    window.RTCPeerConnection.prototype.getLocalStreams = function () {\n      var pc = this;\n      var nativeStreams = origGetLocalStreams.apply(this);\n      pc._reverseStreams = pc._reverseStreams || {};\n      return nativeStreams.map(function (stream) {\n        return pc._reverseStreams[stream.id];\n      });\n    };\n\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function (stream) {\n      var pc = this;\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n\n      stream.getTracks().forEach(function (track) {\n        var alreadyExists = pc.getSenders().find(function (s) {\n          return s.track === track;\n        });\n        if (alreadyExists) {\n          throw new DOMException('Track already exists.', 'InvalidAccessError');\n        }\n      });\n      // Add identity mapping for consistency with addTrack.\n      // Unless this is being used with a stream from addTrack.\n      if (!pc._reverseStreams[stream.id]) {\n        var newStream = new window.MediaStream(stream.getTracks());\n        pc._streams[stream.id] = newStream;\n        pc._reverseStreams[newStream.id] = stream;\n        stream = newStream;\n      }\n      origAddStream.apply(pc, [stream]);\n    };\n\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function (stream) {\n      var pc = this;\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n\n      origRemoveStream.apply(pc, [pc._streams[stream.id] || stream]);\n      delete pc._reverseStreams[pc._streams[stream.id] ? pc._streams[stream.id].id : stream.id];\n      delete pc._streams[stream.id];\n    };\n\n    window.RTCPeerConnection.prototype.addTrack = function (track, stream) {\n      var pc = this;\n      if (pc.signalingState === 'closed') {\n        throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n      }\n      var streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {\n        return t === track;\n      })) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\n      }\n\n      var alreadyExists = pc.getSenders().find(function (s) {\n        return s.track === track;\n      });\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n      var oldStream = pc._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(function () {\n          pc.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        var newStream = new window.MediaStream([track]);\n        pc._streams[stream.id] = newStream;\n        pc._reverseStreams[newStream.id] = stream;\n        pc.addStream(newStream);\n      }\n      return pc.getSenders().find(function (s) {\n        return s.track === track;\n      });\n    };\n\n    // replace the internal stream id with the external one and\n    // vice versa.\n    function replaceInternalStreamId(pc, description) {\n      var sdp = description.sdp;\n      Object.keys(pc._reverseStreams || []).forEach(function (internalId) {\n        var externalStream = pc._reverseStreams[internalId];\n        var internalStream = pc._streams[externalStream.id];\n        sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\n      });\n      return new RTCSessionDescription({\n        type: description.type,\n        sdp: sdp\n      });\n    }\n    function replaceExternalStreamId(pc, description) {\n      var sdp = description.sdp;\n      Object.keys(pc._reverseStreams || []).forEach(function (internalId) {\n        var externalStream = pc._reverseStreams[internalId];\n        var internalStream = pc._streams[externalStream.id];\n        sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\n      });\n      return new RTCSessionDescription({\n        type: description.type,\n        sdp: sdp\n      });\n    }\n    ['createOffer', 'createAnswer'].forEach(function (method) {\n      var nativeMethod = window.RTCPeerConnection.prototype[method];\n      window.RTCPeerConnection.prototype[method] = function () {\n        var pc = this;\n        var args = arguments;\n        var isLegacyCall = arguments.length && typeof arguments[0] === 'function';\n        if (isLegacyCall) {\n          return nativeMethod.apply(pc, [function (description) {\n            var desc = replaceInternalStreamId(pc, description);\n            args[0].apply(null, [desc]);\n          }, function (err) {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]]);\n        }\n        return nativeMethod.apply(pc, arguments).then(function (description) {\n          return replaceInternalStreamId(pc, description);\n        });\n      };\n    });\n\n    var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n    window.RTCPeerConnection.prototype.setLocalDescription = function () {\n      var pc = this;\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(pc, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(pc, arguments[0]);\n      return origSetLocalDescription.apply(pc, arguments);\n    };\n\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n    var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {\n      get: function () {\n        var pc = this;\n        var description = origLocalDescription.get.apply(this);\n        if (description.type === '') {\n          return description;\n        }\n        return replaceInternalStreamId(pc, description);\n      }\n    });\n\n    window.RTCPeerConnection.prototype.removeTrack = function (sender) {\n      var pc = this;\n      if (pc.signalingState === 'closed') {\n        throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      var isLocal = sender._pc === pc;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      pc._streams = pc._streams || {};\n      var stream;\n      Object.keys(pc._streams).forEach(function (streamid) {\n        var hasTrack = pc._streams[streamid].getTracks().find(function (track) {\n          return sender.track === track;\n        });\n        if (hasTrack) {\n          stream = pc._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          pc.removeStream(pc._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        pc.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n  },\n\n  shimPeerConnection: function (window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    // The RTCPeerConnection object.\n    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n      window.RTCPeerConnection = function (pcConfig, pcConstraints) {\n        // Translate iceTransportPolicy to iceTransports,\n        // see https://code.google.com/p/webrtc/issues/detail?id=4869\n        // this was fixed in M56 along with unprefixing RTCPeerConnection.\n        logging('PeerConnection');\n        if (pcConfig && pcConfig.iceTransportPolicy) {\n          pcConfig.iceTransports = pcConfig.iceTransportPolicy;\n        }\n\n        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype = window.webkitRTCPeerConnection.prototype;\n      // wrap static methods. Currently just generateCertificate.\n      if (window.webkitRTCPeerConnection.generateCertificate) {\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n          get: function () {\n            return window.webkitRTCPeerConnection.generateCertificate;\n          }\n        });\n      }\n    } else {\n      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n      var OrigPeerConnection = window.RTCPeerConnection;\n      window.RTCPeerConnection = function (pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n          var newIceServers = [];\n          for (var i = 0; i < pcConfig.iceServers.length; i++) {\n            var server = pcConfig.iceServers[i];\n            if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {\n              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n              server = JSON.parse(JSON.stringify(server));\n              server.urls = server.url;\n              newIceServers.push(server);\n            } else {\n              newIceServers.push(pcConfig.iceServers[i]);\n            }\n          }\n          pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n      // wrap static methods. Currently just generateCertificate.\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n        get: function () {\n          return OrigPeerConnection.generateCertificate;\n        }\n      });\n    }\n\n    var origGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function (selector, successCallback, errorCallback) {\n      var pc = this;\n      var args = arguments;\n\n      // If selector is a function then we are in the old style stats so just\n      // pass back the original getStats format to avoid breaking old users.\n      if (arguments.length > 0 && typeof selector === 'function') {\n        return origGetStats.apply(this, arguments);\n      }\n\n      // When spec-style getStats is supported, return those when called with\n      // either no arguments or the selector argument is null.\n      if (origGetStats.length === 0 && (arguments.length === 0 || typeof arguments[0] !== 'function')) {\n        return origGetStats.apply(this, []);\n      }\n\n      var fixChromeStats_ = function (response) {\n        var standardReport = {};\n        var reports = response.result();\n        reports.forEach(function (report) {\n          var standardStats = {\n            id: report.id,\n            timestamp: report.timestamp,\n            type: {\n              localcandidate: 'local-candidate',\n              remotecandidate: 'remote-candidate'\n            }[report.type] || report.type\n          };\n          report.names().forEach(function (name) {\n            standardStats[name] = report.stat(name);\n          });\n          standardReport[standardStats.id] = standardStats;\n        });\n\n        return standardReport;\n      };\n\n      // shim getStats with maplike support\n      var makeMapStats = function (stats) {\n        return new Map(Object.keys(stats).map(function (key) {\n          return [key, stats[key]];\n        }));\n      };\n\n      if (arguments.length >= 2) {\n        var successCallbackWrapper_ = function (response) {\n          args[1](makeMapStats(fixChromeStats_(response)));\n        };\n\n        return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]);\n      }\n\n      // promise-support\n      return new Promise(function (resolve, reject) {\n        origGetStats.apply(pc, [function (response) {\n          resolve(makeMapStats(fixChromeStats_(response)));\n        }, reject]);\n      }).then(successCallback, errorCallback);\n    };\n\n    // add promise support -- natively available in Chrome 51\n    if (browserDetails.version < 51) {\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n        var nativeMethod = window.RTCPeerConnection.prototype[method];\n        window.RTCPeerConnection.prototype[method] = function () {\n          var args = arguments;\n          var pc = this;\n          var promise = new Promise(function (resolve, reject) {\n            nativeMethod.apply(pc, [args[0], resolve, reject]);\n          });\n          if (args.length < 2) {\n            return promise;\n          }\n          return promise.then(function () {\n            args[1].apply(null, []);\n          }, function (err) {\n            if (args.length >= 3) {\n              args[2].apply(null, [err]);\n            }\n          });\n        };\n      });\n    }\n\n    // promise support for createOffer and createAnswer. Available (without\n    // bugs) since M52: crbug/619289\n    if (browserDetails.version < 52) {\n      ['createOffer', 'createAnswer'].forEach(function (method) {\n        var nativeMethod = window.RTCPeerConnection.prototype[method];\n        window.RTCPeerConnection.prototype[method] = function () {\n          var pc = this;\n          if (arguments.length < 1 || arguments.length === 1 && typeof arguments[0] === 'object') {\n            var opts = arguments.length === 1 ? arguments[0] : undefined;\n            return new Promise(function (resolve, reject) {\n              nativeMethod.apply(pc, [resolve, reject, opts]);\n            });\n          }\n          return nativeMethod.apply(this, arguments);\n        };\n      });\n    }\n\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      var nativeMethod = window.RTCPeerConnection.prototype[method];\n      window.RTCPeerConnection.prototype[method] = function () {\n        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n        return nativeMethod.apply(this, arguments);\n      };\n    });\n\n    // support for addIceCandidate(null or undefined)\n    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;\n    window.RTCPeerConnection.prototype.addIceCandidate = function () {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n  },\n\n  fixNegotiationNeeded: function (window) {\n    utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {\n      var pc = e.target;\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n      return e;\n    });\n  },\n\n  shimGetDisplayMedia: function (window, getSourceId) {\n    if ('getDisplayMedia' in window.navigator) {\n      return;\n    }\n    // getSourceId is a function that returns a promise resolving with\n    // the sourceId of the screen/window/tab to be shared.\n    if (typeof getSourceId !== 'function') {\n      console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');\n      return;\n    }\n    navigator.getDisplayMedia = function (constraints) {\n      return getSourceId(constraints).then(function (sourceId) {\n        constraints.video = {\n          mandatory: {\n            chromeMediaSource: 'desktop',\n            chromeMediaSourceId: sourceId,\n            maxFrameRate: constraints.video.frameRate || 3\n          }\n        };\n        return navigator.mediaDevices.getUserMedia(constraints);\n      });\n    };\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nvar utils = __webpack_require__(/*! ../utils.js */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\nvar logging = utils.log;\n\n// Expose public methods.\nmodule.exports = function (window) {\n  var browserDetails = utils.detectBrowser(window);\n  var navigator = window && window.navigator;\n\n  var constraintsToChrome_ = function (c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    var cc = {};\n    Object.keys(c).forEach(function (key) {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      var r = typeof c[key] === 'object' ? c[key] : { ideal: c[key] };\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      var oldname_ = function (prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return name === 'deviceId' ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        var oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(function (mix) {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n\n  var shimConstraints_ = function (constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      var remap = function (obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      var face = constraints.video.facingMode;\n      face = face && (typeof face === 'object' ? face : { ideal: face });\n      var getSupportedFacingModeLies = browserDetails.version < 66;\n\n      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        var matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices().then(function (devices) {\n            devices = devices.filter(function (d) {\n              return d.kind === 'videoinput';\n            });\n            var dev = devices.find(function (d) {\n              return matches.some(function (match) {\n                return d.label.toLowerCase().indexOf(match) !== -1;\n              });\n            });\n            if (!dev && devices.length && matches.indexOf('back') !== -1) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  var shimError_ = function (e) {\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString: function () {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  var getUserMedia_ = function (constraints, onSuccess, onError) {\n    shimConstraints_(constraints, function (c) {\n      navigator.webkitGetUserMedia(c, onSuccess, function (e) {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n\n  navigator.getUserMedia = getUserMedia_;\n\n  // Returns the result of getUserMedia as a Promise.\n  var getUserMediaPromise_ = function (constraints) {\n    return new Promise(function (resolve, reject) {\n      navigator.getUserMedia(constraints, resolve, reject);\n    });\n  };\n\n  if (!navigator.mediaDevices) {\n    navigator.mediaDevices = {\n      getUserMedia: getUserMediaPromise_,\n      enumerateDevices: function () {\n        return new Promise(function (resolve) {\n          var kinds = { audio: 'audioinput', video: 'videoinput' };\n          return window.MediaStreamTrack.getSources(function (devices) {\n            resolve(devices.map(function (device) {\n              return { label: device.label,\n                kind: kinds[device.kind],\n                deviceId: device.id,\n                groupId: '' };\n            }));\n          });\n        });\n      },\n      getSupportedConstraints: function () {\n        return {\n          deviceId: true, echoCancellation: true, facingMode: true,\n          frameRate: true, height: true, width: true\n        };\n      }\n    };\n  }\n\n  // A shim for getUserMedia method on the mediaDevices object.\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\n  if (!navigator.mediaDevices.getUserMedia) {\n    navigator.mediaDevices.getUserMedia = function (constraints) {\n      return getUserMediaPromise_(constraints);\n    };\n  } else {\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function (cs) {\n      return shimConstraints_(cs, function (c) {\n        return origGetUserMedia(c).then(function (stream) {\n          if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n            stream.getTracks().forEach(function (track) {\n              track.stop();\n            });\n            throw new DOMException('', 'NotFoundError');\n          }\n          return stream;\n        }, function (e) {\n          return Promise.reject(shimError_(e));\n        });\n      });\n    };\n  }\n\n  // Dummy devicechange event methods.\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\n  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {\n    navigator.mediaDevices.addEventListener = function () {\n      logging('Dummy mediaDevices.addEventListener called.');\n    };\n  }\n  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {\n    navigator.mediaDevices.removeEventListener = function () {\n      logging('Dummy mediaDevices.removeEventListener called.');\n    };\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/common_shim.js":
/*!***********************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/common_shim.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nvar SDPUtils = __webpack_require__(/*! sdp */ \"./node_modules/sdp/sdp.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n\nmodule.exports = {\n  shimRTCIceCandidate: function (window) {\n    // foundation is arbitrarily chosen as an indicator for full support for\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n    if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {\n      return;\n    }\n\n    var NativeRTCIceCandidate = window.RTCIceCandidate;\n    window.RTCIceCandidate = function (args) {\n      // Remove the a= which shouldn't be part of the candidate string.\n      if (typeof args === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {\n        args = JSON.parse(JSON.stringify(args));\n        args.candidate = args.candidate.substr(2);\n      }\n\n      if (args.candidate && args.candidate.length) {\n        // Augment the native candidate with the parsed fields.\n        var nativeCandidate = new NativeRTCIceCandidate(args);\n        var parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n        var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);\n\n        // Add a serializer that does not serialize the extra attributes.\n        augmentedCandidate.toJSON = function () {\n          return {\n            candidate: augmentedCandidate.candidate,\n            sdpMid: augmentedCandidate.sdpMid,\n            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\n            usernameFragment: augmentedCandidate.usernameFragment\n          };\n        };\n        return augmentedCandidate;\n      }\n      return new NativeRTCIceCandidate(args);\n    };\n    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {\n      if (e.candidate) {\n        Object.defineProperty(e, 'candidate', {\n          value: new window.RTCIceCandidate(e.candidate),\n          writable: 'false'\n        });\n      }\n      return e;\n    });\n  },\n\n  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.\n\n  shimCreateObjectURL: function (window) {\n    var URL = window && window.URL;\n\n    if (!(typeof window === 'object' && window.HTMLMediaElement && 'srcObject' in window.HTMLMediaElement.prototype && URL.createObjectURL && URL.revokeObjectURL)) {\n      // Only shim CreateObjectURL using srcObject if srcObject exists.\n      return undefined;\n    }\n\n    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);\n    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);\n    var streams = new Map(),\n        newId = 0;\n\n    URL.createObjectURL = function (stream) {\n      if ('getTracks' in stream) {\n        var url = 'polyblob:' + ++newId;\n        streams.set(url, stream);\n        utils.deprecated('URL.createObjectURL(stream)', 'elem.srcObject = stream');\n        return url;\n      }\n      return nativeCreateObjectURL(stream);\n    };\n    URL.revokeObjectURL = function (url) {\n      nativeRevokeObjectURL(url);\n      streams.delete(url);\n    };\n\n    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype, 'src');\n    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {\n      get: function () {\n        return dsc.get.apply(this);\n      },\n      set: function (url) {\n        this.srcObject = streams.get(url) || null;\n        return dsc.set.apply(this, [url]);\n      }\n    });\n\n    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;\n    window.HTMLMediaElement.prototype.setAttribute = function () {\n      if (arguments.length === 2 && ('' + arguments[0]).toLowerCase() === 'src') {\n        this.srcObject = streams.get(arguments[1]) || null;\n      }\n      return nativeSetAttribute.apply(this, arguments);\n    };\n  },\n\n  shimMaxMessageSize: function (window) {\n    if (window.RTCSctpTransport || !window.RTCPeerConnection) {\n      return;\n    }\n    var browserDetails = utils.detectBrowser(window);\n\n    if (!('sctp' in window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n        get: function () {\n          return typeof this._sctp === 'undefined' ? null : this._sctp;\n        }\n      });\n    }\n\n    var sctpInDescription = function (description) {\n      var sections = SDPUtils.splitSections(description.sdp);\n      sections.shift();\n      return sections.some(function (mediaSection) {\n        var mLine = SDPUtils.parseMLine(mediaSection);\n        return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;\n      });\n    };\n\n    var getRemoteFirefoxVersion = function (description) {\n      // TODO: Is there a better solution for detecting Firefox?\n      var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n      if (match === null || match.length < 2) {\n        return -1;\n      }\n      var version = parseInt(match[1], 10);\n      // Test for NaN (yes, this is ugly)\n      return version !== version ? -1 : version;\n    };\n\n    var getCanSendMaxMessageSize = function (remoteIsFirefox) {\n      // Every implementation we know can send at least 64 KiB.\n      // Note: Although Chrome is technically able to send up to 256 KiB, the\n      //       data does not reach the other peer reliably.\n      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n      var canSendMaxMessageSize = 65536;\n      if (browserDetails.browser === 'firefox') {\n        if (browserDetails.version < 57) {\n          if (remoteIsFirefox === -1) {\n            // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n            // fragmentation.\n            canSendMaxMessageSize = 16384;\n          } else {\n            // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n            // messages. Thus, supporting ~2 GiB when sending.\n            canSendMaxMessageSize = 2147483637;\n          }\n        } else if (browserDetails.version < 60) {\n          // Currently, all FF >= 57 will reset the remote maximum message size\n          // to the default value when a data channel is created at a later\n          // stage. :(\n          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n          canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n        } else {\n          // FF >= 60 supports sending ~2 GiB\n          canSendMaxMessageSize = 2147483637;\n        }\n      }\n      return canSendMaxMessageSize;\n    };\n\n    var getMaxMessageSize = function (description, remoteIsFirefox) {\n      // Note: 65536 bytes is the default value from the SDP spec. Also,\n      //       every implementation we know supports receiving 65536 bytes.\n      var maxMessageSize = 65536;\n\n      // FF 57 has a slightly incorrect default remote max message size, so\n      // we need to adjust it here to avoid a failure when sending.\n      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n      if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {\n        maxMessageSize = 65535;\n      }\n\n      var match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');\n      if (match.length > 0) {\n        maxMessageSize = parseInt(match[0].substr(19), 10);\n      } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {\n        // If the maximum message size is not present in the remote SDP and\n        // both local and remote are Firefox, the remote peer can receive\n        // ~2 GiB.\n        maxMessageSize = 2147483637;\n      }\n      return maxMessageSize;\n    };\n\n    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function () {\n      var pc = this;\n      pc._sctp = null;\n\n      if (sctpInDescription(arguments[0])) {\n        // Check if the remote is FF.\n        var isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n        // Get the maximum message size the local peer is capable of sending\n        var canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n        // Get the maximum message size of the remote peer.\n        var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n        // Determine final maximum message size\n        var maxMessageSize;\n        if (canSendMMS === 0 && remoteMMS === 0) {\n          maxMessageSize = Number.POSITIVE_INFINITY;\n        } else if (canSendMMS === 0 || remoteMMS === 0) {\n          maxMessageSize = Math.max(canSendMMS, remoteMMS);\n        } else {\n          maxMessageSize = Math.min(canSendMMS, remoteMMS);\n        }\n\n        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n        // attribute.\n        var sctp = {};\n        Object.defineProperty(sctp, 'maxMessageSize', {\n          get: function () {\n            return maxMessageSize;\n          }\n        });\n        pc._sctp = sctp;\n      }\n\n      return origSetRemoteDescription.apply(pc, arguments);\n    };\n  },\n\n  shimSendThrowTypeError: function (window) {\n    if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {\n      return;\n    }\n\n    // Note: Although Firefox >= 57 has a native implementation, the maximum\n    //       message size can be reset for all data channels at a later stage.\n    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n    function wrapDcSend(dc, pc) {\n      var origDataChannelSend = dc.send;\n      dc.send = function () {\n        var data = arguments[0];\n        var length = data.length || data.size || data.byteLength;\n        if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {\n          throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');\n        }\n        return origDataChannelSend.apply(dc, arguments);\n      };\n    }\n    var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;\n    window.RTCPeerConnection.prototype.createDataChannel = function () {\n      var pc = this;\n      var dataChannel = origCreateDataChannel.apply(pc, arguments);\n      wrapDcSend(dataChannel, pc);\n      return dataChannel;\n    };\n    utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {\n      wrapDcSend(e.channel, e.target);\n      return e;\n    });\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/common_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/edge/edge_shim.js":
/*!**************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/edge/edge_shim.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\nvar filterIceServers = __webpack_require__(/*! ./filtericeservers */ \"./node_modules/webrtc-adapter/src/js/edge/filtericeservers.js\");\nvar shimRTCPeerConnection = __webpack_require__(/*! rtcpeerconnection-shim */ \"./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js\");\n\nmodule.exports = {\n  shimGetUserMedia: __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/edge/getusermedia.js\"),\n  shimPeerConnection: function (window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    if (window.RTCIceGatherer) {\n      if (!window.RTCIceCandidate) {\n        window.RTCIceCandidate = function (args) {\n          return args;\n        };\n      }\n      if (!window.RTCSessionDescription) {\n        window.RTCSessionDescription = function (args) {\n          return args;\n        };\n      }\n      // this adds an additional event listener to MediaStrackTrack that signals\n      // when a tracks enabled property was changed. Workaround for a bug in\n      // addStream, see below. No longer required in 15025+\n      if (browserDetails.version < 15025) {\n        var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');\n        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {\n          set: function (value) {\n            origMSTEnabled.set.call(this, value);\n            var ev = new Event('enabled');\n            ev.enabled = value;\n            this.dispatchEvent(ev);\n          }\n        });\n      }\n    }\n\n    // ORTC defines the DTMF sender a bit different.\n    // https://github.com/w3c/ortc/issues/714\n    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n        get: function () {\n          if (this._dtmf === undefined) {\n            if (this.track.kind === 'audio') {\n              this._dtmf = new window.RTCDtmfSender(this);\n            } else if (this.track.kind === 'video') {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        }\n      });\n    }\n    // Edge currently only implements the RTCDtmfSender, not the\n    // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*\n    if (window.RTCDtmfSender && !window.RTCDTMFSender) {\n      window.RTCDTMFSender = window.RTCDtmfSender;\n    }\n\n    var RTCPeerConnectionShim = shimRTCPeerConnection(window, browserDetails.version);\n    window.RTCPeerConnection = function (config) {\n      if (config && config.iceServers) {\n        config.iceServers = filterIceServers(config.iceServers);\n      }\n      return new RTCPeerConnectionShim(config);\n    };\n    window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;\n  },\n  shimReplaceTrack: function (window) {\n    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614\n    if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {\n      window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;\n    }\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/edge/edge_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/edge/filtericeservers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/edge/filtericeservers.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nmodule.exports = function (iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function (server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function (url) {\n        var validTurn = url.indexOf('turn:') === 0 && url.indexOf('transport=udp') !== -1 && url.indexOf('turn:[') === -1 && !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 && url.indexOf('?transport=udp') === -1;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/edge/filtericeservers.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/edge/getusermedia.js":
/*!*****************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/edge/getusermedia.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n// Expose public methods.\n\nmodule.exports = function (window) {\n  var navigator = window && window.navigator;\n\n  var shimError_ = function (e) {\n    return {\n      name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint,\n      toString: function () {\n        return this.name;\n      }\n    };\n  };\n\n  // getUserMedia error shim.\n  var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n  navigator.mediaDevices.getUserMedia = function (c) {\n    return origGetUserMedia(c).catch(function (e) {\n      return Promise.reject(shimError_(e));\n    });\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/edge/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n\nmodule.exports = {\n  shimGetUserMedia: __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js\"),\n  shimOnTrack: function (window) {\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n        get: function () {\n          return this._ontrack;\n        },\n        set: function (f) {\n          if (this._ontrack) {\n            this.removeEventListener('track', this._ontrack);\n            this.removeEventListener('addstream', this._ontrackpoly);\n          }\n          this.addEventListener('track', this._ontrack = f);\n          this.addEventListener('addstream', this._ontrackpoly = function (e) {\n            e.stream.getTracks().forEach(function (track) {\n              var event = new Event('track');\n              event.track = track;\n              event.receiver = { track: track };\n              event.transceiver = { receiver: event.receiver };\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            }.bind(this));\n          }.bind(this));\n        }\n      });\n    }\n    if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\n      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n        get: function () {\n          return { receiver: this.receiver };\n        }\n      });\n    }\n  },\n\n  shimSourceObject: function (window) {\n    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.\n    if (typeof window === 'object') {\n      if (window.HTMLMediaElement && !('srcObject' in window.HTMLMediaElement.prototype)) {\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n          get: function () {\n            return this.mozSrcObject;\n          },\n          set: function (stream) {\n            this.mozSrcObject = stream;\n          }\n        });\n      }\n    }\n  },\n\n  shimPeerConnection: function (window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\n      return; // probably media.peerconnection.enabled=false in about:config\n    }\n    // The RTCPeerConnection object.\n    if (!window.RTCPeerConnection) {\n      window.RTCPeerConnection = function (pcConfig, pcConstraints) {\n        if (browserDetails.version < 38) {\n          // .urls is not supported in FF < 38.\n          // create RTCIceServers with a single url.\n          if (pcConfig && pcConfig.iceServers) {\n            var newIceServers = [];\n            for (var i = 0; i < pcConfig.iceServers.length; i++) {\n              var server = pcConfig.iceServers[i];\n              if (server.hasOwnProperty('urls')) {\n                for (var j = 0; j < server.urls.length; j++) {\n                  var newServer = {\n                    url: server.urls[j]\n                  };\n                  if (server.urls[j].indexOf('turn') === 0) {\n                    newServer.username = server.username;\n                    newServer.credential = server.credential;\n                  }\n                  newIceServers.push(newServer);\n                }\n              } else {\n                newIceServers.push(pcConfig.iceServers[i]);\n              }\n            }\n            pcConfig.iceServers = newIceServers;\n          }\n        }\n        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype = window.mozRTCPeerConnection.prototype;\n\n      // wrap static methods. Currently just generateCertificate.\n      if (window.mozRTCPeerConnection.generateCertificate) {\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n          get: function () {\n            return window.mozRTCPeerConnection.generateCertificate;\n          }\n        });\n      }\n\n      window.RTCSessionDescription = window.mozRTCSessionDescription;\n      window.RTCIceCandidate = window.mozRTCIceCandidate;\n    }\n\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      var nativeMethod = window.RTCPeerConnection.prototype[method];\n      window.RTCPeerConnection.prototype[method] = function () {\n        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n        return nativeMethod.apply(this, arguments);\n      };\n    });\n\n    // support for addIceCandidate(null or undefined)\n    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;\n    window.RTCPeerConnection.prototype.addIceCandidate = function () {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n\n    // shim getStats with maplike support\n    var makeMapStats = function (stats) {\n      var map = new Map();\n      Object.keys(stats).forEach(function (key) {\n        map.set(key, stats[key]);\n        map[key] = stats[key];\n      });\n      return map;\n    };\n\n    var modernStatsTypes = {\n      inboundrtp: 'inbound-rtp',\n      outboundrtp: 'outbound-rtp',\n      candidatepair: 'candidate-pair',\n      localcandidate: 'local-candidate',\n      remotecandidate: 'remote-candidate'\n    };\n\n    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function (selector, onSucc, onErr) {\n      return nativeGetStats.apply(this, [selector || null]).then(function (stats) {\n        if (browserDetails.version < 48) {\n          stats = makeMapStats(stats);\n        }\n        if (browserDetails.version < 53 && !onSucc) {\n          // Shim only promise getStats with spec-hyphens in type names\n          // Leave callback version alone; misc old uses of forEach before Map\n          try {\n            stats.forEach(function (stat) {\n              stat.type = modernStatsTypes[stat.type] || stat.type;\n            });\n          } catch (e) {\n            if (e.name !== 'TypeError') {\n              throw e;\n            }\n            // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n            stats.forEach(function (stat, i) {\n              stats.set(i, Object.assign({}, stat, {\n                type: modernStatsTypes[stat.type] || stat.type\n              }));\n            });\n          }\n        }\n        return stats;\n      }).then(onSucc, onErr);\n    };\n  },\n\n  shimSenderGetStats: function (window) {\n    if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\n      return;\n    }\n    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n      return;\n    }\n    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function () {\n        var pc = this;\n        var senders = origGetSenders.apply(pc, []);\n        senders.forEach(function (sender) {\n          sender._pc = pc;\n        });\n        return senders;\n      };\n    }\n\n    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function () {\n        var sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function () {\n      return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n    };\n  },\n\n  shimReceiverGetStats: function (window) {\n    if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\n      return;\n    }\n    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n      return;\n    }\n    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function () {\n        var pc = this;\n        var receivers = origGetReceivers.apply(pc, []);\n        receivers.forEach(function (receiver) {\n          receiver._pc = pc;\n        });\n        return receivers;\n      };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', function (e) {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function () {\n      return this._pc.getStats(this.track);\n    };\n  },\n\n  shimRemoveStream: function (window) {\n    if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {\n      return;\n    }\n    window.RTCPeerConnection.prototype.removeStream = function (stream) {\n      var pc = this;\n      utils.deprecated('removeStream', 'removeTrack');\n      this.getSenders().forEach(function (sender) {\n        if (sender.track && stream.getTracks().indexOf(sender.track) !== -1) {\n          pc.removeTrack(sender);\n        }\n      });\n    };\n  },\n\n  shimRTCDataChannel: function (window) {\n    // rename DataChannel to RTCDataChannel (native fix in FF60):\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n    if (window.DataChannel && !window.RTCDataChannel) {\n      window.RTCDataChannel = window.DataChannel;\n    }\n  },\n\n  shimGetDisplayMedia: function (window, preferredMediaSource) {\n    if ('getDisplayMedia' in window.navigator) {\n      return;\n    }\n    navigator.getDisplayMedia = function (constraints) {\n      if (!(constraints && constraints.video)) {\n        var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');\n        err.name = 'NotFoundError';\n        // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n        err.code = 8;\n        return Promise.reject(err);\n      }\n      if (constraints.video === true) {\n        constraints.video = { mediaSource: preferredMediaSource };\n      } else {\n        constraints.video.mediaSource = preferredMediaSource;\n      }\n      return navigator.mediaDevices.getUserMedia(constraints);\n    };\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\nvar logging = utils.log;\n\n// Expose public methods.\nmodule.exports = function (window) {\n  var browserDetails = utils.detectBrowser(window);\n  var navigator = window && window.navigator;\n  var MediaStreamTrack = window && window.MediaStreamTrack;\n\n  var shimError_ = function (e) {\n    return {\n      name: {\n        InternalError: 'NotReadableError',\n        NotSupportedError: 'TypeError',\n        PermissionDeniedError: 'NotAllowedError',\n        SecurityError: 'NotAllowedError'\n      }[e.name] || e.name,\n      message: {\n        'The operation is insecure.': 'The request is not allowed by the ' + 'user agent or the platform in the current context.'\n      }[e.message] || e.message,\n      constraint: e.constraint,\n      toString: function () {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  // getUserMedia constraints shim.\n  var getUserMedia_ = function (constraints, onSuccess, onError) {\n    var constraintsToFF37_ = function (c) {\n      if (typeof c !== 'object' || c.require) {\n        return c;\n      }\n      var require = [];\n      Object.keys(c).forEach(function (key) {\n        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n          return;\n        }\n        var r = c[key] = typeof c[key] === 'object' ? c[key] : { ideal: c[key] };\n        if (r.min !== undefined || r.max !== undefined || r.exact !== undefined) {\n          require.push(key);\n        }\n        if (r.exact !== undefined) {\n          if (typeof r.exact === 'number') {\n            r.min = r.max = r.exact;\n          } else {\n            c[key] = r.exact;\n          }\n          delete r.exact;\n        }\n        if (r.ideal !== undefined) {\n          c.advanced = c.advanced || [];\n          var oc = {};\n          if (typeof r.ideal === 'number') {\n            oc[key] = { min: r.ideal, max: r.ideal };\n          } else {\n            oc[key] = r.ideal;\n          }\n          c.advanced.push(oc);\n          delete r.ideal;\n          if (!Object.keys(r).length) {\n            delete c[key];\n          }\n        }\n      });\n      if (require.length) {\n        c.require = require;\n      }\n      return c;\n    };\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (browserDetails.version < 38) {\n      logging('spec: ' + JSON.stringify(constraints));\n      if (constraints.audio) {\n        constraints.audio = constraintsToFF37_(constraints.audio);\n      }\n      if (constraints.video) {\n        constraints.video = constraintsToFF37_(constraints.video);\n      }\n      logging('ff37: ' + JSON.stringify(constraints));\n    }\n    return navigator.mozGetUserMedia(constraints, onSuccess, function (e) {\n      onError(shimError_(e));\n    });\n  };\n\n  // Returns the result of getUserMedia as a Promise.\n  var getUserMediaPromise_ = function (constraints) {\n    return new Promise(function (resolve, reject) {\n      getUserMedia_(constraints, resolve, reject);\n    });\n  };\n\n  // Shim for mediaDevices on older versions.\n  if (!navigator.mediaDevices) {\n    navigator.mediaDevices = { getUserMedia: getUserMediaPromise_,\n      addEventListener: function () {},\n      removeEventListener: function () {}\n    };\n  }\n  navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function () {\n    return new Promise(function (resolve) {\n      var infos = [{ kind: 'audioinput', deviceId: 'default', label: '', groupId: '' }, { kind: 'videoinput', deviceId: 'default', label: '', groupId: '' }];\n      resolve(infos);\n    });\n  };\n\n  if (browserDetails.version < 41) {\n    // Work around http://bugzil.la/1169665\n    var orgEnumerateDevices = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);\n    navigator.mediaDevices.enumerateDevices = function () {\n      return orgEnumerateDevices().then(undefined, function (e) {\n        if (e.name === 'NotFoundError') {\n          return [];\n        }\n        throw e;\n      });\n    };\n  }\n  if (browserDetails.version < 49) {\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function (c) {\n      return origGetUserMedia(c).then(function (stream) {\n        // Work around https://bugzil.la/802326\n        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(function (track) {\n            track.stop();\n          });\n          throw new DOMException('The object can not be found here.', 'NotFoundError');\n        }\n        return stream;\n      }, function (e) {\n        return Promise.reject(shimError_(e));\n      });\n    };\n  }\n  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    var remap = function (obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n\n    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function (c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function () {\n        var obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function (c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n  navigator.getUserMedia = function (constraints, onSuccess, onError) {\n    if (browserDetails.version < 44) {\n      return getUserMedia_(constraints, onSuccess, onError);\n    }\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/safari/safari_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/safari/safari_shim.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n\nmodule.exports = {\n  shimLocalStreamsAPI: function (window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getLocalStreams = function () {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        return this._localStreams;\n      };\n    }\n    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getStreamById = function (id) {\n        var result = null;\n        if (this._localStreams) {\n          this._localStreams.forEach(function (stream) {\n            if (stream.id === id) {\n              result = stream;\n            }\n          });\n        }\n        if (this._remoteStreams) {\n          this._remoteStreams.forEach(function (stream) {\n            if (stream.id === id) {\n              result = stream;\n            }\n          });\n        }\n        return result;\n      };\n    }\n    if (!('addStream' in window.RTCPeerConnection.prototype)) {\n      var _addTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addStream = function (stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        if (this._localStreams.indexOf(stream) === -1) {\n          this._localStreams.push(stream);\n        }\n        var pc = this;\n        stream.getTracks().forEach(function (track) {\n          _addTrack.call(pc, track, stream);\n        });\n      };\n\n      window.RTCPeerConnection.prototype.addTrack = function (track, stream) {\n        if (stream) {\n          if (!this._localStreams) {\n            this._localStreams = [stream];\n          } else if (this._localStreams.indexOf(stream) === -1) {\n            this._localStreams.push(stream);\n          }\n        }\n        return _addTrack.call(this, track, stream);\n      };\n    }\n    if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.removeStream = function (stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        var index = this._localStreams.indexOf(stream);\n        if (index === -1) {\n          return;\n        }\n        this._localStreams.splice(index, 1);\n        var pc = this;\n        var tracks = stream.getTracks();\n        this.getSenders().forEach(function (sender) {\n          if (tracks.indexOf(sender.track) !== -1) {\n            pc.removeTrack(sender);\n          }\n        });\n      };\n    }\n  },\n  shimRemoteStreamsAPI: function (window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getRemoteStreams = function () {\n        return this._remoteStreams ? this._remoteStreams : [];\n      };\n    }\n    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n        get: function () {\n          return this._onaddstream;\n        },\n        set: function (f) {\n          var pc = this;\n          if (this._onaddstream) {\n            this.removeEventListener('addstream', this._onaddstream);\n            this.removeEventListener('track', this._onaddstreampoly);\n          }\n          this.addEventListener('addstream', this._onaddstream = f);\n          this.addEventListener('track', this._onaddstreampoly = function (e) {\n            e.streams.forEach(function (stream) {\n              if (!pc._remoteStreams) {\n                pc._remoteStreams = [];\n              }\n              if (pc._remoteStreams.indexOf(stream) >= 0) {\n                return;\n              }\n              pc._remoteStreams.push(stream);\n              var event = new Event('addstream');\n              event.stream = stream;\n              pc.dispatchEvent(event);\n            });\n          });\n        }\n      });\n    }\n  },\n  shimCallbacksAPI: function (window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    var prototype = window.RTCPeerConnection.prototype;\n    var createOffer = prototype.createOffer;\n    var createAnswer = prototype.createAnswer;\n    var setLocalDescription = prototype.setLocalDescription;\n    var setRemoteDescription = prototype.setRemoteDescription;\n    var addIceCandidate = prototype.addIceCandidate;\n\n    prototype.createOffer = function (successCallback, failureCallback) {\n      var options = arguments.length >= 2 ? arguments[2] : arguments[0];\n      var promise = createOffer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n    prototype.createAnswer = function (successCallback, failureCallback) {\n      var options = arguments.length >= 2 ? arguments[2] : arguments[0];\n      var promise = createAnswer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n    var withCallback = function (description, successCallback, failureCallback) {\n      var promise = setLocalDescription.apply(this, [description]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n\n    withCallback = function (description, successCallback, failureCallback) {\n      var promise = setRemoteDescription.apply(this, [description]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n\n    withCallback = function (candidate, successCallback, failureCallback) {\n      var promise = addIceCandidate.apply(this, [candidate]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n  },\n  shimGetUserMedia: function (window) {\n    var navigator = window && window.navigator;\n\n    if (!navigator.getUserMedia) {\n      if (navigator.webkitGetUserMedia) {\n        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\n      } else if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n        navigator.getUserMedia = function (constraints, cb, errcb) {\n          navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n        }.bind(navigator);\n      }\n    }\n  },\n  shimRTCIceServerUrls: function (window) {\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    var OrigPeerConnection = window.RTCPeerConnection;\n    window.RTCPeerConnection = function (pcConfig, pcConstraints) {\n      if (pcConfig && pcConfig.iceServers) {\n        var newIceServers = [];\n        for (var i = 0; i < pcConfig.iceServers.length; i++) {\n          var server = pcConfig.iceServers[i];\n          if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {\n            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n            server = JSON.parse(JSON.stringify(server));\n            server.urls = server.url;\n            delete server.url;\n            newIceServers.push(server);\n          } else {\n            newIceServers.push(pcConfig.iceServers[i]);\n          }\n        }\n        pcConfig.iceServers = newIceServers;\n      }\n      return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    if ('generateCertificate' in window.RTCPeerConnection) {\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n        get: function () {\n          return OrigPeerConnection.generateCertificate;\n        }\n      });\n    }\n  },\n  shimTrackEventTransceiver: function (window) {\n    // Add event.transceiver member over deprecated event.receiver\n    if (typeof window === 'object' && window.RTCPeerConnection && 'receiver' in window.RTCTrackEvent.prototype &&\n    // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is\n    // defined for some reason even when window.RTCTransceiver is not.\n    !window.RTCTransceiver) {\n      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n        get: function () {\n          return { receiver: this.receiver };\n        }\n      });\n    }\n  },\n\n  shimCreateOfferLegacy: function (window) {\n    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n    window.RTCPeerConnection.prototype.createOffer = function (offerOptions) {\n      var pc = this;\n      if (offerOptions) {\n        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n        }\n        var audioTransceiver = pc.getTransceivers().find(function (transceiver) {\n          return transceiver.sender.track && transceiver.sender.track.kind === 'audio';\n        });\n        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n          if (audioTransceiver.direction === 'sendrecv') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('sendonly');\n            } else {\n              audioTransceiver.direction = 'sendonly';\n            }\n          } else if (audioTransceiver.direction === 'recvonly') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('inactive');\n            } else {\n              audioTransceiver.direction = 'inactive';\n            }\n          }\n        } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n          pc.addTransceiver('audio');\n        }\n\n        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n        }\n        var videoTransceiver = pc.getTransceivers().find(function (transceiver) {\n          return transceiver.sender.track && transceiver.sender.track.kind === 'video';\n        });\n        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n          if (videoTransceiver.direction === 'sendrecv') {\n            videoTransceiver.setDirection('sendonly');\n          } else if (videoTransceiver.direction === 'recvonly') {\n            videoTransceiver.setDirection('inactive');\n          }\n        } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n          pc.addTransceiver('video');\n        }\n      }\n      return origCreateOffer.apply(pc, arguments);\n    };\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/safari/safari_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nvar logDisabled_ = true;\nvar deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nfunction extractVersion(uastring, expr, pos) {\n  var match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  var proto = window.RTCPeerConnection.prototype;\n  var nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    var wrappedCallback = function (e) {\n      var modifiedEvent = wrapper(e);\n      if (modifiedEvent) {\n        cb(modifiedEvent);\n      }\n    };\n    this._eventMap = this._eventMap || {};\n    this._eventMap[cb] = wrappedCallback;\n    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);\n  };\n\n  var nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    var unwrappedCb = this._eventMap[cb];\n    delete this._eventMap[cb];\n    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);\n  };\n\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get: function () {\n      return this['_on' + eventNameToWrap];\n    },\n    set: function (cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\n\n// Utility methods.\nmodule.exports = {\n  extractVersion: extractVersion,\n  wrapPeerConnectionEvent: wrapPeerConnectionEvent,\n  disableLog: function (bool) {\n    if (typeof bool !== 'boolean') {\n      return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n    }\n    logDisabled_ = bool;\n    return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';\n  },\n\n  /**\n   * Disable or enable deprecation warnings\n   * @param {!boolean} bool set to true to disable warnings.\n   */\n  disableWarnings: function (bool) {\n    if (typeof bool !== 'boolean') {\n      return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n    }\n    deprecationWarnings_ = !bool;\n    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n  },\n\n  log: function () {\n    if (typeof window === 'object') {\n      if (logDisabled_) {\n        return;\n      }\n      if (typeof console !== 'undefined' && typeof console.log === 'function') {\n        console.log.apply(console, arguments);\n      }\n    }\n  },\n\n  /**\n   * Shows a deprecation warning suggesting the modern and spec-compatible API.\n   */\n  deprecated: function (oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n      return;\n    }\n    console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');\n  },\n\n  /**\n   * Browser detector.\n   *\n   * @return {object} result containing browser and version\n   *     properties.\n   */\n  detectBrowser: function (window) {\n    var navigator = window && window.navigator;\n\n    // Returned result object.\n    var result = {};\n    result.browser = null;\n    result.version = null;\n\n    // Fail early if it's not a browser\n    if (typeof window === 'undefined' || !window.navigator) {\n      result.browser = 'Not a browser.';\n      return result;\n    }\n\n    if (navigator.mozGetUserMedia) {\n      // Firefox.\n      result.browser = 'firefox';\n      result.version = extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1);\n    } else if (navigator.webkitGetUserMedia) {\n      // Chrome, Chromium, Webview, Opera.\n      // Version matches Chrome/WebRTC version.\n      result.browser = 'chrome';\n      result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n    } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n      // Edge.\n      result.browser = 'edge';\n      result.version = extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2);\n    } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n      // Safari.\n      result.browser = 'safari';\n      result.version = extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n    } else {\n      // Default fallthrough: not supported.\n      result.browser = 'Not a supported browser.';\n      return result;\n    }\n\n    return result;\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/webrtc-adapter/src/js/utils.js?");

/***/ }),

/***/ "./resources/css/phone.scss":
/*!**********************************!*\
  !*** ./resources/css/phone.scss ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./resources/css/phone.scss?");

/***/ }),

/***/ "./src/lib/Logger.js":
/*!***************************!*\
  !*** ./src/lib/Logger.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst APP_NAME = 'jssip-wrap';\n\nclass Logger {\n\tconstructor(prefix) {\n\t\tif (prefix) {\n\t\t\tthis._debug = (0, _debug2.default)(APP_NAME + ':' + prefix);\n\t\t\tthis._warn = (0, _debug2.default)(APP_NAME + ':WARN:' + prefix);\n\t\t\tthis._error = (0, _debug2.default)(APP_NAME + ':ERROR:' + prefix);\n\t\t} else {\n\t\t\tthis._debug = (0, _debug2.default)(APP_NAME);\n\t\t\tthis._warn = (0, _debug2.default)(APP_NAME + ':WARN');\n\t\t\tthis._error = (0, _debug2.default)(APP_NAME + ':ERROR');\n\t\t}\n\n\t\tthis._debug.log = console.info.bind(console);\n\t\tthis._warn.log = console.warn.bind(console);\n\t\tthis._error.log = console.error.bind(console);\n\t}\n\n\tget debug() {\n\t\treturn this._debug;\n\t}\n\n\tget warn() {\n\t\treturn this._warn;\n\t}\n\n\tget error() {\n\t\treturn this._error;\n\t}\n}\nexports.default = Logger;\n\n//# sourceURL=webpack:///./src/lib/Logger.js?");

/***/ }),

/***/ "./src/lib/getLoginInfo.js":
/*!*********************************!*\
  !*** ./src/lib/getLoginInfo.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Logger = __webpack_require__(/*! ./Logger */ \"./src/lib/Logger.js\");\n\nvar _Logger2 = _interopRequireDefault(_Logger);\n\nvar _sparkMd = __webpack_require__(/*! spark-md5 */ \"./node_modules/spark-md5/spark-md5.js\");\n\nvar _sparkMd2 = _interopRequireDefault(_sparkMd);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst logger = new _Logger2.default('getLoginInfo');\n\n// https://stackoverflow.com/questions/4484424/underscore-prefix-for-property-and-method-names-in-javascript\n// https://stackoverflow.com/questions/22097603/unit-testing-of-private-functions-with-mocha-and-node-js\n// js convention that _ as private function, no need to export, but export for mochas test\n\n\n/**\n * 1 通过json文件获取运维地址\n * 2 getInfo 获取运维信息\n * 3 getEpProfile 获取企业信息\n * 4 getMemberInfo 获取登录所选组\n * 5 updateInfo 更新模式  callintype  -- 2 voip  4 电路  5 sip话机\n */\nasync function getLoginData(un, pwd, switchNumber, callintype, phoneNumber) {\n    try {\n        // 参数校验\n        if (un == undefined || pwd == undefined || switchNumber == undefined || callintype == undefined || (Number(callintype) == 4 || Number(callintype) == 5) && phoneNumber == undefined) throw { status: 50003, info: '获取信息失败,参数错误', step: 'checkParam' };\n\n        // 获取 运维服务器地址 \n        var server = await loadServerFromJson(switchNumber);\n        if (server == undefined || server.length == 0) throw { status: 50000, info: '获取服务器失败', step: 'getESserver' };\n        var PWD = _sparkMd2.default.hash(pwd);\n        var randkey1 = Math.random().toString().split('.')[1].substr(0, 8); //8位随机串\n        var randkey2 = Math.random().toString().split('.')[1].substr(0, 6); //6位随机串\n\n        var obj = {\n            pwd: PWD,\n            clearPwd: randkey1 + pwd + randkey2,\n            switchNumber: switchNumber,\n            callintype: callintype,\n            oldCallType: callintype\n        };\n        if (Number(callintype) == 4) obj.phoneNumber = phoneNumber.startsWith('A') && phoneNumber.endsWith('Z') ? phoneNumber.slice(1, phoneNumber.length - 1) : phoneNumber;;\n        if (Number(callintype) == 5) obj.sipNumber = phoneNumber;\n        localStorage.setItem('userData', JSON.stringify(obj));\n        var infoData = await getInfo(un, pwd, switchNumber, server);\n        if (infoData.status != 200) throw infoData;\n        var webParam = {\n            un: un,\n            pwd: pwd,\n            eid: infoData.data.eid\n        };\n\n        var EsInfo = await webApiHandler('getEpProfile', webParam);\n        if (EsInfo.status != 200) throw EsInfo;\n\n        var memberInfo = await webApiHandler('getMemberInfo', webParam);\n        if (memberInfo.status != 200) throw memberInfo;\n\n        // 回拨话机号码需要加一下校验   这边加一个入口，，如果号码是 A135...Z格式,或企业开关关闭则跳过验证\n        if (Number(callintype) == 4 && !(phoneNumber.startsWith('A') && phoneNumber.endsWith('Z') || JSON.parse(localStorage.userData).epInfo.terminal_need_reg && Number(JSON.parse(localStorage.userData).epInfo.terminal_need_reg) == 0)) {\n            var checkData = await checkRegisterStatus({ mobile: phoneNumber, eid: infoData.data.eid });\n            if (checkData.status != 200) throw checkData;\n        }\n        // 修改sip话机号/ 回拨话机号\n        var data = {\n            callintype: callintype\n        };\n\n        if (Number(callintype) == 4) data.telephone = phoneNumber.startsWith('A') && phoneNumber.endsWith('Z') ? phoneNumber.slice(1, phoneNumber.length - 1) : phoneNumber;\n        if (Number(callintype) == 5) data.sip_telephone = phoneNumber;\n        webParam.jsonStr = JSON.stringify({ \"data\": data });\n\n        var updateInfo = await webApiHandler('updateInfo', webParam);\n        if (updateInfo.status != 200) throw updateInfo;\n\n        return { status: 200, info: '获取成功', serverInfo: infoData.data, epInfo: EsInfo, memberInfo: memberInfo.returnData };\n    } catch (err) {\n        logger.debug(err);\n        localStorage.removeItem('userData');\n        return err;\n    }\n}\n\n// 通过json文件获取运维地址\nasync function loadServerFromJson(number) {\n    var jsonData = __webpack_require__(/*! ./province.json */ \"./src/lib/province.json\");\n    var server = '';\n    var TestDistricts = jsonData.TestDistricts;\n    var CurDistricts = jsonData.CurDistricts;\n    for (var i = 0; i < TestDistricts.length; i++) {\n        if (TestDistricts[i].switchNumbers && TestDistricts[i].switchNumbers.split(',').indexOf(number) !== -1) {\n            server = TestDistricts[i].uniServer;\n            return server;\n        }\n    }\n    for (var i = 0; i < CurDistricts.length; i++) {\n        var data = CurDistricts[i].areaCode.split(',');\n        for (var area of data) {\n            if (number.startsWith(area)) {\n                server = CurDistricts[i].uniServer;\n                logger.debug(`${number} 运维地址 ${server}`);\n                return server;\n            }\n        }\n    }\n    if (!server) {\n        var provinceData = await queryAddrByAreaCode(number);\n        if (provinceData.status != 200) throw provinceData;\n        var province = provinceData.data;\n\n        var serverData = await loadServer();\n        if (serverData.status != 200) throw serverData;\n        var yunweiList = serverData.data;\n\n        for (var i = 0; i < yunweiList.length; i++) {\n            if (province.startsWith(yunweiList[i].province)) {\n                server = yunweiList[i].s_client_domain;\n                return server;\n            }\n        }\n    }\n    logger.warn(`failed to find 运维服务器：${number}`);\n}\n\n// 区号查询省份\nasync function queryAddrByAreaCode(number) {\n    var apiKey = 'HaeJWc31db07c761775ca5a2bcf5059a9b03626a2b32443';\n    var areaCode = number.substr(0, 4);\n    try {\n        var url = new URL('https://api.apishop.net/common/postcode/queryAddrByAreaCode');\n        var params = {\n            apiKey: apiKey,\n            areaCode: areaCode\n        };\n        url.search = new URLSearchParams(params);\n        logger.debug(`await fetch ${url}`);\n        let response = await fetch(url);\n        let data = await response.json();\n        if (!data.result) return { status: 50002, info: `data.result ${data.result}`, step: 'queryAddrByAreaCode' };\n        var province = data.result[0].province;\n        logger.debug(`区号查询 await fetch ${province}`);\n        return { status: 200, info: '区号查询成功', data: province };\n    } catch (err) {\n        logger.error('AreaCode' + err);\n        return { status: 50001, info: err, step: 'queryAddrByAreaCode' };\n    }\n}\n\n// 获取运维列表所需的key\nasync function _getSignKey(version, time, salt) {\n    try {\n        var key = \"81fa3a15a2\"; // 约定信息\n        var url = new URL('http://121.40.120.51:1046/Api/Client/getSignKey');\n        var params = {\n            v: version,\n            t: time,\n            salt: salt,\n            sign: _sparkMd2.default.hash(version + time + salt + key)\n        };\n        url.search = new URLSearchParams(params);\n        logger.debug(`await fetch ${url}`);\n        let response = await fetch(url);\n        let data = await response.json();\n        if (Number(data.status) !== 0) return { status: 50002, info: data.info, step: 'getSignKey' };\n        var res = data.data;\n        return { status: 200, info: '获取加密串成功', data: res };\n    } catch (err) {\n        logger.error('SignKey' + err);\n        return { status: 50001, info: err, step: 'getSignKey' };\n    }\n}\n// 获取运维列表\nasync function loadServer() {\n    try {\n        var version = \"1.0\";\n        var time = Date.now();\n        var salt = Math.random().toString().split('.')[1].substr(0, 6);\n\n        var res = await _getSignKey(version, time, salt);\n        if (res.status != 200) throw res;\n        var key = res.data;\n\n        var url = new URL('http://121.40.120.51:1046/Api/Client/getMtServerList');\n        var params = {\n            v: version,\n            t: time,\n            salt: salt,\n            sign: _sparkMd2.default.hash(version + time + key + _sparkMd2.default.hash(salt))\n        };\n        url.search = new URLSearchParams(params);\n        logger.debug(`await fetch ${url}`);\n        let response = await fetch(url);\n        let data = await response.json();\n        if (Number(data.status) !== 0) return { status: 50002, info: data.info, step: 'loadServer' };\n        var res = data.data;\n        // logger.debug(`运维地址列表 await fetch ${JSON.stringify(res)}`)\n        return { status: 200, info: '获取运维列表成功', data: res };\n    } catch (err) {\n        logger.error('serverList' + err);\n        return { status: 50001, info: err, step: 'loadServer' };\n    }\n}\n\n// 获取企业服务器信息\nasync function getInfo(un, pwd, switchNumber, server) {\n    try {\n        var url = new URL('https://' + server + ':1047/Api/Client/getinfo');\n        // getLoginData会在调用loadServerFromJson成功后设置\n        // 单独测试getInfo方法加上|| {}\n        //确认有值才可以直接 localStorage.userData 这里不可以\n        var obj = JSON.parse(localStorage.getItem('userData')) || {};\n        var params = {\n            un: un,\n            pwd: obj && obj.pwd !== null && obj.pwd !== undefined ? obj.pwd : _sparkMd2.default.hash(pwd),\n            switchNumber: switchNumber,\n            cFlag: 1\n        };\n        url.search = new URLSearchParams(params);\n        logger.debug(`await fetch ${url}`);\n        let response = await fetch(url);\n        let data = await response.json();\n        if (Number(data.status) !== 0) return { status: 50002, info: data.info, step: 'getinfo' };\n        obj.server = data.data.real_domain;\n        obj.serverIp = data.data.domain;\n        obj.eid = data.data.eid;\n        obj.sipPort = data.data.port;\n\n        var s = Number(data.data.eid).toString(16);\n        var eid = \"00000000\" + s;\n        eid = eid.substr(s.length, eid.length); // 截取最后8位字符\n        obj.eid16 = eid;\n        localStorage.setItem('userData', JSON.stringify(obj));\n\n        var returnData = {\n            domain: data.data.domain,\n            sipPort: data.data.port,\n            real_domain: data.data.real_domain,\n            http_port: data.data.http_port,\n            https_port: data.data.http_ports,\n            epName: data.data.epName,\n            eid: data.data.eid\n        };\n        logger.debug('getinfo:' + JSON.stringify(returnData));\n        return { status: 200, info: '获取运维信息成功', data: returnData };\n    } catch (err) {\n        logger.error('getInfo' + err);\n        return { status: 50001, info: err, step: 'getinfo' };\n    }\n}\n\n// 校验回拨话机号码\nasync function checkRegisterStatus(params) {\n    try {\n        var obj = JSON.parse(localStorage.userData);\n        var url = new URL('https://' + obj.server + '/Talk/Mapi/checkRegisterStatus');\n        url.search = new URLSearchParams(params);\n        logger.debug(`await fetch ${url}`);\n        let response = await fetch(url);\n        let data = await response.json();\n        if (Number(data.status) !== 0) return { status: 50004, info: data.info, step: 'checkRegisterStatus' };\n        logger.debug('checkRegisterStatus:' + JSON.stringify(data));\n        return { status: 200, info: '回拨号码校验成功' };\n    } catch (err) {\n        logger.error('checkRegisterStatus' + err);\n        return { status: 50001, info: err, step: 'checkRegisterStatus' };\n    }\n}\n/**\n * \n * @param {请求方法名} functionName \n * @param {请求参数} webParam \n */\nasync function webApiHandler(functionName, webParam) {\n    try {\n        var obj = JSON.parse(localStorage.userData);\n        var server = obj.server;\n        var baseUrl = 'https://' + server + '/Talk/Api/';\n        webParam.pwd = obj && obj.pwd !== null && obj.pwd !== undefined ? obj.pwd : _sparkMd2.default.hash(webParam.pwd);\n        var url = new URL(baseUrl + functionName);\n        url.search = new URLSearchParams(webParam);\n        logger.debug(`${functionName} await fetch ${url}`);\n        logger.debug(`${functionName} param ${JSON.stringify(webParam)}`);\n        let response = await fetch(url);\n        let resultData = await response.json();\n        if (Number(resultData.status) !== 0) return { status: 50003, info: resultData.info, step: functionName };\n        var returnData = {};\n        // 返回数据处理\n        switch (functionName) {\n            case 'getEpProfile':\n                {\n                    //获取企业属性 目前未确定用到哪些属性 \n                    var data = resultData.data.epProfile;\n                    returnData = {\n                        dialing_display_set: data.dialing_display_set,\n                        incoming_call_remind: data.incoming_call_remind,\n                        outcallenterprisenumber: data.outcallenterprisenumber,\n                        switch_number_public_set_mode: data.switch_number_public_set_mode,\n                        switch_number_default: data.switch_number_default,\n                        allow_customer_manager: data.allow_customer_manager,\n                        allow_callcenter: data.allow_callcenter,\n                        allow_auto_answer: data.allow_auto_answer, //sip话机自动应答开关 0-关闭 1-开启\n                        auto_answer_duration: data.auto_answer_duration, //自动应答时长 范围：3、5、8\n                        terminal_need_reg: data.terminal_need_reg, //回拨话机校验开关 0-关闭 1-开启\n                        allow_hide_number: data.allow_hide_number,\n                        allow_worksheet: data.allow_worksheet,\n                        allow_monitor: data.allow_monitor,\n                        extension_end: data.extension_end, //分机号段结尾值\n                        extension_start: data.extension_start, //分机号段起始值\n                        allow_record_manager: data.allow_record_manager\n                    };\n                    var epInfo = {\n                        allow_auto_answer: data.allow_auto_answer,\n                        auto_answer_duration: data.auto_answer_duration,\n                        terminal_need_reg: data.terminal_need_reg,\n                        extension_end: data.extension_end,\n                        extension_start: data.extension_start\n                    };\n                    obj.epInfo = epInfo;\n                    localStorage.setItem('userData', JSON.stringify(obj));\n                    break;\n                }\n            case 'getGroups':\n                {\n                    //获取所有技能组 暂时不处理层级结构\n                    var groupData = resultData.data;\n                    var groups = groupData.map(function (m) {\n                        return {\n                            id: m.id,\n                            eid: m.eid,\n                            name: m.name\n                        };\n                    });\n                    returnData = groups;\n                    break;\n                }\n            case 'getMemberInfo':\n                {\n                    //获取用户所属技能组\n                    var data = resultData.data;\n                    var groups = data.inGroups.map(function (m) {\n                        return {\n                            id: m.id,\n                            eid: m.eid,\n                            name: m.name\n                        };\n                    });\n                    // 存储登录时选组信息\n                    obj.groupInfo = groups;\n                    var userData = {\n                        id: data.id,\n                        eid: data.eid,\n                        uid: data.uid,\n                        displayname: data.displayname,\n                        number: data.number,\n                        work_number: data.work_number,\n                        duty: data.duty,\n                        mobile: data.mobile,\n                        outside_callnumber: data.outside_callnumber,\n                        address: data.address,\n                        permission: data.permission,\n                        call_limit: data.call_limit,\n                        time_limit: data.time_limit,\n                        cur_limit_time: data.cur_limit_time\n                    };\n                    obj.userInfo = userData;\n                    localStorage.setItem('userData', JSON.stringify(obj));\n                    returnData = {\n                        userData: userData,\n                        inGroups: groups\n                    };\n                    break;\n                }\n            case 'updateInfo':\n                {\n                    //更新用户呼叫模式\n\n                    logger.debug(functionName + JSON.stringify(resultData));\n                    returnData = resultData;\n                    break;\n                }\n            case 'searchEpMembers':\n                {\n                    //获取技能组包含坐席\n                    var memberData = resultData.data.data;\n                    var members = memberData.map(function (ele) {\n                        return {\n                            id: ele.eid,\n                            eid: ele.eid,\n                            uid: ele.uid,\n                            displayname: ele.displayname,\n                            number: ele.number,\n                            mobile: ele.mobile,\n                            telephone: ele.telephone,\n                            pinyin: ele.pinyin,\n                            outside_callnumber: ele.outside_callnumber,\n                            address: ele.address,\n                            gids: ele.gids,\n                            gName: ele.gName,\n                            service_callmode: ele.service_callmode, //呼叫模式\n                            service_control_time: ele.service_control_time,\n                            service_control: ele.service_control // 状态 0-离线 1-空闲 2-暂离 3-消息请求 4-呼叫请求 5-通话中 6-话后处理\n                        };\n                    });\n                    returnData = { recordsTotal: resultData.data.recordsTotal, recordsFiltered: resultData.data.recordsFiltered, data: members };\n                    break;\n                }\n            case 'getMemberCallStates':\n                {\n                    //获取坐席状态\n                    var element = resultData.data.filter(function (ele) {\n                        return ele.uid == webParam.uid;\n                    });\n                    returnData = element;\n                    break;\n                }\n            default:\n                return { status: 50004, info: '未知请求' };\n        }\n        logger.debug(functionName + JSON.stringify(returnData));\n        return { status: 200, info: '获取成功', returnData: returnData };\n    } catch (err) {\n        logger.error(functionName + err);\n        return { status: 50001, info: err, step: functionName };\n    }\n}\n\nmodule.exports = {\n    getLoginData,\n    webApiHandler,\n    \"_loadServerFromJson\": loadServerFromJson,\n    \"_getInfo\": getInfo,\n    \"_queryAddrByAreaCode\": queryAddrByAreaCode,\n    \"_loadServer\": loadServer\n};\n\n//# sourceURL=webpack:///./src/lib/getLoginInfo.js?");

/***/ }),

/***/ "./src/lib/index.js":
/*!**************************!*\
  !*** ./src/lib/index.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _jssip = __webpack_require__(/*! jssip */ \"./node_modules/jssip/lib-es5/JsSIP.js\");\n\nvar _jssip2 = _interopRequireDefault(_jssip);\n\nvar _Logger = __webpack_require__(/*! ./Logger */ \"./src/lib/Logger.js\");\n\nvar _Logger2 = _interopRequireDefault(_Logger);\n\nvar _xmljs = __webpack_require__(/*! ./xmljs */ \"./src/lib/xmljs.js\");\n\nvar _xmljs2 = _interopRequireDefault(_xmljs);\n\nvar _getLoginInfo = __webpack_require__(/*! ./getLoginInfo */ \"./src/lib/getLoginInfo.js\");\n\nvar _getLoginInfo2 = _interopRequireDefault(_getLoginInfo);\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst EventEmitter = _events2.default.EventEmitter;\nconst logger = new _Logger2.default('index');\n\nclass JsSipWrapper extends EventEmitter {\n\n    constructor() {\n        super();\n        this._ua = null;\n        this.webApi = _getLoginInfo2.default;\n    }\n\n    // 登录\n    async login(param, cb) {\n        var userData = JSON.parse(localStorage.userData);\n        if (!userData) this.emit('registrationFailed');\n        if (param) {\n            userData.loginGid = param.gid;\n            userData.socketUri = param.socketUri;\n            userData.remoteAudio = param.remoteAudio;\n            localStorage.setItem('userData', JSON.stringify(userData));\n        }\n        //服务器确认了才写到 localStorage\n        logger.debug('准备sip注册');\n\n        this.registerSip(userData);\n\n        this.registerEvents(cb);\n\n        this.receiveNewMsg();\n        //如何进一步保障这个值一定能取到？\n        var audioId = param && param.remoteAudio || userData.remoteAudio;\n        // 此处接受 audio 元素 播放声音\n        this.newSessionEvent(document.getElementById(audioId));\n    }\n    registerSip(userData) {\n        // 直接注册sip\n        let sipServer = `${userData.serverIp}:${userData.sipPort}`;\n        let sipUser = `${userData.userInfo.number}_${userData.eid16}`;\n        let socket = new _jssip2.default.WebSocketInterface(userData.socketUri);\n        // socket.via_transport = 'auto'\n        this._ua = new _jssip2.default.UA({\n            uri: `sip:${sipUser}@${sipServer}`,\n            password: userData.clearPwd.slice(8, userData.clearPwd.length - 6),\n            display_name: userData.userInfo.displayname,\n            sockets: [socket],\n            registrar_server: sipServer,\n            contact_uri: `sip:${sipUser}@${sipServer}`,\n            authorization_user: sipUser,\n            user_agent: 'callcenter_webrtc',\n            use_preloaded_route: false,\n            session_timers: true\n        });\n        this._ua.start();\n    }\n\n    receiveNewMsg(cb) {\n        this._ua.on('newMessage', data => {\n            if (data.originator == \"local\") return;\n            var msgXml = data.request.body;\n            var result = _xmljs2.default.xmlToJs(msgXml);\n            logger.debug(`receive message:${JSON.stringify(result)}`);\n            let top = Object.keys(result)[0];\n            var userData = JSON.parse(localStorage.userData);\n            if (top == 'cc' && Number(userData.seatMode) !== 1) {\n                //移动模式时不发消息\n                let eventType = result.cc.a;\n                switch (eventType) {\n                    case '1':\n                    case '2':\n                        // 修改状态\n                        this.emit('statusChanged', { status: eventType });\n                        break;\n                    case '87':\n                        // 通话中预设状态响应,r=200表示成功,挂断电话就会收到状态值是2的消息\n                        this.emit('preSetStatusResponse', result.cc);\n                        break;\n                    case '38':\n                        // 电话转接成功\n                        this.emit('transferCallSuccess', result.cc);\n                        break;\n                    case '39':\n                        // 电话转接失败\n                        this.emit('transferCallFaild', result.cc);\n                        break;\n                    case '201':\n                        // 座席外呼响应(外线)\n                        this.emit('calloutResponse', result.cc);\n                        break;\n                    case '301':\n                        // 座席外呼响应(内线) r:200 成功 ;502 状态不对 503 非工作时间\n                        this.emit('callinResponse', result.cc);\n                        break;\n                    case '309':\n                        // 座席外呼响应(内线) 被叫超时未接听，，给主叫发 309  被叫发101\n                        this.emit('callinFaildResponse', result.cc);\n                        break;\n                    case '100':\n                        // 来电呼入\n                        this.emit('newPBXCall', result.cc);\n                        break;\n                    case '101':\n                        // 来电取消 主叫方挂断; 被叫方挂断; 被叫超时未应答\n                        this.emit('cancelPBXCall', result.cc);\n                        break;\n                    case '104':\n                        // 通话建立,对方接听了电话,需要打开转接,3方通话.\n                        this.emit('answeredPBXCall', result.cc);\n                        break;\n                    case '105':\n                        // 通话断开\n                        this.emit('endPBXCall', result.cc);\n                        break;\n                }\n            } else if (top == 'o') {\n                // o 应该是踢下线的消息\n                /**\n                    * <o> <a>  <u n=\"1006_00010078\" a=\"o\" nm=\"fengchunyan\" r=\"895\" /> </a></o>\n                    * 895 被踢下线\n                    * 897 注册超时被踢下线 \n                    * 898 账号过期/账号被删/账号修改被踢下线\n                    * 899 企业停止后被踢下线\n                */\n                //  通话建立，也会发这个消息，，不处理 <o> <m>  <c n=\"1534396656524476conf_1534396661189\" a=\"i\" /> </m></o>\n                if (result.o.a && result.o.a.u) this.emit('kickedOffLine', result.o.a.u[0]);\n            } else if (top == 'mn') {}\n            // mn 应该是总机的离线同步消息\n\n            // this.emit('newMessage', data);\n        });\n    }\n\n    registerEvents(cb) {\n        this._ua.on('connecting', data => {\n            cb({ code: 'connecting', data: data });\n        });\n\n        this._ua.on('connected', data => {\n            cb({ code: 'connected', data: data });\n        });\n\n        this._ua.on('disconnected', data => {\n\n            cb({ code: 'disconnected', data: data });\n        });\n\n        this._ua.on('registered', data => {\n            //注册后需要马上发三条消息\n            let userData = JSON.parse(localStorage.userData);\n            //设置在线,考虑刷页面、续注册情况\n            let preferedStatus = userData.status || localStorage.getItem('preferredStatus') || '1';\n            this.changeStaus(preferedStatus, true);\n            //默认设置 坐席模式为固定坐席模式,\n            if (!userData.seatMode) this.setSeatMode(52, true);\n            //设置gid\n            this.logonWithGroup(userData.loginGid, userData.eid);\n            cb({ code: 'registered', data: data });\n        });\n\n        this._ua.on('registrationFailed', data => {\n            logger.debug('sip注册失败');\n            localStorage.removeItem('userData');\n            cb({ code: 'registrationFailed', data: data });\n        });\n        //http://jssip.net/documentation/3.1.x/api/ua/#event_registrationExpiring   windows 没有走续注册 mac 触发几率很高\n        // this._ua.on('registrationExpiring', (data) => {\n        //     cb({ code: 'registrationExpiring', data: data })\n        // });\n    }\n\n    newSessionEvent(remoteAudio) {\n        /******************* 通话相关事件 ******************/\n        // 收到INVITE 消息后调用.\n        this._ua.on('newRTCSession', data => {\n            logger.debug('UA \"newRTCSession\" event');\n            let session = data.session;\n            // 此处设置音频流\n            session.answer({ 'mediaConstraints': { 'audio': true, 'video': false } });\n            let peerconnection = session.connection;\n            peerconnection.addEventListener('addstream', event => {\n                // 设置音频\n                remoteAudio.srcObject = event.stream;\n                event.stream.addEventListener('addtrack', event => {\n                    let track = event.track;\n                    if (remoteAudio.srcObject !== event.stream) return;\n                    remoteAudio.srcObject = event.stream;\n                    track.addEventListener('ended', () => {});\n                });\n                event.stream.addEventListener('removetrack', () => {\n                    if (remoteAudio.srcObject !== event.stream) return;\n                    remoteAudio.srcObject = event.stream;\n                });\n            });\n            this.emit('incomingCall', data);\n            this.setSessionInfo(session);\n        });\n    }\n\n    setSessionInfo(session) {\n        session.on('newInfo', sessionData => {\n            logger.debug('UA \"newInfo\" event');\n            if (session.ccNumber) return;\n            // 解析ccNumber\n            var msgXml = sessionData.request.body;\n            session.ccNumber = _xmljs2.default.xmlToJs(msgXml).i.n;\n        });\n    }\n    // send sip msg to PBX helper\n    sendMsgHelper(content, event, tagName, eventHandlers) {\n        var sendXml = _xmljs2.default.jsToXml(content, tagName);\n        if (!eventHandlers) {\n            let that = this;\n            eventHandlers = {\n                \"succeeded\": function (e) {\n                    logger.debug(`${event} success!`);\n                    that.emit(\"sendMessageSucccess\", `${event} success!`);\n                },\n                \"failed\": function (e) {\n                    logger.debug(e);\n                    that.emit(\"sendMessageFaild\", `${event} Faild!`, e);\n                }\n            };\n        }\n        this.sendMessage('PBX', sendXml, eventHandlers);\n    }\n\n    answerPBXCall(ccNumber) {\n        var content = {\n            a: '102',\n            c: ccNumber\n        };\n        this.sendMsgHelper(content, 'answerPBXCall', \"cc\");\n    }\n    // 呼叫保持\n    holdPBXCall(ccNumber) {\n        var userData = JSON.parse(localStorage.getItem('userData'));\n        var number = '';\n        if (userData.callintype == 2 || userData.callintype == 5) number = `${userData.userInfo.number}_${userData.eid16}`;\n        if (userData.callintype == 4) number = '9' + userData.phoneNumber;\n\n        var content = {\n            a: '1',\n            number: number,\n            cc: ccNumber\n        };\n        this.sendMsgHelper(content, 'holdPBXCall', \"ch\");\n    }\n\n    // 呼叫恢复\n    unholdPBXCall(ccNumber) {\n        var userData = JSON.parse(localStorage.getItem('userData'));\n        var number = '';\n        if (userData.callintype == 2 || userData.callintype == 5) number = `${userData.userInfo.number}_${userData.eid16}`;\n        if (userData.callintype == 4) number = '9' + userData.phoneNumber;\n        var content = {\n            a: '2',\n            number: number,\n            cc: ccNumber\n\n        };\n        this.sendMsgHelper(content, 'unholdPBXCall', \"ch\");\n    }\n\n    /**\n     * 通话中预设坐席状态 这边只能是休息状态 \n     * code 2 设置忙的状态  -1 取消设置忙的状态\n     */\n    preSetStatus(ccNumber, code) {\n        var content = {\n            a: '87',\n            s: code,\n            c: ccNumber\n        };\n        this.sendMsgHelper(content, 'preSetStatus', \"cc\");\n    }\n\n    hangUpPBXCall(ccNumber) {\n        var content = {\n            a: '106',\n            c: ccNumber\n        };\n        this.sendMsgHelper(content, 'hangUpPBXCall', \"cc\");\n    }\n\n    // 拨打电话\n    call(target, type, eventHandlers) {\n        // type = 1 外线拨号  type = 2 回拨  type = 3 内线互拨\n        logger.debug('call others [uri:\"%s\"]', target);\n        var userData = JSON.parse(localStorage.userData);\n        var randkey = Math.random().toString().split('.')[1].substr(0, 3); //3位随机串\n        switch (type) {\n            case 1:\n                let session = this._ua.call(target, {\n                    mediaConstraints: {\n                        audio: true\n                    },\n                    rtcOfferConstraints: {\n                        offerToReceiveAudio: 1\n                    },\n                    'eventHandlers': eventHandlers\n                });\n                this.setSessionInfo(session);\n                return session;\n                break;\n            case 2:\n                // p 是总机号,应该要从登陆的参数获得 ,i 是时间戳,随机生成\n                var content = {\n                    a: '200',\n                    p: userData.switchNumber,\n                    i: Date.now().toString() + randkey,\n                    t: target\n\n                };\n                this.sendMsgHelper(content, 'call-回拨', \"cc\", eventHandlers);\n                break;\n            case 3:\n                var content = {\n                    a: '300',\n                    p: userData.switchNumber,\n                    i: Date.now().toString() + randkey,\n                    t: `${target}_${userData.eid16}`\n                };\n                this.sendMsgHelper(content, 'call-内线互拨', \"cc\", eventHandlers);\n                break;\n            default:\n\n        }\n    }\n\n    stop(cb) {\n        this._ua.stop();\n        this._ua.once('unregistered', data => {\n            var res = data.response;\n            if (res.reason_phrase == 'OK' && res.status_code == 200 && res.method == \"REGISTER\") {\n                // 注销需要清除localstorege\n                localStorage.removeItem('userData');\n                cb({ code: res.status_code, info: res.reason_phrase });\n            } else {\n                cb({ code: res.status_code, info: res.reason_phrase });\n            }\n        });\n    }\n\n    // 发送xml消息\n    sendMessage(target, text, eventHandlers) {\n        logger.debug(`send message!!!,content:${text} target:${target}`);\n        let options = {\n            'eventHandlers': eventHandlers,\n            'contentType': 'application/pidf+xml'\n\n        };\n        return this._ua.sendMessage(target, text, options);\n    }\n\n    isConnected() {\n        return this._ua.isConnected;\n    }\n\n    // 修改坐席状态 0 离线  1 空闲  2暂离\n    changeStaus(status, isLogin) {\n        let that = this;\n        var eventHandlers = {\n            \"succeeded\": function (e) {\n                logger.debug(`changeStaus success!`);\n                that.emit('statusChanged', { status: status });\n            },\n            \"failed\": function (e) {\n                logger.debug(e);\n                if (isLogin) that.emit('changeStausLoginFailed', e);else that.emit('changeStausFailed', e);\n            }\n            // var xml = `<?xml version=\"1.0\" encoding=\"utf-8\"?><cc a=\"1\" />`\n        };return this.sendMsgHelper({ a: status.toString() }, 'changeStaus', \"cc\", eventHandlers);\n    }\n\n    // 发送登录时所选组的消息\n    logonWithGroup(gid, eid) {\n        // <?xml version=\"1.0\" encoding=\"utf-8\"?><cc a=\"53\" g=\"580_65656\" />\n        return this.sendMsgHelper({\n            a: '53',\n            g: `${gid}_${eid}`\n        }, 'logonWithGroup', \"cc\");\n    }\n    /**\n     * 设置座席模式 \n     * seatMode 51 移动模式  52 固定模式\n     * 对应 localStorage 值存储为  1 移动模式 2 固定模式\n     */\n    // 设置座席模式  \n    async setSeatMode(seatMode, isLogin) {\n\n        //<?xml version=\"1.0\" encoding=\"utf-8\"?><cc a=\"52\" />\n        if (!isLogin && seatMode == 52) this.changeStaus('1', false); //登录后设置成固定模式时，必须置闲\n        var userData = JSON.parse(localStorage.userData);\n\n        if (seatMode == 52) {\n            //固定模式\n            userData.seatMode = 2;\n            if (!isLogin) userData.callintype = userData.oldCallType;\n        }\n        if (seatMode == 51) {\n            //移动坐席模式\n            userData.seatMode = 1;\n            userData.callintype = 4; // 移动坐席模式必须是 回拨模式\n        }\n        //移动模式时必须是电路模式  固定模式时必须配置回拨话机号，，暂不处理，切回 voip模式\n        var webParam = {\n            un: userData.userInfo.number,\n            pwd: userData.clearPwd.slice(8, userData.clearPwd.length - 6),\n            eid: userData.eid,\n            jsonStr: JSON.stringify({ \"data\": { \"callintype\": userData.callintype } })\n        };\n\n        await this.webApi.webApiHandler('updateInfo', webParam);\n        localStorage.setItem('userData', JSON.stringify(userData));\n\n        return this.sendMsgHelper({\n            a: seatMode.toString()\n        }, 'setSeatMode', \"cc\");\n    }\n    // 通话转接给坐席\n    transferPBXCall(ccNumber, gid, tranNumber) {\n        //<?xml version=\"1.0\" encoding=\"utf-8\"?><cc a=\"31\" c=\"1522722042196121conf_1522721954556\" g=\"0_65656\" n=\"1008_00010078\" />\n        if (!ccNumber || !gid || !tranNumber) {\n            let err = new Error('缺少参数');\n            return err;\n        }\n        var userData = JSON.parse(localStorage.userData);\n        var content = {\n            a: '31',\n            c: ccNumber,\n            g: `${gid}_${userData.eid}`,\n            n: `${tranNumber}_${userData.eid16}`\n        };\n        return this.sendMsgHelper(content, 'transferPBXCall', \"cc\");\n    }\n}\nexports.default = JsSipWrapper;\n\n//# sourceURL=webpack:///./src/lib/index.js?");

/***/ }),

/***/ "./src/lib/province.json":
/*!*******************************!*\
  !*** ./src/lib/province.json ***!
  \*******************************/
/*! exports provided: version, TestDistricts, CurDistricts, default */
/***/ (function(module) {

eval("module.exports = {\"version\":\"1.0\",\"TestDistricts\":[{\"name\":\"开发调试服务器\",\"uniServer\":\"cses.emic.com.cn\",\"Ip\":\"112.80.5.131\",\"switchNumbers\":\"02566699703\"},{\"name\":\"159分布式云总机-开发调试\",\"uniServer\":\"kfyw.emic.com.cn\",\"Ip\":\"112.80.5.155\",\"switchNumbers\":\"02566699741,02566699794,02566687971,02566687961,02566687313,02566687960,02566687301,02566699792,02566699734,02566687970,02566699746,02566699794,02566687335\"}],\"CurDistricts\":[{\"areaCode\":\"025,0510,0511,0512,0513,0514,0515,0516,0517,0518,0519,0523,0527\",\"name\":\"江苏省\",\"uniServer\":\"yzj.10010js.com\"},{\"areaCode\":\"010\",\"name\":\"北京市\",\"uniServer\":\"bj.emic.com.cn\"},{\"areaCode\":\"0770,0771,0772,0773,0774,0775,0776,0777,0778,0779\",\"name\":\"广西自治区\",\"uniServer\":\"emic.gx10010.com\"},{\"areaCode\":\"0730,0731,0734,0735,0736,0737,0738,0739,0743,0744,0745,0746\",\"name\":\"湖南省\",\"uniServer\":\"hn.emic.com.cn\"},{\"areaCode\":\"0570,0571,0572,0573,0574,0575,0576,0577,0578,0579,0580\",\"name\":\"浙江省\",\"uniServer\":\"zj.emic.com.cn\"},{\"areaCode\":\"0591,0592,0593,0594,0595,0596,0597,0598,0599\",\"name\":\"福建省\",\"uniServer\":\"fj.emic.com.cn\"},{\"areaCode\":\"0310,0311,0312,0313,0314,0315,0316,0317,0318,0319,0335\",\"name\":\"河北省\",\"uniServer\":\"www.woyzj.com\"},{\"areaCode\":\"0550,0551,0552,0553,0554,0555,0556,0557,0558,0559,0561,0562,0563,0564,0566\",\"name\":\"安徽省\",\"uniServer\":\"ah.emic.com.cn\"},{\"areaCode\":\"021\",\"name\":\"上海市\",\"uniServer\":\"sh.emic.com.cn\"},{\"areaCode\":\"0891,0892,0893,0894,0895,0896,0897\",\"name\":\"西藏自治区\",\"uniServer\":\"xz.emic.com.cn\"},{\"areaCode\":\"029,0911,0912,0913,0914,0915,0916,0917,0919\",\"name\":\"陕西省\",\"uniServer\":\"sn.emic.com.cn\"},{\"areaCode\":\"0701,0790,0791,0792,0793,0794,0795,0796,0797,0798,0799\",\"name\":\"江西省\",\"uniServer\":\"jx.emic.com.cn\"},{\"areaCode\":\"0370,0371,0372,0373,0374,0375,0376,0377,0379,0391,0392,0393,0394,0395,0396,0398\",\"name\":\"河南省\",\"uniServer\":\"yzj.online.ha.cn\"},{\"areaCode\":\"022\",\"name\":\"天津市\",\"uniServer\":\"yzj.tjunicom.com\"},{\"areaCode\":\"0851,0852,0853,0854,0855,0856,0857,0858,0859\",\"name\":\"贵州省\",\"uniServer\":\"gz.emic.com.cn\"},{\"areaCode\":\"020,0660,0662,0663,0668,0750,0751,0752,0753,0754,0755,0756,0757,0758,0759,0760,0762,0763,0766,0768,0769\",\"name\":\"广东省\",\"uniServer\":\"gd.emic.com.cn\"},{\"areaCode\":\"0691,0692,0870,0871,0872,0873,0874,0875,0876,0877,0878,0879,0883,0886,0887,0888\",\"name\":\"云南省\",\"uniServer\":\"yn.emic.com.cn\"},{\"areaCode\":\"023\",\"name\":\"重庆市\",\"uniServer\":\"cq.emic.com.cn\"},{\"areaCode\":\"028,0812,0813,0816,0817,0818,0825,0826,0827,0830,0831,0832,0833,0834,0835,0836,0837,0838,0839\",\"name\":\"四川省\",\"uniServer\":\"sc.emic.com.cn\"},{\"areaCode\":\"0349,0350,0351,0352,0353,0354,0355,0356,0357,0358,0359\",\"name\":\"山西省\",\"uniServer\":\"sx.emic.com.cn\"},{\"areaCode\":\"024,0411,0412,0415,0416,0417,0418,0419,0421,0427,0429\",\"name\":\"辽宁省\",\"uniServer\":\"ln.emic.com.cn\"},{\"areaCode\":\"0930,0931,0932,0933,0934,0935,0936,0937,0938,0939,0941,0943\",\"name\":\"甘肃省\",\"uniServer\":\"gs.emic.com.cn\"},{\"areaCode\":\"0530,0531,0532,0533,0534,0535,0536,0537,0538,0539,0543,0546,0631,0632,0633,0634,0635\",\"name\":\"山东省\",\"uniServer\":\"sd.emic.com.cn\"},{\"areaCode\":\"027,0710,0711,0712,0713,0714,0715,0716,0717,0718,0719,0722,0724\",\"name\":\"湖北省\",\"uniServer\":\"hub.emic.com.cn\"},{\"areaCode\":\"0898\",\"name\":\"海南省\",\"uniServer\":\"han.emicloud.com\"}]};\n\n//# sourceURL=webpack:///./src/lib/province.json?");

/***/ }),

/***/ "./src/lib/xmljs.js":
/*!**************************!*\
  !*** ./src/lib/xmljs.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Logger = __webpack_require__(/*! ./Logger */ \"./src/lib/Logger.js\");\n\nvar _Logger2 = _interopRequireDefault(_Logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst logger = new _Logger2.default('xml2json');\n// xml -> js，只能在浏览器跑：DOMParser\nfunction xmlToJs(str) {\n  // a \n  // b\n  // c ccnumber\n  // f 是否进入话后处理（0-不进，1-进）\n  // g gid_eid\n  // k k=-1表示从批量外呼任务中添加或删除登陆坐席，此902状态不用向web端请求批量外呼状态\n  // o \n  // i CallId\n  // m 模式\n  // n        主叫号码\n  // p 回拨号码/话机号码    IVR节点号  外呼显示号码\n  // r 121消息  200表示成功收到   404\n  // s 状态   被叫号码\n  // t 被叫号码  分机号_企业号\n  // q\n  // n 分机号_企业号\n  // v 2:网络 4：回拨 5：sip话机\n  // z\n  var arr = ['a', 'b', 'c', 'f', 'g', 'k', 'o', 'i', 'm', 'n', 'p', 'r', 's', 't', 'q', 'v', 'z', 'l', 'u', 'nm'];\n  var arrlen = arr.length;\n  var topName = ['cc', 'o', 'mn', 'i'];\n  var a = {};\n  for (var j = 0; j < topName.length; j++) {\n    if (xmlToDom(str).getElementsByTagName(topName[j]).length) {\n      var top;\n      top = topName[j];\n      var xmlDom = xmlToDom(str).firstChild;\n      var obj = {};\n      for (var i = 0; i < arrlen; i++) {\n        if (xmlDom.getAttribute(arr[i])) {\n          obj[arr[i]] = xmlDom.getAttribute(arr[i]);\n        }\n      }\n      // 一级赋值\n      a[top] = obj;\n      if (xmlToDom(str).firstChild.childNodes.length > 0) {\n        // 获取所有子节点\n        var childNodes = xmlToDom(str).firstChild;\n        var childArray = [];\n        for (var i = 0, len = childNodes.children.length; i < len; i++) {\n          var childObj = {};\n          var demo = childNodes.children[i];\n\n          for (var k = 0; k < arrlen; k++) {\n            if (demo.getAttribute(arr[k])) {\n              childObj[arr[k]] = demo.getAttribute(arr[k]);\n            }\n          }\n          childArray.push(childObj);\n          // 二级赋值\n          a[top][xmlToDom(str).firstChild.children[0].tagName] = childArray;\n          if (childNodes.children[0].children.length > 0) {\n            var childArray1 = [];\n            for (var p = 0; p < childNodes.children[0].children.length; p++) {\n              var obj = childNodes.children[0].children[p];\n              var childObj1 = {};\n              for (var k = 0; k < arrlen; k++) {\n                if (obj.getAttribute(arr[k])) {\n                  childObj1[arr[k]] = obj.getAttribute(arr[k]);\n                }\n              }\n              childArray1.push(childObj1);\n              // 三级赋值\n              a[top][xmlToDom(str).firstChild.children[0].tagName][childNodes.children[0].children[0].tagName] = childArray1;\n            }\n          }\n        }\n      }\n    }\n  }\n  return a;\n}\n\n// js -> xml\nfunction jsToXml(obj, tagName) {\n  var tag = xmlToDom('<' + tagName + '/>').getElementsByTagName(tagName)[0];\n  for (var k in obj) {\n    tag.setAttribute(k, obj[k]);\n  }\n  return '<?xml version=\"1.0\" encoding=\"utf-8\"?>' + domToStr(tag);\n}\n\nfunction domToStr(node) {\n  let tmpNode = document.createElement('div');\n  tmpNode.appendChild(node);\n  let str = tmpNode.innerHTML;\n  tmpNode = node = null; // 解除引用，以便于垃圾回收  \n  return str;\n}\n\n// https://blog.csdn.net/medivhq/article/details/44647329\nfunction xmlToDom(xmlString) {\n  var xmlDoc = null;\n  if (!window.DOMParser && window.ActiveXObject) {\n    // 兼容ie浏览器\n    var xmlDomVersions = ['MSXML.2.DOMDocument.6.0', 'MSXML.2.DOMDocument.3.0', 'Microsoft.XMLDOM'];\n    for (var i = 0; i < xmlDomVersions.length; i++) {\n      try {\n        xmlDoc = new ActiveXObject(xmlDomVersions[i]);\n        xmlDoc.async = false;\n        xmlDoc.loadXML(xmlString); //loadXML方法载入xml字符串\n        break;\n      } catch (e) {}\n    }\n  } else if (window.DOMParser && document.implementation && document.implementation.createDocument) {\n    try {\n      var domParser = null;\n      domParser = new DOMParser();\n      xmlDoc = domParser.parseFromString(xmlString, 'text/xml');\n    } catch (e) {}\n  } else {\n    return null;\n  }\n  return xmlDoc;\n}\n\nexports.default = {\n  xmlToJs,\n  jsToXml\n};\n\n//# sourceURL=webpack:///./src/lib/xmljs.js?");

/***/ }),

/***/ "./src/ui/html.js":
/*!************************!*\
  !*** ./src/ui/html.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = creatHTML;\nfunction creatHTML(options) {\n\n    /**\n    * PHONE-ENTRY-LOGIN 注册页面\n    * PHONE-ENTRY-SETTING 配置页面\n    * PHONE-ENTRY-MASK 遮罩\n    * PHONE-IFRAME 嵌入工具条\n    * PHONE-ENTRY-PANEL 快速呼叫\n    * PHONE-ENTRY-SWITCH 转接\n    * PHONE-ENTRY-MESSAGE 发送消息\n    * PHONE-LEFT-STATUS 左侧状态\n    * PHONE-ENTRY-TOGGLE 状态切换\n     */\n    var config = {\n        EphoneBar_width: 230,\n        callStatusPage_width: parseInt(options.width) - 230\n    };\n    var setting = `<div id=\"PHONE-ENTRY-SETTING\" data-hide='0'  data-toggle='setting'>\n                        <span data-type='close'>&times;</span>\n                        <ul>\n                            <li>\n                                <span>坐席模式</span>\n                                <span>\n                                <label><input type=\"radio\" name=\"pattern\" checked value=\"51\" data-type=\"move\">&nbsp;移动&nbsp; </label>\n                                <label><input type=\"radio\" name=\"pattern\"  value=\"52\" checked data-type=\"fix\" >&nbsp;固定 </label>\n                                </span>\n                            </li>\n                            <li>\n                                <span>wss地址</span>\n                                <span>\n                                    <select>\n                                        <option value=\"1\" selected>wss://s01.vsbc.com:9060</option>\n                                        <option value=\"2\">wss://10.0.0.165:10443</option>\n                                    </select> \n                                </span>\n                            </li>\n                            <li>\n                                <span>功能按钮位置</span>\n                                <span>\n                                <label><input type=\"radio\"  data-type=\"postionButton\" name=\"postionButton\" value=\"left\" checked>&nbsp;左&nbsp; </label>\n                                <label><input type=\"radio\"  data-type=\"postionButton\" name=\"postionButton\" value=\"right\">&nbsp;右 </label>\n                                </span>\n                            </li>\n                            <li id=\"confirm\">\n                                <button data-type='confirm'>确定</button>\n                            </li>\n                        </ul>\n                    </div>`;\n    //注册登陆\n    var loginPage = ` <div id=\"PHONE-ENTRY-LOGIN\" data-hide='0'  data-toggle='loginPage'>\n                        <span data-type='close'>&times;</span>\n                        <span data-type='error'></span>\n                        <ul>\n                            <li>\n                                <span>总机号</span>\n                                <input type=\"text\" data-type=\"switchnumber\" value=\"02566699734\" onkeyup=\"this.value=this.value.replace(/\\\\D/g,'')\" onpaste=\"this.value=this.value.replace(/\\\\D/g,'')\">\n                            </li>\n                            <li>\n                                <span>分机号</span>\n                                <input type=\"text\" data-type='seatnumber' onkeyup=\"this.value=this.value.replace(/\\\\D/g,'')\" onpaste=\"this.value=this.value.replace(/\\\\D/g,'')\">\n                            </li>\n                            <li>\n                                <span>密　码</span>\n                                <input type=\"password\" data-type=\"password\">\n                            </li>\n                            <li  data-hide='0' data-type='model'>  \n                                <span data-type='4' data-hide='0' >回拨话机号</span>\n                                <span data-type='5' data-hide='0' >sip话机号</span>\n                                <input type=\"text\" data-type=\"modelnumber\" onpaste=\"this.value=this.value.replace(/\\\\D/g,'')\">\n                            </li>\n                            <li id=\"model\" style=\"border:none\">\n                                <label><span><input type=\"radio\" name=\"callintype\" value='2' checked>&nbsp;VOIP</span></label>\n                                <label><span><input type=\"radio\" name=\"callintype\" value='5'>&nbsp;SIP话机</span></label>\n                                <label><span><input type=\"radio\" name=\"callintype\" value='4'>&nbsp;回拨话机</span></label>\n                                <span data-type=\"loginStatus\"><em></em>&nbsp;<span>示闲</span></span> \n                            </li>\n                            <li id=\"login\">\n                                <button data-type='login' data-disabled='1'>登录</button>\n                            </li>\n                        </ul>\n                    </div>`;\n    // 状态切换\n    var statusPage = `<div id=\"PHONE-ENTRY-TOGGLE\" data-hide='0'   data-toggle='statusPage'> \n                        <ul>\n                            <li data-type=\"leisure\" data-hide='1'    data-disabled='false'><em></em><span>空闲</span></li>\n                            <li data-type=\"busy\"    data-hide='1'    data-disabled='false' data-status='2'><em></em><span>忙碌</span></li>\n                            <li data-type=\"logout\"  data-hide='1'    data-disabled='false'><em>&#xe81c;</em><span>退出</span></li>\n                        </ul>\n                    </div>`;\n    //登陆选择所在组\n    var selectGroup = `<div id=\"PHONE-ENTRY-SELECTGROUP\" data-hide='0' data-toggle='selectGroup' >\n                            <span data-type='close'>&times;</span>\n                            <div data-type=\"introduce\">请先选择工作所需的技能组:</div>\n                            <ul data-type=\"groupList\" class=\"option_style\">\n                                <<li>白浅白浅</li>\n                                <li>野花野花</li>\n                                <li class=\"selected\">凤九凤九</li>\n                                <li>东华东华</li>\n                                <li>小团子小团子子子</li>\n                                <li>成玉成玉</li>\n                                <li>白浅白浅</li>\n                                <li>野花野花</li>\n                            </ul>\n                            <button data-type=\"confirm\" data-disabled='1'>确认</button>\n                        </div>`;\n\n    //快速呼叫面板\n    var fastPage = `<div id='PHONE-ENTRY-PANEL' data-hide='0'  data-toggle='fastPage'>\n                        <span data-type='close'>&times;</span>\n                        <ul>\n                            <li><input type=\"text\" data-type='input' placeholder=\"请输入电话号码\" oninput='this.value=this.value.replace(/[^0-9]/g,\"\").replace(/ /g,\"\")'><li>\n                            <li><button data-type='call'>呼叫</button><li>\n                        </ul>\n                    </div>`;\n\n    //状态\n    //呼叫状态显示状态 \n    var callStatusPage = ` <div id='PHONE-LEFT-STATUS'  style='width:${config.callStatusPage_width}px'>\n                                <div data-type='pattern'>\n                                    <div  data-hide='0'>\n                                        当前处于移动模式\n                                    </div>\n                                </div>            \n                                <div data-type='rect' >\n                                    <div data-hide='0'>\n                                        <span data-type='number'>18330986136</span>\n                                        &nbsp;|&nbsp;\n                                        <span data-type='status'>呼叫中</span>\n                                        <span data-type='times'>00:00:00</span>\n                                    </div>\n                                </div>\n                                <div data-type='planePage'>\n                                    <div data-hide='0'>\n                                        &#xe627;\n                                    </div> \n                                </div> \n                                <div  data-type='incomingStatus'>\n                                        <div data-hide='0'>\n                                            <div data-type='bg'>\n                                                <span data-type='number'>18330986136</span>\n                                                &nbsp\n                                                <span data-type='status'>来电</span>\n                                            </div>   \n                                            <button data-hide=\"1\"  data-disable='1' data-type='answer'>接听</button> \n                                        </div>  \n                                </div>\n                            </div>\n                        `;\n    // 拨号面板\n    // var buttons = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '*', '0', '#']\n    // var str = ''\n    // buttons.map((v, i) => {\n    //     var marginRight = i % 3 == 0 ? 0 : 16\n    //     str += '<span style=\"display:inline-block;\"><input data-type=\"num\" type=\"button\" value=\"' + v + '\"  style=\"margin-left:' + marginRight + 'px\"></span>'\n    // })\n    // var planePage = `<div id=\"PHONE-PANEL\" data-hide='0'   data-toggle='planePage'> \n    //           <span data-type='close'>&times;</span>\n    //           <div><input data-type='input' id='PANEL-INPUT' type='text' placeholder=\"请输入拨打的号码\" oninput='this.value=this.value.replace(/[^0-9]/g,\"\")'></div>\n    //           <div>\n    //           ${str}\n    //           </div>\n    //           <div data-type='call' data-hide='0'>拨号</div>\n    //       </div>`\n    //转接\n    var switchPage = `  <div id=\"PHONE-ENTRY-SWITCH\" data-hide='0' data-toggle='switchPage'>\n                            <span data-type=\"error\"></span>\n                            <div id=\"SWITCH_PlATE\">\n                                <span data-type=\"close\">&times;</span>\n                                <div id=\"GROUP\">\n                                    <div data-type=\"select\">\n                                    <div data-type=\"select_text\">全部技能组</div>\n                                    <div data-type=\"select_icon\">\n                                        <div class=\"arrow arrow-down\"></div>\n                                    </div>\n                                    </div>\n                                    <ul data-type=\"group\" data-hide=\"0\">\n                                    <!--<li data-eid='65656' data-id='580' data-level='1' data-name='翟岗岗技能组' data-oid='1' data-pid='0'>全部技能组</li>\n                                    <li>售前技能组</li>\n                                    <li>售后技能组</li>\n                                    <li>技术支持</li> -->\n                                    </ul>\n                                    <div data-type=\"filter\"><input type=\"checkbox\" data-type=\"checkbox\" style='vertical-align: middle;'>&nbsp;仅查可转接坐席</div>\n                                </div>\n                                <ul data-type=\"kefuList\"  class=\"option_style\">\n                                </ul>\n                                <button data-type=\"transfer\" data-disabled='1'>确认转接</button>\n                            </div>\n                        </div>`;\n    //三方通话\n    // var threeSession = `<div id=\"PHONE-TRILATERA-SESSION\" data-hide='0' data-toggle='threeSession'>\n    //           <p data-type=\"status\">等待被叫接听...</p>\n    //           <p>\n    //             <span data-type=\"number\">02567893755</span>\n    //             <span data-type=\"img\">&#xe76b;</span> \n    //             <!-- <span data-type=\"cancel\">取消</span> -->\n    //             <!-- <span data-type=\"redial\">重新拨号</span> -->\n    //             <span data-type=\"hangup\">挂断</span>\n    //           </p>\n    //           <p>\n    //             <span data-type=\"number\">02567893755</span>\n    //             <!-- <span data-type=\"img\">&#xe76b;</span> -->\n    //             <span data-type=\"cancel\">取消</span>\n    //             <span data-type=\"redial\">重新拨号</span>\n    //             <!-- <span data-type=\"hangup\">挂断</span> -->\n    //           </p>\n    //         </div>`\n\n    //工具条按钮\n    var controlPage = `<ul  id='EphoneBar' style='width:${config.EphoneBar_width}px'>\n            \n                    <li  data-phone-key=\"0\" data-phone-type=\"register\">\n                        <!-- &#xe600; &#xe633;-->\n                        <em title=\"注册\">&#xe63f;</em>\n                        <span data-type=\"toggle\" data-hide=\"0\"></span>\n                        <div  data-arrow='register' class=\"arrow arrow-up\" data-hide='0'></div>\n                        <!--状态切换-->\n                        ${statusPage}\n                    </li>\n\n                    <!--<li   data-phone-key=\"0\" data-phone-type=\"logout\" data-hide='0'>\n                        <em title=\"退出\">&#xe7c9;</em>\n                    </li>\n                    <li class=\"gray\"  data-phone-key=\"3\"  data-phone-type='busy' data-hide='1'>\n                        <em title=\"示闲\">&#xe6a5;</em>\n                    </li>\n                    <li class=\"\" data-phone-key=\"3\"  data-phone-type='leisure' data-hide='0'>\n                        <em title=\"示忙\">&#xe6a6;</em>\n                    </li> -->\n\n                    <li class=\"gray\"  data-phone-key=\"1\" data-phone-type='open' data-hide='1'>\n                        <em title=\"呼叫\">&#xe625;</em>\n                        <div  data-arrow='open' class=\"arrow arrow-up\"  data-hide='0'></div>\n                    </li>\n\n                    <li class=\"gray\"  data-phone-key=\"1\" data-phone-type='terminate' data-hide='0' style='color:red'>\n                        <em title=\"挂断\">&#xe845;</em>\n                    </li> \n                    <li class=\"gray\" data-phone-key=\"2\" data-phone-type=\"switch\">\n                        <em title=\"转接\">&#xe603;</em>\n                        <div  data-arrow='switch' class=\"arrow arrow-up\"  data-hide='0'></div>\n                    </li>\n\n                    <!--<li class=\"gray\"  data-phone-type='three'>\n                        <em></em>\n                        <span>三方通话</span>\n                        <div  data-arrow='three' class=\"arrow arrow-up\"  data-hide='0'></div>\n                    </li> -->\n\n                    <li class=\"gray\"  data-phone-key=\"1\"  data-phone-type='hold' data-hide='1'>\n                        <em title=\"暂停通话\">&#xe61c;</em>\n                    </li>\n                    <li class=\"\"  data-phone-key=\"1\"  data-phone-type='unhold' data-hide='0'>\n                        <em title=\"恢复通话\">&#xe846;</em>\n                    </li> \n\n                    <li class=\"gray\"  data-phone-key=\"4\"  data-phone-type='setting' data-hide='1'>\n                        <em title=\"设置\">&#xe610;</em>\n                        <div  data-arrow='setting' class=\"arrow arrow-up\"  data-hide='0'></div>\n                    </li>\n            </ul>`;\n\n    var HTML = `<div id=\"PHONE-ENTRY-CONTAINER\" style=\"width:${options.width};height:${options.height};\">\n                    <div  style=\"background:${options.background};\"width:${options.width};height:${options.height};\">                 \n                        <audio autoplay id='peeraudio'></audio>\n                        <!--控制面板-->\n                        ${controlPage}\n                        <!--通话状态-->\n                        ${callStatusPage}\n                    </div> \n                        <!--登陆-->\n                        ${loginPage}\n                        <!--登陆选组-->\n                        ${selectGroup}\n                        <!--拨号面板-->\n                        ${fastPage}\n                        <!--转接-->              \n                        ${switchPage}\n                        <!--设置-->\n                        ${setting}\n                        <!--三方通话-->                                                                   \n                </div>`;\n    return HTML;\n}\n\n//# sourceURL=webpack:///./src/ui/html.js?");

/***/ }),

/***/ "./src/ui/index.js":
/*!*************************!*\
  !*** ./src/ui/index.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _phone = __webpack_require__(/*! ./phone */ \"./src/ui/phone.js\");\n\nvar _phone2 = _interopRequireDefault(_phone);\n\nvar _getLoginInfo = __webpack_require__(/*! ../lib/getLoginInfo */ \"./src/lib/getLoginInfo.js\");\n\nvar _html = __webpack_require__(/*! ./html */ \"./src/ui/html.js\");\n\nvar _html2 = _interopRequireDefault(_html);\n\n__webpack_require__(/*! ../../resources/css/phone.scss */ \"./resources/css/phone.scss\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//webpack specfic || gulp 还没有找到import scss的包\n\n(function (global, doc) {\n    class Ephone {\n        constructor() {\n            //定义Ephone的属性\n            this.options = {\n                width: \"480px\",\n                height: \"50px\",\n                background: \"\",\n                callBackground: [\"#1E59B9\", '#19C583', '#FF6754'],\n                drop: true\n            };\n            this.closeTimer = null;\n            this.watchTimer = null;\n            this.outTimer = null;\n            this.titleTimer = null;\n            this.recordsTotal = null; // 某组坐席总数 滚动加载时使用\n            this.callintype = \"2\"; // 模式\n            this.callType = 0; // 呼叫模式 0 无  2外线 3 内线\n            this._ccNumber = undefined; //ccNumber\n            this.socket_uri = \"wss://s01.vsbc.com:9060\";\n            this.log = _phone2.default.debug('script');\n        }\n        init(targetID, options) {\n            // var ccNumber = localStorage.getItem(\"ccNumber\")\n            var head = document.getElementsByTagName('head')[0];\n            var link = document.createElement('link');\n            var userData = localStorage.userData ? JSON.parse(localStorage.userData) : false;\n            var toolbar = document.createElement(\"div\");\n            var target = doc.querySelector(targetID) || doc.querySelector(\"body\");\n            if (!!window.ActiveXObject || \"ActiveXObject\" in window) {\n                target.innerHTML = \"<h1 style='text-align:center'>请使用非 IE 浏览器！！！</h1>\";\n                return;\n            }\n            //初始化配置\n            if (typeof options == 'object' && options) {\n                this.options.width = options.width ? options.width : this.options.width;\n                this.options.height = options.height ? options.height : this.options.height;\n                this.options.background = options.background ? options.background : this.options.background;\n                this.options.drop = options.drop != undefined ? options.drop : this.options.drop;\n                this.options.callBackground = options.callBackground && Array.isArray(options.callBackground) ? options.callBackground : this.options.callBackground;\n            }\n            //增加拖拽功能\n            if (this.options.drop) {\n                this._addDrop(toolbar, target);\n            }\n            //html\n            toolbar.style.width = this.options.width;\n            toolbar.style.boxShadow = '0px 1px 15px ' + '#c3c3c3';\n            toolbar.style.zIndex = 999;\n            toolbar.style.background = this.options.background;\n            toolbar.id = \"PHONE-DROP\";\n            toolbar.innerHTML = (0, _html2.default)(this.options);\n            target.appendChild(toolbar);\n            //添加DOM事件处理\n            this.eventListener();\n            // this._hideAllMode()\n            window.addEventListener(\"beforeunload\", function (e) {\n                _phone2.default.terminate(this.ccNumber);\n                if (_phone2.default.kefuStatus == 0 && localStorage.getItem('userData')) localStorage.removeItem('userData');\n                event.returnValue = \"离开取消会话\";\n            });\n            // 初始位置 功能按钮位置  配置项可配\n            if (userData && userData.setting) {\n                this.setTogglePosition(userData.setting);\n            }\n            // if (ccNumber) {\n            //     // Phone.terminate(ccNumber)\n            //     localStorage.removeItem(\"ccNumber\")\n            // }\n        }\n        eventListener() {\n            var stopProList = [];\n            var that = this; //回调函数才需要that=this，或者箭头函数\n            var wssMode; // wss地址 \n            var targetId; // 技能组id\n            var timer = null;\n            var page = 1; // 记录当前页数\n            var checked = 0; // 仅查可转接坐席是否勾选 0 未勾选 1 已勾选\n            var gid;\n            var tranNumber;\n            //工具条元素\n            let actionButtons = document.querySelectorAll('#EphoneBar li[data-phone-key]');\n            let registerBtn = doc.querySelector(\"#EphoneBar li[data-phone-type='register']\"); //登陆\n            let openBtn = doc.querySelector(\"#EphoneBar li[data-phone-type='open']\"); // 快速呼叫\n            let planePageBtn = doc.querySelector(\"#PHONE-LEFT-STATUS>div[data-type='planePage']>div\"); //拨号面板按钮\n            let kefuStatus = registerBtn.querySelector(\"span[data-type='toggle']\"); //注册按钮显示状态\n            //弹框元素\n            let loginTarget = doc.querySelector(\"#PHONE-ENTRY-LOGIN[data-hide]\"); //登陆页面\n            let selectGroupTarget = doc.querySelector(\"#PHONE-ENTRY-SELECTGROUP[data-hide]\"); //登陆选择技能组\n            let toggleTarget = doc.querySelector(\"#PHONE-ENTRY-TOGGLE[data-hide]\"); //切换状态\n            let settingTarget = doc.querySelector(\"#PHONE-ENTRY-SETTING[data-hide]\"); //设置页面\n            let panel = doc.querySelector(\"#PHONE-ENTRY-PANEL[data-hide]\"); //拨号面板\n            let switchPage = doc.querySelector(\"#PHONE-ENTRY-SWITCH[data-hide]\"); //转接页面\n            var incomingStatus = doc.querySelector(\"#PHONE-LEFT-STATUS>div[data-type='incomingStatus']>div\"); //来电\n\n            //loginTarget 登陆页面元素\n            let Logininputs = doc.querySelectorAll('#PHONE-ENTRY-LOGIN[data-hide] input[data-type]');\n            let switchnumber = Logininputs[0]; //总机号\n            let seatnumber = Logininputs[1]; //分机号\n            let password = Logininputs[2]; //密码\n            let modelnumber = Logininputs[3]; //回拨话机/sip话机\n            let error = loginTarget.querySelector(\"span[data-type='error']\"); // 错误提示\n            var statusBtn = loginTarget.querySelector(\"[data-type='loginStatus']\");\n            var status_text = statusBtn.querySelector(\"span\"); // 示忙/示闲\n            let modelSel = loginTarget.querySelectorAll(\"li#model input[name='callintype']\");\n            let modelLi = loginTarget.querySelector(\"li[data-type='model']\");\n            //  toggleTarget 切换状态\n            let leisureStatus = toggleTarget.querySelector(\"li[data-type='leisure']\");\n            let busyStatus = toggleTarget.querySelector(\"li[data-type='busy']\");\n            let logoutStatus = toggleTarget.querySelector(\"li[data-type='logout']\");\n            // settingTarget //设置页面元素\n            let register_server = doc.querySelector(\"#PHONE-ENTRY-SETTING input[data-type='registerServer']\");\n            let wss_url = doc.querySelector(\"#PHONE-ENTRY-SETTING input[data-type='websocketUrl']\");\n            let optionInp = doc.querySelectorAll(\"#PHONE-ENTRY-SETTING option\");\n            let kefuList = doc.querySelector(\"#PHONE-ENTRY-SWITCH[data-hide] [data-type='kefuList']\"); //坐席\n            //状态 退出空闲忙碌元素\n            //panel 快速拨号元素\n            let panelInput = doc.querySelector(\"#PHONE-ENTRY-PANEL[data-hide] input[data-type='input']\"); //手机号输入框\n            // switchPage转接页元素\n            let p = switchPage.querySelector(\"[data-type='select_text']\");\n            let errorTitle = switchPage.querySelector(\"span[data-type='error']\");\n            let checkInp = doc.querySelector(\"#PHONE-ENTRY-SWITCH[data-hide] [data-type='checkbox']\");\n\n            //incomingStatus来电呼入\n            var incomingBg = incomingStatus.querySelector(\"div[data-type='bg']\");\n            // var incomingN = incomingStatus.querySelector(\"span[data-type='number']\")\n            var incomingS = incomingStatus.querySelector(\"span[data-type='status']\");\n            var incomingA = incomingStatus.querySelector(\"button[data-type='answer']\");\n            //自动登陆\n            if (localStorage && localStorage.userData) {\n                this.register();\n            }\n            // 聚焦 错误提示隐藏\n            // Array.from(Logininputs).forEach(v => {\n            //     v.onfocus = () => { error.innerText = '' }\n            // })\n            //工具条点击事件\n            Array.from(actionButtons).forEach(v => {\n                stopProList.push(v);\n                v.onclick = function (e) {\n                    e.stopPropagation();\n                    //this here is v so we can't use arrow function.\n                    //BUT I really hate coding like this!!\n                    var type = this.getAttribute(\"data-phone-type\");\n                    var key = this.getAttribute(\"data-phone-key\");\n                    if (this.classList.contains(\"gray\")) return;\n                    switch (key) {\n                        case \"0\":\n                            //注册,这里主要是续注册处理，要优化\n                            if (type == 'register') {\n                                that.log(_phone2.default.kefuStatus);\n                                if (_phone2.default.kefuStatus > 0) {\n                                    var userData = JSON.parse(localStorage.userData);\n                                    var leisure = doc.querySelector(\"#PHONE-ENTRY-TOGGLE li[data-type='leisure']\");\n                                    var busy = doc.querySelector(\"#PHONE-ENTRY-TOGGLE li[data-type='busy']\");\n                                    leisure.dataset.hide = busy.dataset.hide = userData.seatMode == 1 ? \"0\" : \"1\";\n                                    that.setDisplayNone(\"statusPage\");\n                                } else {\n                                    _phone2.default.kefuStatus = status_text.innerText == '示闲' ? 1 : 2; // 若不切换示忙示闲，默认是闲的状态\n                                    that.setDisplayNone(\"loginPage\");\n                                }\n                            }\n                            break;\n                        case \"1\":\n                            // 快速呼叫 挂断 保持 恢复\n                            var holdBtn = doc.querySelector(\"#EphoneBar li[data-phone-type='hold']\");\n                            var unHoldBtn = doc.querySelector(\"#EphoneBar li[data-phone-type='unhold']\");\n                            if (type == 'open') {\n                                that.setDisplayNone(\"fastPage\");\n                            }\n                            if (type == 'terminate') {\n                                _phone2.default.terminate(that.ccNumber);\n                            }\n                            if (type == 'hold') {\n                                _phone2.default.hold(that.ccNumber);\n                                holdBtn.dataset.hide = \"0\";\n                                unHoldBtn.dataset.hide = \"1\";\n                            }\n                            if (type == 'unhold') {\n                                _phone2.default.unhold(that.ccNumber);\n                                holdBtn.dataset.hide = \"1\";\n                                unHoldBtn.dataset.hide = \"0\";\n                            }\n                            break;\n                        case \"2\":\n                            // 转接\n                            var hide = doc.querySelector(\"#PHONE-ENTRY-SWITCH[data-hide]\").dataset.hide;\n                            // 仅看在线坐席复选框 置为false(未选)\n                            if (hide == 0) {\n                                // 置空可转接座席选择框\n                                checkInp.checked = false;\n                                checked = 0;\n                                // 获取技能组\n                                that.getGroup();\n\n                                // 获取坐席  getMembers\n                                var userData = JSON.parse(localStorage.userData);\n                                gid = userData.loginGid ? userData.loginGid : -1;\n                                var webParam = {\n                                    un: userData.userInfo.number,\n                                    pwd: userData.pwd,\n                                    eid: userData.eid,\n                                    searchGid: gid,\n                                    length: 20\n                                };\n                                that.getMembers(webParam, gid);\n\n                                // 获取技能组状态 getMemberCallStates\n                                // var res3 = await webApiHandler(\"getMemberCallStates\", webParam)\n                                // console.log({ getMemberCallStates: res3 })\n                            }\n                            that.setDisplayNone(\"switchPage\");\n                            break;\n                        case '4':\n                            //设置\n                            var moveBtn = doc.querySelector(\"#PHONE-ENTRY-SETTING input[data-type='move']\");\n                            var fixBtn = doc.querySelector(\"#PHONE-ENTRY-SETTING input[data-type='fix']\");\n                            var userData = JSON.parse(localStorage.userData);\n                            that.setDisplayNone(\"setting\");\n                            if (userData) userData.seatMode == \"1\" ? moveBtn.checked = true : fixBtn.checked = true;\n                        default:\n                    }\n                };\n            });\n            //话机模式 切换\n            Array.from(modelSel).forEach(v => {\n                v.onchange = function () {\n                    if (this.value != '2') {\n                        modelLi.dataset.hide = '1';\n                        modelLi.querySelectorAll('span').forEach(sv => {\n                            sv.dataset.hide = sv.dataset.type == this.value ? \"1\" : \"0\";\n                        });\n                        modelnumber.value = '';\n                        modelnumber.oninput = null;\n                        modelnumber.oninput = function () {\n                            if (v.value == '5') {\n                                this.value = this.value.replace(/\\D/g, '');\n                            } else {\n                                this.value = this.value.replace(/[^0-9A-Z]/g, '');\n                            }\n                            this.value.length > 15 ? this.value = this.value.substr(0, 14) : this.value;\n                        };\n                    } else {\n                        modelLi.dataset.hide = '0';\n                    }\n                };\n            });\n            //loginTarget 登陆页面\n            loginTarget.onclick = async function (e) {\n                e.stopPropagation();\n                var target = e.target || e.srcElement;\n                if (target.dataset.type == 'close') {\n                    loginTarget.dataset.hide = '0';\n                    that.setArrowNone();\n                }\n                if (target.dataset.type == 'loginStatus' || target.parentNode.dataset.type == 'loginStatus') {\n                    if (statusBtn.classList.contains('busy')) {\n                        statusBtn.classList.remove('busy');\n                        status_text.innerText = \"示闲\";\n                        localStorage.preferredStatus = '1';\n                    } else {\n                        statusBtn.classList.add('busy');\n                        status_text.innerText = \"示忙\";\n                        localStorage.preferredStatus = '2';\n                    }\n                }\n                if (target.dataset.type == 'login') {\n                    var checkedModel = loginTarget.querySelector(\"li#model input[name='callintype']:checked\").value;\n                    that.callintype = loginTarget.querySelector(\"input[type='radio'][name='callintype']:checked\").value;\n                    if (switchnumber.value.length == 0) return that.showError(switchnumber, error, '请输入总机号码');\n                    if (seatnumber.value.length == 0) return that.showError(seatnumber, error, '请输入分机号码');\n                    if (seatnumber.value.length < 4 || seatnumber.value.length > 6) return that.showError(seatnumber, error, '分机号码错误，请重新输入');\n                    if (password.value.length == 0) return that.showError(password, error, '请输入密码');\n                    if (checkedModel != '2' && modelnumber.value.length == '') return that.showError(modelnumber, error, '请输入话机号码');\n\n                    if (target.dataset.disabled == \"0\") return;\n                    target.dataset.disabled = \"0\";\n                    var res = await (0, _getLoginInfo.getLoginData)(seatnumber.value, password.value, switchnumber.value, that.callintype, that.callintype != \"2\" ? modelnumber.value : undefined);\n                    that.log(\"getLoginData\", { res: res });\n\n                    if (res.status == 50000) {\n                        that.showError(switchnumber, error, '总机号码错误，请重新输入');\n                        target.dataset.disabled = \"1\";\n                        return;\n                    }\n                    if (res.status == 50001) {\n                        that.showError(switchnumber, error, '未找到该企业，请改用别的账号试试');\n                        target.dataset.disabled = \"1\";\n                        return;\n                    }\n                    if (res.status == 50002) {\n                        that.showError(seatnumber, error, '分机号码或密码错误，请重新输入');\n                        target.dataset.disabled = \"1\";\n                        return;\n                    }\n                    if (res.status == 50003) {\n                        that.showError(switchnumber, error, '参数错误');\n                        target.dataset.disabled = \"1\";\n                        return;\n                    }\n                    if (res.status == 50004) {\n                        that.showError(modelnumber, error, '回拨话机号码不存在');\n                        target.dataset.disabled = \"1\";\n                        return;\n                    }\n                    // that.log({ groupInfo: res.memberInfo.inGroups})\n                    var groupInfo = JSON.parse(localStorage.userData).groupInfo;\n                    if (groupInfo.length > 1) {\n                        loginTarget.dataset.hide = \"0\";\n                        selectGroupTarget.dataset.hide = \"1\";\n                        var group = '';\n                        groupInfo.map((v, i) => {\n                            group += \"<li title='\" + v.name + \"' data-eid='\" + v.eid + \"' data-id='\" + v.id + \"'>\" + v.name + \"</li>\";\n                        });\n                        doc.querySelector(\"#PHONE-ENTRY-SELECTGROUP ul[data-type='groupList']\").innerHTML = group;\n                        target.dataset.disabled = \"1\";\n                        return;\n                    }\n                    var params = {\n                        switchnumber: switchnumber.value,\n                        un: seatnumber.value,\n                        pwd: password.value,\n                        gid: groupInfo[0] ? groupInfo[0].id : 0,\n                        callintype: that.callintype,\n                        socketUri: that.socket_uri,\n                        remoteAudio: \"peeraudio\"\n                    };\n                    that.register(params, target);\n                }\n            };\n            // 切换坐席状态、退出\n            toggleTarget.addEventListener(\"click\", function (e) {\n                e.stopPropagation();\n                var target = e.target || e.srcElement;\n                var title = doc.querySelector(\"#PHONE-LEFT-STATUS div[data-type='pattern']>div\");\n                var userData = localStorage.getItem(\"userData\") ? JSON.parse(localStorage.getItem(\"userData\")) : false;\n                var seatMode = userData.seatMode;\n                if (target.dataset.type == \"leisure\" || target.parentNode.dataset.type == \"leisure\") {\n                    // 示闲\n                    if (seatMode == 1) return;\n                    _phone2.default.changeStaus(\"1\", false);\n                }\n                if (target.dataset.type == \"busy\" || target.parentNode.dataset.type == \"busy\") {\n                    // 示忙\n                    if (seatMode == 1) return;\n                    if (that.ccNumber) {\n                        _phone2.default.preSetStatus({ ccNumber: that.ccNumber, code: busyStatus.dataset.status }, function (res) {\n                            if (res.code == 200) {\n                                busyStatus.dataset.status = busyStatus.dataset.status == \"2\" ? \"-1\" : \"2\";\n                                busyStatus.querySelector(\"span\").innerText = busyStatus.dataset.status == \"2\" ? \"忙碌\" : \"取消\";\n                            }\n                            target.dataset.disabled = \"1\";\n                        });\n                        that.log('通话中修改状态', busyStatus.dataset.status);\n                    } else {\n                        _phone2.default.changeStaus(\"2\", false);\n                    }\n                }\n                if (target.dataset.type == \"logout\" || target.parentNode.dataset.type == \"logout\") {\n                    // 退出\n                    if (target.dataset.disabled == \"true\" || target.parentNode.dataset.disabled == \"true\" || that.ccNumber) return;\n                    _phone2.default.stop(function (res) {\n                        if (res.code == 200) {\n                            kefuStatus.dataset.hide = '0';\n                            that.setDisplayNone(\"all\");\n                            that.sethighlight('register', true);\n                            title.dataset.hide = '0';\n                            if (localStorage.getItem(\"preferredStatus\")) localStorage.removeItem(\"preferredStatus\");\n                        } else {\n                            alert(res.info);\n                        }\n                    });\n                }\n                toggleTarget.dataset.hide = \"0\";\n                that.setArrowNone();\n            });\n\n            // PHONE-ENTRY-SETTING 更改设置\n            settingTarget.onclick = function (e) {\n                e.stopPropagation();\n                var target = e.target || e.srcElement;\n                if (target.dataset.type == 'confirm') {\n                    var userData = JSON.parse(localStorage.userData);\n                    var bar = doc.querySelector(\"#EphoneBar\");\n                    var status = doc.querySelector(\"#PHONE-LEFT-STATUS\");\n                    var title = doc.querySelector(\"#PHONE-LEFT-STATUS div[data-type='pattern']>div\");\n                    var patternRadioValue = settingTarget.querySelector(\"input[type='radio'][name='pattern']:checked\").getAttribute(\"value\");\n                    var postionRadioValue = settingTarget.querySelector(\"input[type='radio'][name='postionButton']:checked\").getAttribute(\"value\");\n                    var pattern = patternRadioValue == \"51\" ? 1 : 2;\n                    var setting = { postion: postionRadioValue\n                        //模式\n                    };if (!userData) return;\n                    userData.setting = setting;\n                    localStorage.setItem('userData', JSON.stringify(userData));\n                    if (userData.seatMode != pattern) {\n                        _phone2.default.setSeatMode(patternRadioValue);\n                        title.dataset.hide = pattern == 1 ? \"1\" : \"0\";\n                        pattern == 1 ? that.sethighlight(\"register,setting\", true) : that.sethighlight(\"register,open,setting\", true);\n                    }\n                    //定位\n                    that.setTogglePosition(setting);\n                    that.setArrowNone();\n                    settingTarget.dataset.hide = 0;\n                    //wss\n                    // for(var i = 0;i<optionInp.length;i++) {\n                    //     if (optionInp[i].selected) {\n                    //         wssMode = optionInp[i].innerText\n                    //     }\n                    // }\n                    // setting.socket.uri = wssMode   // 更改wss地址\n                    // loginTarget.dataset.hide = 1\n                    // var userData = JSON.parse(localStorage.userData)\n                    // var params = {\n                    //     switchnumber: userData.switchnumber,\n                    //     seatnumber: userData.userInfo.number,\n                    //     password: slice(8, userData.clearPwd.length - 6),\n                    //     gid: userData.loginGid,\n                    //     callintype: \"2\",\n                    //     socketUri: setting.socket.uri,\n                    //     status: Phone.kefuStatus\n                    // }\n                    // that.register(params)\n                }\n\n                if (target.dataset.type == 'close') {\n                    settingTarget.dataset.hide = 0;\n                    that.setArrowNone();\n                }\n            };\n            // PHONE-ENTRY-SELECTGROUP 选择技能组\n            selectGroupTarget.onclick = function (e) {\n                e.stopPropagation();\n                var target = e.target || e.srcElement;\n\n                if (target.dataset.type == \"close\") {\n                    selectGroupTarget.dataset.hide = '0';\n                    loginTarget.dataset.hide = '1';\n                    if (localStorage.userData) localStorage.removeItem('userData');\n                }\n                if (target.parentNode.dataset.type == \"groupList\") {\n                    var list = target.parentNode.children;\n                    Array.from(list).forEach(v => {\n                        v.classList.remove('selected');\n                    });\n                    target.classList.add('selected');\n                    targetId = target.dataset.id;\n                    that.log(\"groupList:id\", targetId);\n                }\n                if (target.dataset.type == \"confirm\") {\n                    if (target.dataset.disabled == \"0\") return;\n                    var len = document.querySelectorAll(\"#PHONE-ENTRY-SELECTGROUP ul[data-type='groupList']>li.selected\").length;\n                    if (len < 1) return;\n\n                    target.dataset.disabled = \"0\";\n                    var userData = JSON.parse(localStorage.userData);\n                    var params = {\n                        switchnumber: userData.switchNumber,\n                        un: userData.userInfo.number,\n                        pwd: userData.pwd,\n                        gid: targetId,\n                        callintype: that.callintype,\n                        socketUri: that.socket_uri,\n                        remoteAudio: \"peeraudio\"\n                    };\n                    that.register(params, target);\n                }\n            };\n            // PHONE-ENTRY-PANEL 快速呼叫 \n            panel.onclick = function (e) {\n                e.stopPropagation();\n                var target = e.target || e.srcElement;\n                if (target.dataset.type == 'close') {\n                    that.setArrowNone();\n                    panel.dataset.hide = '0';\n                }\n\n                if (target.dataset.type == 'call') {\n                    //拨号\n                    if (panelInput.value.length == 0) return;\n                    var peerID = panelInput.value;\n                    var userData = JSON.parse(localStorage.userData);\n                    var extension_start = parseInt(userData.epInfo.extension_start);\n                    var extension_end = parseInt(userData.epInfo.extension_end);\n                    that.callType = parseInt(peerID) >= extension_start && parseInt(peerID) <= extension_end ? 3 : 2;\n                    var params = {\n                        peerID: that.callType == 2 ? \"9\" + peerID : peerID,\n                        callType: that.callType\n                    };\n                    _phone2.default.call(params);\n                    that.phoneStatus('outgoingCall', { panelInput: peerID, callType: params.callType });\n                    panelInput.value = '';\n                    panel.dataset.hide = 0;\n                }\n            };\n            panelInput.onkeydown = function (e) {\n                if (e.keyCode == \"13\") {\n                    if (panelInput.value.length == 0) return;\n                    var peerID = panelInput.value;\n                    var userData = JSON.parse(localStorage.userData);\n                    var extension_start = parseInt(userData.epInfo.extension_start);\n                    var extension_end = parseInt(userData.epInfo.extension_end);\n                    that.callType = parseInt(peerID) >= extension_start && parseInt(peerID) <= extension_end ? 3 : 2;\n                    var params = {\n                        peerID: that.callType == 2 ? \"9\" + peerID : peerID,\n                        callType: that.callType\n                    };\n                    _phone2.default.call(params);\n                    that.phoneStatus('outgoingCall', { panelInput: peerID, callType: params.callType });\n                    panelInput.value = '';\n                    panel.dataset.hide = 0;\n                }\n            };\n            //接听\n            incomingA.onclick = function (e) {\n                e.stopPropagation();\n                if (this.dataset.disabled == \"0\") return;\n                if (this.closeTimer) global.clearTimeout(this.closeTimer);\n                this.dataset.disabled = \"0\";\n                incomingS.innerHTML = \"呼叫中<span class='dotting'></span>\";\n                _phone2.default.answerPBXCall(that.ccNumber);\n            };\n            // PHONE-ENTRY-SWITCH 转接\n            switchPage.onclick = async function (e) {\n                e.stopPropagation();\n                var target = e.target || e.srcElement;\n                var hide = doc.querySelector('#GROUP ul[data-type=\"group\"]');\n                if (target.parentNode.dataset.type == \"select\" || target.dataset.type == 'select' || target.classList[0] == 'arrow') {\n                    hide.dataset.hide = hide.dataset.hide == '1' ? '0' : '1';\n                } else {\n                    hide.dataset.hide = \"0\";\n                }\n                if (target.parentNode.dataset.type == \"group\") {\n                    p.innerText = target.innerText;\n                    doc.querySelector('#GROUP ul[data-type=\"group\"]').dataset.hide = 0;\n                    that.log(target.dataset.id);\n                    gid = target.dataset.id ? target.dataset.id : -1;\n\n                    page = 1;\n                    // 获取某组坐席  getMembers\n                    var userData = JSON.parse(localStorage.userData);\n                    var webParam = {\n                        un: userData.userInfo.number,\n                        pwd: userData.pwd,\n                        eid: userData.eid,\n                        searchGid: gid,\n                        length: 20\n                    };\n                    if (checked) {\n                        webParam.searchServiceControl = checked;\n                    }\n                    that.getMembers(webParam, gid);\n                }\n                if (target.dataset.type == \"checkbox\") {\n                    page = 1;\n                    that.log(target.checked);\n                    var userData = JSON.parse(localStorage.userData);\n                    var webParam = {\n                        un: userData.userInfo.number,\n                        pwd: userData.pwd,\n                        eid: userData.eid,\n                        searchGid: gid,\n                        length: 20\n                    };\n                    if (target.checked) {\n                        checked = 1;\n                        webParam.searchServiceControl = checked;\n                    } else {\n                        checked = 0;\n                    }\n\n                    that.getMembers(webParam, gid);\n                }\n                if (target.dataset.type == \"close\") {\n                    that.setDisplayNone(\"switchPage\");\n                    p.innerText = '未分组';\n                    that.setArrowNone();\n                }\n                if (target.parentNode.dataset.type == \"kefuList\") {\n                    if (target.dataset.status == \"offLine\" || target.dataset.status == \"busy\") return;\n\n                    var len = target.parentNode.children.length;\n                    for (var i = 0; i < len; i++) {\n                        target.parentNode.children[i].classList.remove('selected');\n                    }\n                    target.classList.add('selected');\n                    gid = target.dataset.gids;\n                    tranNumber = target.dataset.number;\n                }\n                if (target.dataset.type == \"transfer\" && target.dataset.disabled != \"0\" && gid && tranNumber) {\n                    that.log('正在转接...', { gid, tranNumber, ccNumber: that.ccNumber });\n                    target.dataset.disabled = '0';\n                    errorTitle.style.color = '#19C583';\n                    errorTitle.innerText = '正在转接,请稍后...';\n                    that.sethighlight(\"all\", true);\n                    _phone2.default.transferPBXCall(gid, tranNumber, that.ccNumber, function (res) {\n                        if (res.type == \"transferCallFaild\") {\n                            switchPage.dataset.hide = '1';\n                            errorTitle.style.color = '#FD3D39';\n                            errorTitle.innerText = '电话转接失败';\n                            if (timer) global.clearTimeout(timer);\n                            timer = global.setTimeout(() => {\n                                errorTitle.innerText = '';\n                                that.sethighlight(\"terminate,hold,unhold,switch\", true);\n                            }, 2000);\n                        } else {\n\n                            errorTitle.innerText = \"电话转接成功\";\n                            if (timer) global.clearTimeout(timer);\n                            timer = global.setTimeout(() => {\n                                errorTitle.innerText = '';\n                                switchPage.dataset.hide = '0';\n                            }, 2000);\n                        }\n                        target.dataset.disabled = '1';\n                    });\n                }\n            };\n            //滚动加载坐席\n            kefuList.onscroll = function (e) {\n                var target = e.target || e.srcElement;\n                var pageTotal = Math.ceil(parseInt(that.recordsTotal) / 20);\n\n                if (target.scrollTop >= target.scrollHeight - target.offsetHeight) {\n                    if (page == pageTotal) return;\n                    var userData = JSON.parse(localStorage.userData);\n                    var webParam = {\n                        un: userData.userInfo.number,\n                        pwd: userData.pwd,\n                        eid: userData.eid,\n                        searchGid: gid,\n                        start: 20 * page,\n                        length: 20\n                    };\n                    that.getMembers(webParam, gid, true);\n                    page++;\n                }\n            };\n            //拨号面板\n            // var planePage = doc.querySelector(\"#PHONE-PANEL\")\n            // var input = planePage.querySelector(\"input[data-type='input']\")\n            // planePageBtn.onclick = function (e) {\n            //     e.stopPropagation()\n            //     var hide = planePage.dataset.hide\n            //     planePage.dataset.hide = hide == '0' ? \"1\" : \"0\"\n            // }\n            // planePage.onclick = function (e) {\n            //     e.stopPropagation()\n            //     var target = e.target || e.srcElement\n            //     var type = target.dataset.type\n            //     if (type == 'num') {  //点击数字键盘\n            //         input.value += target.value\n            //         Phone.sendDTMF(target.value)\n            //         input.focus()\n            //     }\n            //     if (type == 'call') { //删除\n            //         if (input.value.length == 0) return\n            //         input.value = input.value.substring(0, input.value.length - 1)\n            //     }\n            //     if (type == 'close') { //删除\n            //         planePage.dataset.hide = \"0\"\n            //     }\n\n            // }\n\n            stopProList.push(loginTarget, selectGroupTarget, settingTarget, panel, switchPage, toggleTarget, incomingA);\n            if (this.options.drop) this._stopPro(stopProList);\n        }\n        // 获取技能组\n        async getGroup() {\n            var userData = JSON.parse(localStorage.userData);\n            var webParam = {\n                un: userData.userInfo.number,\n                pwd: userData.pwd,\n                eid: userData.eid\n                // needPbxFields: 1\n            };\n            var res = await (0, _getLoginInfo.webApiHandler)(\"getGroups\", webParam);\n            this.log({ getGroups: res });\n            var groups = \"<li>未分组</li>\";\n            var searchName;\n            res.returnData.map((v, i) => {\n                v.id == userData.loginGid && (searchName = v.name);\n                groups += \"<li data-eid='\" + v.eid + \"' data-id='\" + v.id + \"' data-level='\" + v.level + \"' data-name='\" + v.name + \"' data-oid='\" + v.oid + \"' data-pid='\" + v.pid + \"'>\" + v.name + \"</li>\";\n            });\n            doc.querySelector(\"#PHONE-ENTRY-SWITCH[data-hide] [data-type='select_text']\").innerText = searchName ? searchName : '未分组';\n            var selectDom = doc.querySelector('#PHONE-ENTRY-SWITCH ul[data-type=\"group\"]');\n            selectDom.innerHTML = groups;\n        }\n\n        // 请求坐席\n        async getMembers(webParam, gid, isScroll) {\n            var res = await _phone2.default.webApiHandler(\"searchEpMembers\", webParam);\n            this.recordsTotal = res.returnData.recordsTotal;\n            this.log({ getMembers: res });\n            var members = '';\n            if (res.returnData.data.length) {\n                res.returnData.data.map((v, i) => {\n                    var status;\n                    if (v.service_control == 0 || v.service_control == 2) {\n                        status = 'offLine';\n                    } else if (v.service_control == 1) {\n                        status = '';\n                    } else if (v.service_control > 2) {\n                        status = 'busy';\n                    }\n                    members += \"<li title='\" + v.displayname + \"' data-status_code='\" + v.service_control + \"' data-status='\" + status + \"' data-gids='\" + gid + \"' data-number='\" + v.number + \"'>\" + v.displayname + \"<span></span></li>\";\n                });\n            } else {\n                members += \"<li data-type='noOne'>暂无坐席</li>\";\n            }\n            var liDom = doc.querySelector('#PHONE-ENTRY-SWITCH>#SWITCH_PlATE>ul');\n            if (isScroll) {\n                liDom.innerHTML = liDom.innerHTML + members;\n            } else {\n                liDom.innerHTML = members;\n            }\n        }\n\n        register(params, target) {\n            if (target) target.dataset.disabled = '1';\n            function kickOffcb(data) {\n                let resCode = data.r;\n                this.log(\"被踢下线\", resCode);\n                switch (resCode) {\n                    case \"895\":\n                    case \"897\":\n                        this.setDisplayNone(\"all\");\n                        var str = resCode == '897' ? '注册超时，请重新登录' : '其他用户登录您的账号';\n                        var modal = confirm(str + \"确认重新登录,取消退出状态\");\n                        if (modal) {\n                            _phone2.default.terminate(this.ccNumber);\n                            this.register();\n                        } else {\n                            _phone2.default.stop(res => {\n                                if (res.code == 200) {\n                                    if (_phone2.default.session) {\n                                        // 通话状态时，选择退出，需要 endPBXCall 的逻辑\n                                        this.phoneStatus('endPBXCall', { type: \"kickOff\" });\n                                    }\n                                    doc.querySelector(\"#EphoneBar li[data-phone-type='register'] span[data-type='toggle']\").dataset.hide = '0';\n                                    this.sethighlight('register', true);\n                                } else {\n                                    alert(res.info);\n                                }\n                            });\n                        }\n                        this.ccNumber = undefined;\n                        break;\n                    case \"898\":\n                    case \"899\":\n                        alert(resCode == '898' ? \"账号过期/账号被删/账号修改，请重新登录\" : \"企业停止\");\n                        _phone2.default.stop(res => {\n                            if (res.code == 200) {\n                                if (_phone2.default.session) {\n                                    this.phoneStatus('endPBXCall', { type: \"kickOff\" });\n                                }\n                                doc.querySelector(\"#EphoneBar li[data-phone-type='register'] span[data-type='toggle']\").dataset.hide = '0';\n                                this.sethighlight('register', true);\n                            }\n                        });\n                        this.ccNumber = undefined;\n                        break;\n                }\n            }\n\n            function registercb(data) {\n                if (target) target.dataset.disabled = \"1\";\n\n                let resCode = data.code;\n                if (resCode != 200) {\n                    //登录失败；用户名、密码的错误在getLoginData已经做了检查，所以这次错误应该主要是网络原因\n                    //registrationFailed 暂时设置code = 500\n                    alert(data.info);\n                    return;\n                }\n                this.log(`What is current status:${_phone2.default.kefuStatus}`);\n                if (_phone2.default.session || this.ccNumber) return;\n                var title = doc.querySelector(\"#PHONE-LEFT-STATUS div[data-type='pattern']>div\"); //移动模式提示\n                var userData = localStorage.userData ? JSON.parse(localStorage.userData) : undefined;\n                //初始状态\n                this.setDisplayNone(\"all\");\n                this.setArrowNone();\n                if (userData) {\n                    userData.seatMode == 1 ? this.sethighlight(\"register,setting\", true) : this.sethighlight(\"register,open,setting\", true);\n                    title.dataset.hide = userData.seatMode == 1 ? \"1\" : \"0\";\n                } else {\n                    _phone2.default.stop();\n                    this.sethighlight('register', true);\n                }\n            }\n\n            function statusEvent(data) {\n                let resCode = data.code;\n                switch (resCode) {\n                    case 302:\n                        _phone2.default.stop(res => {\n                            if (res.code == 200) {\n                                alert(data.info);\n                                doc.querySelector(\"#EphoneBar li[data-phone-type='register'] span[data-type='toggle']\").dataset.hide = '0';\n                                this.sethighlight('register', true);\n                            } else {\n                                alert(res.info);\n                            }\n                        });\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            let callbackMap = {\n                \"callEvent\": this.phoneStatus.bind(this),\n                \"kickedOffLine\": kickOffcb.bind(this),\n                \"statusEvent\": statusEvent.bind(this),\n                \"register\": registercb.bind(this)\n            };\n            _phone2.default.init(params, callbackMap);\n        }\n\n        _addDrop(toolbar, target) {\n            var thisWrapper = this;\n            toolbar.onmousedown = function (ev) {\n                ev.stopPropagation();\n                ev.preventDefault();\n                target.setCapture && target.setCapture();\n\n                var oEvent = ev || event;\n                var disX = oEvent.clientX - this.offsetLeft;\n                var disY = oEvent.clientY - this.offsetTop;\n\n                this.style.position = \"fixed\";\n                this.style.cursor = \"move\";\n\n                document.onmousemove = ev => {\n                    var oEvent = ev || event;\n                    var l = oEvent.clientX - disX;\n                    var t = oEvent.clientY - disY;\n                    var clientHeight = document.body.clientHeight || document.documentElement.offsetHeight || document.body.scrollHeight || window.screen.height - 133;\n                    var clientWidth = document.body.clientWidth || document.documentElement.clientWidth || document.body.clientWidth;\n\n                    if (l <= 20) {\n                        l = 0;\n                    }\n                    if (l >= clientWidth - parseInt(this.offsetWidth) - 20) {\n                        l = clientWidth - parseInt(this.offsetWidth);\n                    }\n                    if (t >= clientHeight - parseInt(thisWrapper.options.height) - 20) {\n                        t = clientHeight - parseInt(thisWrapper.options.height);\n                    }\n                    if (t <= 20) {\n                        t = 0;\n                    }\n                    this.style.left = l + 'px';\n                    this.style.top = t + 'px';\n                };\n\n                document.onmouseup = () => {\n                    document.onmousemove = null; //如果不取消，鼠标弹起div依旧会随着鼠标移动\n                    document.onmouseup = null;\n                    this.style.cursor = \"default\";\n                    toolbar.setCapture && target.releaseCapture();\n                };\n                //    };\n            };\n        }\n        _stopPro(arr) {\n            arr.forEach(v => {\n                v.addEventListener(\"mousedown\", function (e) {\n                    e.stopPropagation();\n                });\n            });\n        }\n        _hideAllMode() {\n            document.addEventListener(\"click\", e => {\n                e.stopPropagation();\n                this.setDisplayNone(\"all\");\n            });\n        }\n        timerWatch(target, falg) {\n            var second = 0,\n                minute = 0,\n                hour = 0,\n                timer = null;\n            target.innerText = '00:00:00';\n            if (falg) {\n                global.clearInterval(this.watchTimer);\n                this.watchTimer = global.setInterval(() => {\n                    second++;\n                    if (second >= 60) {\n                        second = 0;\n                        minute++;\n                    }\n                    if (minute >= 60) {\n                        minute = 0;\n                        hour++;\n                    }\n                    // hour < 10 ? '0' + hour : hour + \":\" + minute < 10 ? '0' + minute : minute +\n                    target.innerText = (hour < 10 ? '0' + hour : hour) + \":\" + (minute < 10 ? '0' + minute : minute) + ':' + (second < 10 ? '0' + second : second);\n                }, 1000);\n            } else {\n                global.clearInterval(this.watchTimer);\n            }\n        }\n        sethighlight(str, flag) {\n            var actionButtons = document.querySelectorAll('#EphoneBar li[data-phone-key]'); //工具条面板\n            actionButtons.forEach(v => {\n                if (str.indexOf(v.dataset.phoneType) !== -1) {\n                    flag ? v.classList.remove(\"gray\") : v.classList.add(\"gray\");\n                    if (v.dataset.phoneType == 'terminate') flag ? v.style.color = \"red\" : v.style = '#999';\n                } else {\n                    flag ? v.classList.add(\"gray\") : v.classList.remove(\"gray\");\n                    if (v.dataset.phoneType == 'terminate') flag ? v.style = '#999' : v.style.color = \"red\";\n                }\n            });\n        }\n        setDisplayNone(str) {\n            var modes = document.querySelectorAll(\"#PHONE-ENTRY-CONTAINER  div[data-toggle]\");\n            var arrows = document.querySelectorAll('#EphoneBar div[data-arrow]');\n            var arr = ['loginPage', 'selectGroup', 'statusPage', 'fastPage', 'switchPage', 'setting'];\n            var compArr = ['register', 'register', 'register', 'open', 'switch', 'setting'];\n            Array.from(arrows).forEach(v => {\n                v.dataset.hide = \"0\";\n            });\n            Array.from(modes).forEach(v => {\n                if (str.indexOf(v.dataset.toggle) !== -1) {\n                    var index = arr.indexOf(v.dataset.toggle);\n\n                    v.dataset.hide = v.dataset.hide == \"1\" ? \"0\" : \"1\";\n                    v.dataset.hide == \"1\" && v.querySelector(\"input[type='text']\") && v.querySelector(\"input\").focus();\n                    if (index >= 0) {\n                        document.querySelector('#EphoneBar div[data-arrow=' + compArr[index] + ']').dataset.hide = v.dataset.hide;\n                    }\n                } else {\n                    v.dataset.hide = \"0\";\n                }\n            });\n        }\n        setTogglePosition(setting) {\n            var modes = document.querySelectorAll(\"#PHONE-ENTRY-CONTAINER  div[data-toggle]\");\n            var bar = doc.querySelector(\"#EphoneBar\");\n            var status = doc.querySelector(\"#PHONE-LEFT-STATUS\");\n            var radio = doc.querySelector(\"#PHONE-ENTRY-SETTING[data-hide] input[data-type='postionButton'][value=\" + setting.postion + \"]\");\n            var isLeft = setting.postion && setting.postion == 'left';\n\n            bar.style.float = isLeft ? \"left\" : 'right';\n            status.style.float = isLeft ? \"right\" : \"left\";\n            radio.checked = true;\n\n            Array.from(modes).forEach(v => {\n                if (v.dataset.toggle != 'statusPage') v.style.left = isLeft ? \"0px\" : parseInt(this.options.width) - 300 + \"px\";\n            });\n        }\n        setArrowNone() {\n            var arrows = document.querySelectorAll(\"#EphoneBar>li>div[data-arrow]\");\n            Array.from(arrows).forEach(v => {\n                v.dataset.hide = '0';\n            });\n        }\n        showError(target, errorTarget, text) {\n            global.clearTimeout(this.titleTimer);\n            errorTarget.innerText = text;\n            target.focus();\n            this.titleTimer = global.setTimeout(() => {\n                errorTarget.innerText = \"\";\n            }, 2000);\n        }\n        get ccNumber() {\n            return this._ccNumber;\n        }\n        set ccNumber(c) {\n            // 会话中状态操作控制\n            var statusList = doc.querySelector(\"#PHONE-ENTRY-TOGGLE[data-hide]\").querySelectorAll(\"li[data-type^=l]\"); //切换状态是否禁用\n            var busy = doc.querySelector(\"#PHONE-ENTRY-TOGGLE[data-hide]\").querySelector(\"li[data-type='busy']\");\n            Array.from(statusList).forEach(v => {\n                if (c) {\n                    v.style.color = '#999';\n                    v.dataset.disabled = true;\n                } else {\n                    v.dataset.disabled = false;\n                    v.style.color = \"#2ea9df\";\n                }\n            });\n            if (!c) {\n                busy.dataset.status = \"2\";\n                busy.querySelector(\"span\").innerText = \"忙碌\";\n            }\n            this._ccNumber = c;\n            var userData = JSON.parse(localStorage.getItem(\"userData\"));\n            if (userData) {\n                userData.ccNumber = c;\n                localStorage.setItem(\"userData\", JSON.stringify(userData));\n            }\n            this.log(\"set ccNumber\", c);\n        }\n        /**\n         * \n         * @param {*呼入呼出页面交互} status \n         * progress 通话建立 但未接听 呼叫中\n         * accept:接听通话通话中 \n         * callfailed 呼叫失败\n         * callended 呼叫结束 \n         * \n         */\n        phoneStatus(callType, data) {\n            this.log(\"phoneStatus_\" + callType + \":\", data);\n            //外呼样式\n            var circleStatus = doc.querySelector(\"#PHONE-LEFT-STATUS>div[data-type='circle']>div\"); //左边状态显示\n            var rectStatus = doc.querySelector(\"#PHONE-LEFT-STATUS>div[data-type='rect']>div\");\n            var rectN = rectStatus.querySelector(\"span[data-type='number']\");\n            var rectS = rectStatus.querySelector(\"span[data-type='status']\");\n            var rectT = rectStatus.querySelector(\"span[data-type='times']\");\n            //呼入样式\n            var incomingStatus = doc.querySelector(\"#PHONE-LEFT-STATUS>div[data-type='incomingStatus']>div\");\n            var incomingBg = incomingStatus.querySelector(\"div[data-type='bg']\");\n            var incomingN = incomingStatus.querySelector(\"span[data-type='number']\");\n            var incomingS = incomingStatus.querySelector(\"span[data-type='status']\");\n            var incomingA = incomingStatus.querySelector(\"button[data-type='answer']\");\n            var call_bg = this.options.callBackground;\n            //通话中 拨号键\n            var planePageBtn = doc.querySelector(\"#PHONE-LEFT-STATUS>div[data-type='planePage']>div\");\n            var planePage = doc.querySelector(\"#PHONE-PANEL\");\n            //工具条按钮\n            var openBtn = doc.querySelector(\"li[data-phone-type='open']\");\n            var terminateBtn = doc.querySelector(\"li[data-phone-type='terminate']\");\n            var holdBtn = doc.querySelector(\"#EphoneBar li[data-phone-type='hold']\");\n            var unHoldBtn = doc.querySelector(\"#EphoneBar li[data-phone-type='unhold']\");\n            //pbx\n            switch (callType) {\n                //点击拨号\n                case \"outgoingCall\":\n                    rectStatus.dataset.hide = 1;\n                    rectStatus.style.background = call_bg[0];\n                    rectN.innerText = data.panelInput.length > 12 ? data.panelInput.substring(1, 12) + '...' : data.panelInput;\n                    rectS.innerText = \"呼叫中\";\n                    this.timerWatch(rectT, true);\n                    this.sethighlight(\"all\", true);\n                    this.setDisplayNone(\"all\");\n                    this.setArrowNone();\n                    if (this.outTimer) global.clearTimeout(this.outTimer);\n                    this.outTimer = global.setTimeout(() => {\n                        this.log(\"呼叫超时\");\n                        if (this.ccNumber) return;\n                        rectStatus.style.background = call_bg[2];\n                        rectS.innerText = \"呼叫超时\";\n                        this.timerWatch(rectT, false);\n                        global.clearTimeout(this.closeTimer);\n                        this.closeTimer = global.setTimeout(() => {\n                            rectStatus.dataset.hide = \"0\";\n                            openBtn.dataset.hide = '1';\n                            terminateBtn.dataset.hide = '0';\n                            this.sethighlight(\"register,open,setting\", true);\n                            this.setDisplayNone(\"all\");\n                        }, 2000);\n                    }, 15000); //服务器是10秒\n                    // Phone.changeStaus(\"2\")\n                    break;\n                //呼入 \n                case \"newPBXCall\":\n                    if (this.outTimer) global.clearTimeout(this.outTimer);\n                    var userData = JSON.parse(localStorage.userData);\n                    var allow_auto_answer = userData.epInfo.allow_auto_answer; //是否自动应答\n                    var auto_answer_duration = Number(userData.epInfo.auto_answer_duration); //时间\n                    var extension_start = parseInt(userData.epInfo.extension_start);\n                    var extension_end = parseInt(userData.epInfo.extension_end);\n                    var peerID = data.n.indexOf(\"_\") != -1 ? data.n.split(\"_\")[0] : data.n;\n                    this.callType = parseInt(peerID) >= extension_start && parseInt(peerID) <= extension_end ? 3 : 2;\n                    this.ccNumber = data.c;\n                    rectN.innerText = incomingN.innerText = peerID;\n                    openBtn.dataset.hide = '0';\n                    terminateBtn.dataset.hide = '1';\n                    this.sethighlight(\"terminate\", true);\n                    this.setDisplayNone(\"all\");\n                    this.setArrowNone();\n                    incomingStatus.dataset.hide = \"1\";\n                    incomingA.dataset.hide = '1';\n                    incomingA.dataset.disabled = \"1\";\n                    incomingBg.style.background = call_bg[0];\n                    incomingS.innerHTML = \"来电<span class='dotting'></span>\";\n\n                    if (allow_auto_answer == '1') {\n                        if (this.closeTimer) global.clearTimeout(this.closeTimer);\n                        this.closeTimer = global.setTimeout(() => {\n                            incomingA.click();\n                        }, auto_answer_duration * 1000);\n                    }\n\n                    break;\n                case 'cancelPBXCall':\n                    //  100和101消息一直发  在101处理逻辑这加一个延迟定时器，保证页面状态不变\n                    //  暂时没想到其他方法\n                    if (this.outTimer) global.clearTimeout(this.outTimer);\n                    this.outTimer = global.setTimeout(() => {\n                        this.ccNumber = undefined;\n                        this.sethighlight(\"all\", true);\n                        incomingA.dataset.hide = '0';\n                        incomingBg.style.background = call_bg[2];\n                        incomingS.innerHTML = \"来电未接听\";\n                        global.setTimeout(() => {\n                            incomingStatus.dataset.hide = \"0\";\n                            openBtn.dataset.hide = '1';\n                            terminateBtn.dataset.hide = '0';\n                            this.sethighlight(\"register,open,setting\", true);\n                        }, 2000);\n                    }, 2000);\n                    break;\n                case 'callinFaildResponse':\n                    break;\n                //呼出响应\n                case \"calloutResponse\": //呼出外线PBX响应\n                case \"callinResponse\":\n                    //呼出内线PBX响应\n                    global.clearTimeout(this.outTimer);\n                    global.clearTimeout(this.closeTimer);\n                    if (data.r != 200) {\n                        //200成功   503对象忙碌 509//非工作时间\n                        rectStatus.style.background = call_bg[2];\n                        switch (Number(data.r)) {\n                            case 509:\n                                rectS.innerText = \"非工作时间\";\n                                break;\n                            case 503:\n                                //内线离线 忙碌\n                                rectS.innerText = \"对方忙碌\";\n                                break;\n                            default:\n                                rectS.innerText = \"呼叫失败\";\n                                break;\n                        }\n                        this.closeTimer = global.setTimeout(() => {\n                            rectStatus.dataset.hide = \"0\";\n                            this.sethighlight(\"register,open,setting\", true);\n                            this.setDisplayNone(\"all\");\n                        }, 2000);\n                    } else {\n                        this.ccNumber = data.c;\n                        openBtn.dataset.hide = '0';\n                        terminateBtn.dataset.hide = '1';\n                        this.sethighlight(\"terminate,register\", true);\n                        this.setDisplayNone(\"all\");\n                        this.setArrowNone();\n                    }\n                    break;\n                //对方未接听 挂断\n                case '':\n                    break;\n                //通话已经建立接通\n                case 'answeredPBXCall':\n                    incomingStatus.dataset.hide = \"0\";\n                    rectStatus.dataset.hide = '1';\n                    rectStatus.style.background = call_bg[1];\n                    this.timerWatch(rectT, true);\n                    rectS.innerText = \"通话中\";\n                    this.callType == 2 ? this.sethighlight(\"register,terminate,hold,unhold,switch\", true) : this.sethighlight(\"register,terminate,hold,unhold\", true);\n                    break;\n                case \"endPBXCall\":\n                    this.ccNumber = undefined;\n                    // Phone.changeStaus(\"1\")\n                    this.setDisplayNone(\"all\");\n                    this.timerWatch(rectT, false);\n                    incomingStatus.dataset.hide = \"0\";\n                    rectStatus.dataset.hide = \"1\";\n                    rectStatus.style.background = call_bg[2];\n                    rectS.innerText = \"通话结束\";\n                    this.sethighlight(\"all\", true);\n                    global.clearTimeout(this.closeTimer);\n                    this.closeTimer = global.setTimeout(() => {\n                        rectStatus.dataset.hide = \"0\";\n                        openBtn.dataset.hide = '1';\n                        terminateBtn.dataset.hide = '0';\n                        unHoldBtn.dataset.hide = \"0\";\n                        holdBtn.dataset.hide = \"1\";\n                        this.sethighlight(\"register,open,setting\", true);\n                        if (data.type == \"kickOff\") {\n                            doc.querySelector(\"#EphoneBar li[data-phone-type='register'] span[data-type='toggle']\").dataset.hide = '0';\n                            this.sethighlight('register', true);\n                        }\n                    }, 2000);\n                    break;\n                // sessio\n                // 在接收或生成INVITE请求的1XX SIP类响应（> 100）时触发。\n                case 'progress':\n                    // Phone.incomingCall(true)\n                    // openBtn.dataset.hide = '0'\n                    // terminateBtn.dataset.hide = '1'\n                    // this.sethighlight(\"terminate\", true)\n                    // this.setDisplayNone(\"all\")\n                    // this.setArrowNone()\n                    break;\n                //本地接听\n                case 'accepted':\n                    break;\n                //结束\n                case 'ended':\n                    //\n                    this.ccNumber = undefined;\n                    break;\n                case 'failed':\n                    // planePageBtn.dataset.hide = '0'\n                    this.setDisplayNone(\"all\");\n                    this.timerWatch(rectT, false);\n                    incomingStatus.dataset.hide = \"0\";\n                    rectStatus.dataset.hide = \"1\";\n                    rectStatus.style.background = call_bg[2];\n                    rectS.innerText = \"通话结束\";\n                    this.ccNumber = undefined;\n                    this.sethighlight(\"all\", true);\n                    global.clearTimeout(this.closeTimer);\n                    // Phone.changeStaus(\"1\")\n                    this.closeTimer = global.setTimeout(() => {\n                        rectStatus.dataset.hide = \"0\";\n                        openBtn.dataset.hide = '1';\n                        terminateBtn.dataset.hide = '0';\n                        unHoldBtn.dataset.hide = \"0\";\n                        holdBtn.dataset.hide = \"1\";\n                        this.sethighlight(\"register,open,setting\", true);\n                    }, 2000);\n                    break;\n                // case \"hold\":\n                //     if (data.originator == \"local\") {\n                //         holdBtn.dataset.hide = \"0\"\n                //         unHoldBtn.dataset.hide = \"1\"\n                //     }\n                //     break;\n                // case \"unhold\":\n                //     if (data.originator == \"local\") {\n                //         holdBtn.dataset.hide = \"1\"\n                //         unHoldBtn.dataset.hide = \"0\"\n                //     }\n                //     break;\n                default:\n                    break;\n            }\n        }\n    }\n    global.$E = new Ephone();\n})(window, document);\n\n//# sourceURL=webpack:///./src/ui/index.js?");

/***/ }),

/***/ "./src/ui/phone.js":
/*!*************************!*\
  !*** ./src/ui/phone.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _index = __webpack_require__(/*! ../lib/index */ \"./src/lib/index.js\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Phone {\n    constructor() {\n        this._ua = new _index2.default(); //jssipwrapper实例 ._ua==UA实例\n        this._session = null; //当前会话\n        //0 就是sip没注册，一旦register成功我们会再马上发一条消息把自己状态设置为空闲\n        this.kefuStatus = 0; //会话状态   0 离线  1 空闲  2暂离\n        this.callType = \"2\"; // type = 1 外线拨号  type = 2 回拨  type = 3 内线互拨\n        //可能需要有一个标识当前会话是呼入还是呼出的设置，但不需要保存incomingSession\n        this.getLoginData = this._ua.webApi.getLoginData;\n        this.webApiHandler = this._ua.webApi.webApiHandler;\n        this.debug = _debug2.default;\n        this.log = this.debug(\"phone\");\n    }\n    // 注册,各种回调设置\n    init(params, cb) {\n        this.log(\"login param :\", params);\n        //登录状态的回调\n        let register = cb['register'];\n        this._ua.login(params, result => {\n            this.loginResult(result, register);\n        });\n        //状态，置忙置闲\n        this.kefuStatusChange(cb['statusEvent']);\n        //呼入会话监听\n        this.callEvent(cb['callEvent']);\n        // 被踢下线\n        let kickoff = cb['kickedOffLine'];\n        this._ua.on(\"kickedOffLine\", data => {\n            this.log(\"kickedOffLine, \", { data });\n            kickoff(data);\n        });\n    }\n    loginResult(result, cb) {\n        var code = result.code;\n        this.log(`UA ${result.code} event ${JSON.stringify(result.data)}`);\n        //try-it示例里有connected但未registered的状态，但目前对我们不太适用，如果没有注册，什么都干不了\n        //所以kefuStatus不维护 connected但未registered的状态的状态，0就是未注册\n        //registered后我们会马上发changeStaus(1)\n        switch (code) {\n            case 'connecting':\n                break;\n            case 'disconnected':\n                this.kefuStatus = 0;\n                break;\n            case 'connected':\n                break;\n            case 'registered':\n                this.log(\"registered: \", result.data.response.status_code, \",\", result.data.response.reason_phrase, { data: result.data });\n                cb({ code: result.data.response.status_code, info: \"登陆成功\", data: result.data });\n                break;\n            case 'registrationFailed':\n                this.kefuStatus = 0;\n                //原来给的301不对，301不是这个意思。另可参见jssip.js的 REASON_PHRASE\n                //我暂时用500\n                cb({ code: 500, info: \"登录失败\", data: result.data });\n                break;\n            // case 'registrationExpiring':\n            //     break;\n        }\n    }\n    //修改坐席状态，需要等服务器确认才能真正改变\n    changeStaus(status) {\n        this._ua.changeStaus(status, false);\n        this.log(`setchangeStaus:${status}, waiting for statusChanged callback`);\n    }\n    //状态   0 离线  1 空闲  2忙碌\n    kefuStatusChange(cb) {\n        //状态\n        this._ua.on('statusChanged', data => {\n            var toggleStatus = document.querySelector(\"li[data-phone-type='register'] span\");\n            var bgList = [\"#4bd966\", \"#fed300\"];\n            if (data.status == \"0\") {//等jsswrapper 没有返回状态\n\n            }\n            if (data.status == \"1\") {\n\n                toggleStatus.dataset.hide = '1';\n                toggleStatus.style.background = bgList[0];\n            }\n            if (data.status == \"2\") {\n\n                toggleStatus.dataset.hide = '1';\n                toggleStatus.style.background = bgList[1];\n            }\n            this.kefuStatus = parseInt(data.status);\n            // 状态改变，修改localStorage里的值\n            var obj = JSON.parse(localStorage.userData);\n\n            obj.status = data.status;\n            localStorage.setItem('userData', JSON.stringify(obj));\n            this.log('statusChanged:', data);\n        });\n\n        this._ua.on(\"changeStausLoginFailed\", data => {\n            //登录时预设设置状态失败，返回状态错误\n            // 状态改变，修改localStorage里的值\n            cb({ code: 302, info: data.response.reason_phrase, data: data });\n            this.log(\"changeStausLoginFailed:\", data);\n        });\n        this._ua.on(\"changeStausFailed\", data => {\n            //登录后设置状态失败，，暂不改UI\n            // 状态改变，修改localStorage里的值\n            this.log(\"changeStausFailed:\", data);\n        });\n    }\n    callEvent(cb) {\n        /*\n            newPBXCall 来电 100\n            cancelPBXCall 非voip 来电取消 任意一方主动挂断 未接 101\n            calloutResponse 座席外呼响应'201'\n            callinResponse 座席外呼响应(内线)'301'\n            callinFaildResponse 座席外呼响应(内线) 被叫超时未接听，，给主叫发 309  被叫发101\n            answeredPBXCall\n        */\n\n        let calltypes = ['newPBXCall', 'cancelPBXCall', 'calloutResponse', 'callinFaildResponse', 'answeredPBXCall', 'endPBXCall', 'callinResponse'];\n        for (let type of calltypes) {\n            this._ua.on(type, data => {\n                //呼叫接通等待接听\n                //cb => phoneStatus\n                if (type == \"endPBXCall\") this.session = null;\n                cb(type, data);\n            });\n        }\n        let incomingEvent = ['progress', 'connecting', 'accepted', 'failed', 'ended', 'newDTMF'];\n        this._ua.on('incomingCall', data => {\n            this.log('incomingCall: ', data.originator + \":\", { data });\n            if (data.originator === 'local') return;\n            let session = data.session;\n            // 这个判断可能还是需要\n            // if (this.session || this.incomingSession) {\n            //     that.log('\"Busy Here\"');\n            //     session.terminate(\n            //         {\n            //             status_code: 486,\n            //             reason_phrase: 'Busy Here'\n            //         });\n            //     return;\n            // }\n            this.session = session; //只有呼入的会话\n            for (let type of incomingEvent) {\n                this.session.on(type, data => {\n                    //呼叫接通等待接听\n                    cb(type, data);\n                });\n            }\n        });\n    }\n    //打电话\n    call(params) {\n        this.callType = params.callType;\n        this._ua.call(params.peerID, this.callType, {});\n        this.log(\"call to:\", { peerID: params.peerID, callType: this.callType });\n    }\n    //会话接听\n    answerPBXCall(ccNumber) {\n        this._ua.answerPBXCall(ccNumber);\n    }\n    sendDTMF(num) {\n        //示例，sip服务器未实现\n        var extraHeaders = ['X-Foo: foo', 'X-Bar: bar'];\n        var options = {\n            'duration': 160,\n            'interToneGap': 1200,\n            'extraHeaders': extraHeaders\n        };\n        // if (this.session )\n        this.session.sendDTMF(num);\n        this.log(\"sendDTMF\", num + '');\n    }\n\n    //挂断 需要发送给pbx 挂断状态处理消息\n    terminate(c) {\n        var userData = JSON.parse(localStorage.getItem(\"userData\"));\n        var ccNumber = c || this.session.ccNumber || userData.ccNumber;\n        if (ccNumber) {\n            this._ua.hangUpPBXCall(ccNumber);\n        }\n        this.log(\"terminate\", { ccNumber: ccNumber });\n    }\n    // 注销\n    stop(cb) {\n        //在回调里才设置 kefuStatus=0 保证是服务器确认下线\n        //但我的担心是如果因为网络原因（最大可能），没有收到回调，这时候其实就应该是下线了\n        this.kefuStatus = 0;\n        if (!this._ua._ua.isRegistered()) return;\n        this._ua.stop(res => {\n            cb(res);\n        });\n    }\n    //呼叫保持\n    hold(ccNumber) {\n        if (!ccNumber) return;\n        this._ua.holdPBXCall(ccNumber);\n        this.log(\"hold\", ccNumber);\n        // if (!this.session) return\n        // this.session.hold()\n    }\n    unhold(ccNumber) {\n        if (!ccNumber) return;\n        this._ua.unholdPBXCall(ccNumber);\n        this.log(\"unhold\", ccNumber);\n        // if (!this.session) return\n        // this.session.unhold()\n    }\n    //转接\n    /**\n     * ccNumber\n     * gid\n     * tranNumber\n     */\n    transferPBXCall(gid, tranNumber, ccNumber, cb) {\n        // gid = '2059'\n        // tranNumber = '1023'\n        if (ccNumber) {\n            this._ua.transferPBXCall(ccNumber, gid, tranNumber);\n            // this._ua.on(\"\")\n            this._ua.once(\"transferCallSuccess\", data => {\n                this.log('transferCallSuccess(电话转接成功)', data);\n                cb({ type: \"transferCallSuccess\", data });\n            });\n            this._ua.once(\"transferCallFaild\", data => {\n                this.log('transferCallFaild(电话转接失败)', data);\n                cb({ type: \"transferCallFaild\", data });\n            });\n        }\n    }\n    preSetStatus(params, cb) {\n        this._ua.preSetStatus(params.ccNumber, params.code);\n        //通话中设置状态 87 \n        this._ua.once(\"preSetStatusResponse\", data => {\n            if (data.a == \"87\" && data.r) {\n                cb({ code: data.r });\n            } else {\n                //非收到PBX的远程消息\n                cb({ code: 50006 });\n            }\n            this.log(\"preSetStatusResponse\", data);\n        });\n    }\n\n    // 修改坐席模式\n    setSeatMode(seatMode) {\n        this._ua.setSeatMode(seatMode, false);\n        this.log(\"setSeatMode:\", seatMode);\n    }\n\n    get session() {\n        return this._session;\n    }\n    set session(session) {\n\n        this._session = session;\n        this.log(\"session change:\", session);\n    }\n\n}\nexports.default = new Phone();\n\n//# sourceURL=webpack:///./src/ui/phone.js?");

/***/ })

/******/ });